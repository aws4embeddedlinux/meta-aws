From e92179c5533401b2fe443a7c6a1c6ae69fc908aa Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Fri, 25 Jun 2021 17:12:27 -0700
Subject: [PATCH] Add 256-bit and 384-bit big-endian conversions

The functions are called "bignum_bigendian_4" (4 words = 256 bits) and
"bignum_bigendian_6" (6 words = 384 bits), with additional aliases
using names "...frombytes..." and "...tobytes...", treating either
input or output as a byte array (exactly the same code, but with a
different type in the C prototype). Each such alias has its own
variant correctness theorem stated slightly differently.

Although they are not specific to the P-256 and P-384 primes (only
their native sizes) they are located in the respective "p256" and
"p384" subdirectories, since the main anticipated uses are in
connection with those primes.

For a little-endian platform, these always amount to byte reversal.
The ARM code has not been tested in a big-endian instantiation, and
since the current ARM model assumes little-endianness a priori,
neither has it been verified in a big-endian setting, but it is
supposed to work there. This is not relevant for x86, which is always
little-endian.

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/99cd9044f288de42d3e317f04d9a13bf86754614
---
 arm/p384/Makefile             |   1 +
 arm/p384/bignum_bigendian_6.S | 100 ++++++++++++++++++++++++++++++++++
 2 files changed, 101 insertions(+)
 create mode 100644 arm/p384/bignum_bigendian_6.S

diff --git a/arm/p384/Makefile b/arm/p384/Makefile
index 91c7a4c6e..33fbe6c6d 100644
--- a/arm/p384/Makefile
+++ b/arm/p384/Makefile
@@ -34,6 +34,7 @@ endif
 OBJ = bignum_add_p384.o \
       bignum_amontmul_p384.o \
       bignum_amontsqr_p384.o \
+      bignum_bigendian_6.o \
       bignum_cmul_p384.o \
       bignum_deamont_p384.o \
       bignum_demont_p384.o \
diff --git a/arm/p384/bignum_bigendian_6.S b/arm/p384/bignum_bigendian_6.S
new file mode 100644
index 000000000..652441a0f
--- /dev/null
+++ b/arm/p384/bignum_bigendian_6.S
@@ -0,0 +1,100 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert 6-digit (384-bit) bignum to/from big-endian form
+// Input x[6]; output z[6]
+//
+//    extern void bignum_bigendian_6
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// The same function is given two other prototypes whose names reflect the
+// treatment of one or other argument as a byte array rather than word array:
+//
+//    extern void bignum_frombytes_6
+//     (uint64_t z[static 6], uint8_t x[static 48]);
+//
+//    extern void bignum_tobytes_6
+//     (uint8_t z[static 48], uint64_t x[static 6]);
+//
+// The implementation works by loading in bytes and storing in words (i.e.
+// stylistically it is "frombytes"); in the more common little-endian
+// usage of ARM, this is just byte reversal.
+//
+// Standard ARM ABI: X0 = z, X1 = x
+// ----------------------------------------------------------------------------
+
+.text
+.globl bignum_bigendian_6
+.globl bignum_frombytes_6
+.globl bignum_tobytes_6
+
+#define z x0
+#define x x1
+
+#define d x2
+#define dshort w2
+#define a x3
+#define c x4
+
+.macro accumdigit dest, i
+        ldrb    dshort, [x, 8 * \i + 7]
+        extr    \dest, d, xzr, 8
+        ldrb    dshort, [x, 8 * \i + 6]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 5]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 4]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 3]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 2]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 1]
+        extr    \dest, d, \dest, 8
+        ldrb    dshort, [x, 8 * \i + 0]
+        extr    \dest, d, \dest, 8
+.endm
+
+// The reads and writes are organized in mirror-image pairs (0-5, 1-4, 2-3)
+// to allow x and z to point to the same buffer without using more
+// intermediate registers.
+
+bignum_bigendian_6:
+bignum_frombytes_6:
+bignum_tobytes_6:
+
+// 0 and 5 words
+
+                accumdigit a, 0
+                accumdigit c, 5
+                str     a, [z, 8*5]
+                str     c, [z, 8*0]
+
+// 1 and 4 words
+
+                accumdigit a, 1
+                accumdigit c, 4
+                str     a, [z, 8*4]
+                str     c, [z, 8*1]
+
+// 2 and 3 words
+
+                accumdigit a, 2
+                accumdigit c, 3
+                str     a, [z, 8*3]
+                str     c, [z, 8*2]
+
+                ret
