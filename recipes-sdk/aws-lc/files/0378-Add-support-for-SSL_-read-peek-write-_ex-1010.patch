From 069b4eaf6c70108211e1f7c3c0c071ae4b126093 Mon Sep 17 00:00:00 2001
From: Samuel Chiang <sachiang@amazon.com>
Date: Mon, 22 May 2023 22:04:38 -0700
Subject: [PATCH] Add support for SSL_(read/peek/write)_ex (#1010)

mySQL consumes the SSL_(read/peek/write)_ex family of APIs from OpenSSL.
These are similar to the existing SSL_(read/peek/write) APIs in AWS-LC,
but have slightly different expected parameters and function signatures.
Since these have the same underlying operations, I just wrapped
SSL_*_ex around it's respective SSL_* operation.
---
 include/openssl/ssl.h | 27 +++++++++++++++++++++++++
 ssl/ssl_lib.cc        | 27 +++++++++++++++++++++++++
 ssl/ssl_test.cc       | 46 +++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 100 insertions(+)

diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index 9a7f2a556..b96f2d38f 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -372,9 +372,27 @@ OPENSSL_EXPORT int SSL_accept(SSL *ssl);
 // https://crbug.com/466303.
 OPENSSL_EXPORT int SSL_read(SSL *ssl, void *buf, int num);
 
+// SSL_read_ex reads up to |num| bytes from |ssl| into |buf|. It is similar to
+// |SSL_read|, but instead of returning the number of bytes read, it returns
+// 1 on success or 0 for failure. The number of bytes actually read is stored in
+// |read_bytes|.
+//
+// This is only maintained for OpenSSL compatibility. Use |SSL_read| instead.
+OPENSSL_EXPORT int SSL_read_ex(SSL *ssl, void *buf, size_t num,
+                               size_t *read_bytes);
+
 // SSL_peek behaves like |SSL_read| but does not consume any bytes returned.
 OPENSSL_EXPORT int SSL_peek(SSL *ssl, void *buf, int num);
 
+// SSL_peek_ex reads up to |num| bytes from |ssl| into |buf|. It is similar to
+// |SSL_peek|, but instead of returning the number of bytes read, it returns
+// 1 on success or 0 for failure. The number of bytes actually read is stored in
+// |read_bytes|.
+//
+// This is only maintained for OpenSSL compatibility. Use |SSL_peek| instead.
+OPENSSL_EXPORT int SSL_peek_ex(SSL *ssl, void *buf, size_t num,
+                               size_t *read_bytes);
+
 // SSL_pending returns the number of buffered, decrypted bytes available for
 // read in |ssl|. It does not read from the transport.
 //
@@ -428,6 +446,15 @@ OPENSSL_EXPORT int SSL_has_pending(const SSL *ssl);
 // https://crbug.com/466303.
 OPENSSL_EXPORT int SSL_write(SSL *ssl, const void *buf, int num);
 
+// SSL_write_ex writes up to |num| bytes from |buf| into |ssl|. It is similar to
+// |SSL_write|, but instead of returning the number of bytes written, it returns
+// 1 on success or 0 for failure. The number bytes actually written is stored in
+// |written|.
+//
+// This is only maintained for OpenSSL compatibility. Use |SSL_write| instead.
+OPENSSL_EXPORT int SSL_write_ex(SSL *s, const void *buf, size_t num,
+                                size_t *written);
+
 // SSL_KEY_UPDATE_REQUESTED indicates that the peer should reply to a KeyUpdate
 // message with its own, thus updating traffic secrets for both directions on
 // the connection.
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index 6f222ff50..ccf55ff63 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -1006,6 +1006,15 @@ static int ssl_read_impl(SSL *ssl) {
   return 1;
 }
 
+int SSL_read_ex(SSL *ssl, void *buf, size_t num, size_t *read_bytes) {
+  int ret = SSL_read(ssl, buf, (int)num);
+  if (ret <= 0) {
+    return 0;
+  }
+  *read_bytes = ret;
+  return 1;
+}
+
 int SSL_read(SSL *ssl, void *buf, int num) {
   int ret = SSL_peek(ssl, buf, num);
   if (ret <= 0) {
@@ -1040,6 +1049,15 @@ int SSL_peek(SSL *ssl, void *buf, int num) {
   return static_cast<int>(todo);
 }
 
+int SSL_peek_ex(SSL *ssl, void *buf, size_t num, size_t *read_bytes) {
+  int ret = SSL_peek(ssl, buf, (int)num);
+  if (ret <= 0) {
+    return 0;
+  }
+  *read_bytes = ret;
+  return 1;
+}
+
 int SSL_write(SSL *ssl, const void *buf, int num) {
   ssl_reset_error_state(ssl);
 
@@ -1081,6 +1099,15 @@ int SSL_write(SSL *ssl, const void *buf, int num) {
   return ret <= 0 ? ret : static_cast<int>(bytes_written);
 }
 
+int SSL_write_ex(SSL *ssl, const void *buf, size_t num, size_t *written) {
+  int ret = SSL_write(ssl, buf, (int)num);
+  if (ret <= 0) {
+    return 0;
+  }
+  *written = ret;
+  return 1;
+}
+
 int SSL_key_update(SSL *ssl, int request_type) {
   ssl_reset_error_state(ssl);
 
diff --git a/ssl/ssl_test.cc b/ssl/ssl_test.cc
index d714850ba..4ef5834cb 100644
--- a/ssl/ssl_test.cc
+++ b/ssl/ssl_test.cc
@@ -5552,6 +5552,52 @@ TEST_P(SSLVersionTest, SSLPending) {
   EXPECT_EQ(1, SSL_has_pending(client_.get()));
 }
 
+// Identical test to the |SSLPending| test suite above, but with
+// |SSL_(read/peek/write)_ex| operations instead.
+TEST_P(SSLVersionTest, SSLPendingEx) {
+  UniquePtr<SSL> ssl(SSL_new(client_ctx_.get()));
+  ASSERT_TRUE(ssl);
+  EXPECT_EQ(0, SSL_pending(ssl.get()));
+
+  ASSERT_TRUE(Connect());
+  EXPECT_EQ(0, SSL_pending(client_.get()));
+  EXPECT_EQ(0, SSL_has_pending(client_.get()));
+
+  size_t buf_len;
+  ASSERT_EQ(1, SSL_write_ex(server_.get(), "hello", 5, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)5);
+  ASSERT_EQ(1, SSL_write_ex(server_.get(), "world", 5, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)5);
+
+  EXPECT_EQ(0, SSL_pending(client_.get()));
+  EXPECT_EQ(0, SSL_has_pending(client_.get()));
+
+  char buf[10];
+  ASSERT_EQ(1, SSL_peek_ex(client_.get(), buf, 1, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)1);
+  EXPECT_EQ(5, SSL_pending(client_.get()));
+  EXPECT_EQ(1, SSL_has_pending(client_.get()));
+
+  ASSERT_EQ(1, SSL_read_ex(client_.get(), buf, 1, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)1);
+  EXPECT_EQ(4, SSL_pending(client_.get()));
+  EXPECT_EQ(1, SSL_has_pending(client_.get()));
+
+  ASSERT_EQ(1, SSL_read_ex(client_.get(), buf, 10, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)4);
+  EXPECT_EQ(0, SSL_pending(client_.get()));
+  if (is_dtls()) {
+    EXPECT_EQ(1, SSL_has_pending(client_.get()));
+  } else {
+    EXPECT_EQ(0, SSL_has_pending(client_.get()));
+  }
+
+  ASSERT_EQ(1, SSL_read_ex(client_.get(), buf, 2, &buf_len));
+  ASSERT_EQ(buf_len, (size_t)2);
+  EXPECT_EQ(3, SSL_pending(client_.get()));
+  EXPECT_EQ(1, SSL_has_pending(client_.get()));
+}
+
 // Test that post-handshake tickets consumed by |SSL_shutdown| are ignored.
 TEST(SSLTest, ShutdownIgnoresTickets) {
   bssl::UniquePtr<SSL_CTX> ctx(CreateContextWithTestCertificate(TLS_method()));
