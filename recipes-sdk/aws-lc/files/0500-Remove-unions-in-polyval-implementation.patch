From 21cbe35794b547d74eb222e81d56ee2266942a4e Mon Sep 17 00:00:00 2001
From: David Benjamin <davidben@google.com>
Date: Tue, 2 May 2023 18:28:15 -0400
Subject: [PATCH] Remove unions in polyval implementation

This can be done with just memcpy, which tempts the compiler slightly
less.

Bug: 574
Change-Id: I7b46c2f2578abc85621834426de20d5eaf492a74
Reviewed-on: https://boringssl-review.googlesource.com/c/boringssl/+/59527
Reviewed-by: Adam Langley <agl@google.com>
Commit-Queue: David Benjamin <davidben@google.com>
(cherry picked from commit 85e6453cc3b940b2151681f55e698b625be0d723)
---
 crypto/fipsmodule/modes/internal.h |  7 +---
 crypto/fipsmodule/modes/polyval.c  | 52 +++++++++++++++---------------
 2 files changed, 27 insertions(+), 32 deletions(-)

diff --git a/crypto/fipsmodule/modes/internal.h b/crypto/fipsmodule/modes/internal.h
index f2563d6bf..a90020975 100644
--- a/crypto/fipsmodule/modes/internal.h
+++ b/crypto/fipsmodule/modes/internal.h
@@ -453,13 +453,8 @@ size_t CRYPTO_xts128_encrypt(const XTS128_CONTEXT *ctx,
 // similar to the one that GHASH uses. See
 // https://www.rfc-editor.org/rfc/rfc8452.html#section-3.
 
-typedef union {
-  uint64_t u[2];
-  uint8_t c[16];
-} polyval_block;
-
 struct polyval_ctx {
-  polyval_block S;
+  uint64_t S[2];
   // |gcm_*_ssse3| require |Htable| to be 16-byte-aligned.
   // TODO(crbug.com/boringssl/604): Revisit this.
   alignas(16) u128 Htable[16];
diff --git a/crypto/fipsmodule/modes/polyval.c b/crypto/fipsmodule/modes/polyval.c
index a637188cd..4e5322298 100644
--- a/crypto/fipsmodule/modes/polyval.c
+++ b/crypto/fipsmodule/modes/polyval.c
@@ -22,26 +22,27 @@
 
 
 // byte_reverse reverses the order of the bytes in |b->c|.
-static void byte_reverse(polyval_block *b) {
-  const uint64_t t = CRYPTO_bswap8(b->u[0]);
-  b->u[0] = CRYPTO_bswap8(b->u[1]);
-  b->u[1] = t;
+static void byte_reverse(uint8_t b[16]) {
+  uint64_t hi = CRYPTO_load_u64_le(b);
+  uint64_t lo = CRYPTO_load_u64_le(b + 8);
+  CRYPTO_store_u64_le(b, CRYPTO_bswap8(lo));
+  CRYPTO_store_u64_le(b + 8, CRYPTO_bswap8(hi));
 }
 
-// reverse_and_mulX_ghash interprets the bytes |b->c| as a reversed element of
-// the GHASH field, multiplies that by 'x' and serialises the result back into
-// |b|, but with GHASH's backwards bit ordering.
-static void reverse_and_mulX_ghash(polyval_block *b) {
-  uint64_t hi = b->u[0];
-  uint64_t lo = b->u[1];
+// reverse_and_mulX_ghash interprets |b| as a reversed element of the GHASH
+// field, multiplies that by 'x' and serialises the result back into |b|, but
+// with GHASH's backwards bit ordering.
+static void reverse_and_mulX_ghash(uint8_t b[16]) {
+  uint64_t hi = CRYPTO_load_u64_le(b);
+  uint64_t lo = CRYPTO_load_u64_le(b + 8);
   const crypto_word_t carry = constant_time_eq_w(hi & 1, 1);
   hi >>= 1;
   hi |= lo << 63;
   lo >>= 1;
   lo ^= ((uint64_t) constant_time_select_w(carry, 0xe1, 0)) << 56;
 
-  b->u[0] = CRYPTO_bswap8(lo);
-  b->u[1] = CRYPTO_bswap8(hi);
+  CRYPTO_store_u64_le(b, CRYPTO_bswap8(lo));
+  CRYPTO_store_u64_le(b + 8, CRYPTO_bswap8(hi));
 }
 
 // POLYVAL(H, X_1, ..., X_n) =
@@ -51,40 +52,39 @@ static void reverse_and_mulX_ghash(polyval_block *b) {
 // See https://www.rfc-editor.org/rfc/rfc8452.html#appendix-A.
 
 void CRYPTO_POLYVAL_init(struct polyval_ctx *ctx, const uint8_t key[16]) {
-  polyval_block H;
-  OPENSSL_memcpy(H.c, key, 16);
-  reverse_and_mulX_ghash(&H);
+  alignas(8) uint8_t H[16];
+  OPENSSL_memcpy(H, key, 16);
+  reverse_and_mulX_ghash(H);
 
   int is_avx;
-  CRYPTO_ghash_init(&ctx->gmult, &ctx->ghash, ctx->Htable, &is_avx, H.c);
+  CRYPTO_ghash_init(&ctx->gmult, &ctx->ghash, ctx->Htable, &is_avx, H);
   OPENSSL_memset(&ctx->S, 0, sizeof(ctx->S));
 }
 
 void CRYPTO_POLYVAL_update_blocks(struct polyval_ctx *ctx, const uint8_t *in,
                                   size_t in_len) {
   assert((in_len & 15) == 0);
-  polyval_block reversed[32];
+  alignas(8) uint8_t buf[32 * 16];
 
   while (in_len > 0) {
     size_t todo = in_len;
-    if (todo > sizeof(reversed)) {
-      todo = sizeof(reversed);
+    if (todo > sizeof(buf)) {
+      todo = sizeof(buf);
     }
-    OPENSSL_memcpy(reversed, in, todo);
+    OPENSSL_memcpy(buf, in, todo);
     in += todo;
     in_len -= todo;
 
-    size_t blocks = todo / sizeof(polyval_block);
+    size_t blocks = todo / 16;
     for (size_t i = 0; i < blocks; i++) {
-      byte_reverse(&reversed[i]);
+      byte_reverse(buf + 16 * i);
     }
 
-    ctx->ghash(ctx->S.u, ctx->Htable, (const uint8_t *) reversed, todo);
+    ctx->ghash(ctx->S, ctx->Htable, buf, todo);
   }
 }
 
 void CRYPTO_POLYVAL_finish(const struct polyval_ctx *ctx, uint8_t out[16]) {
-  polyval_block S = ctx->S;
-  byte_reverse(&S);
-  OPENSSL_memcpy(out, &S.c, sizeof(polyval_block));
+  OPENSSL_memcpy(out, &ctx->S, 16);
+  byte_reverse(out);
 }
