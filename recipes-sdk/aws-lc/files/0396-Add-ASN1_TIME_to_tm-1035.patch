From 25260d785f6e2eaf3c5f5dce83cf92c272f0a8b1 Mon Sep 17 00:00:00 2001
From: Andrew Hopkins <andhop@amazon.com>
Date: Tue, 30 May 2023 16:42:24 -0700
Subject: [PATCH] Add ASN1_TIME_to_tm (#1035)

---
 crypto/asn1/a_time.c     |  4 ++
 crypto/asn1/asn1_test.cc | 96 ++++++++++++++++++++++++++++++++--------
 crypto/asn1/internal.h   |  2 +-
 crypto/asn1/posix_time.c |  7 ++-
 include/openssl/asn1.h   | 16 +++++++
 5 files changed, 105 insertions(+), 20 deletions(-)

diff --git a/crypto/asn1/a_time.c b/crypto/asn1/a_time.c
index f5304f55b..d8c38f616 100644
--- a/crypto/asn1/a_time.c
+++ b/crypto/asn1/a_time.c
@@ -208,6 +208,10 @@ int ASN1_TIME_diff(int *out_days, int *out_seconds, const ASN1_TIME *from,
 // slightly different than the many other copies of X.509 time validation
 // sprinkled through the codebase. The custom checks in X509_cmp_time meant that
 // it did not allow four digit timezone offsets in UTC times.
+int ASN1_TIME_to_tm(const ASN1_TIME *s, struct tm *tm) {
+  return asn1_time_to_tm(tm, s, /*allow_timezone_offset=*/0);
+}
+
 int ASN1_TIME_to_time_t(const ASN1_TIME *t, time_t *out_time) {
   struct tm tm;
   if (!asn1_time_to_tm(&tm, t, /*allow_timezone_offset=*/0)) {
diff --git a/crypto/asn1/asn1_test.cc b/crypto/asn1/asn1_test.cc
index 733150464..ba0173f30 100644
--- a/crypto/asn1/asn1_test.cc
+++ b/crypto/asn1/asn1_test.cc
@@ -965,40 +965,75 @@ static std::string PrintStringToBIO(const ASN1_STRING *str,
   return std::string(data, data + len);
 }
 
+// MSVC 2015 does not support compound literals e.g. using (struct tm){0,0,...}}
+// in the list of test vectors below. Note: this returns  a copy of the stack
+// allocated value t.
+static struct tm make_tm(int sec, int min, int hour, int mday, int mon, int year, int wday, int yday, int isdst, long gmtoff, char* zone) {
+  struct tm t;
+  t.tm_sec = sec;
+  t.tm_min = min;
+  t.tm_hour = hour;
+  t.tm_mday = mday;
+  t.tm_mon = mon;
+  t.tm_year = year;
+  t.tm_wday = wday;
+  t.tm_yday = yday;
+  t.tm_isdst = isdst;
+#if defined(__GNUC__)
+  t.tm_gmtoff = gmtoff;
+  t.tm_zone = zone;
+#endif
+  return t;
+}
+
 TEST(ASN1Test, SetTime) {
   static const struct {
     int64_t time;
     const char *generalized;
     const char *utc;
     const char *printed;
+    const struct tm expected_tm;
+    // struct tm years are deltas from 1900 and months start at 0
+    // AWS-LC does not calculate or set year day, weekday, timezone, or daylight savings
   } kTests[] = {
-      {-631152001, "19491231235959Z", nullptr, "Dec 31 23:59:59 1949 GMT"},
-      {-631152000, "19500101000000Z", "500101000000Z",
-       "Jan  1 00:00:00 1950 GMT"},
-      {0, "19700101000000Z", "700101000000Z", "Jan  1 00:00:00 1970 GMT"},
-      {981173106, "20010203040506Z", "010203040506Z",
-       "Feb  3 04:05:06 2001 GMT"},
-      {951804000, "20000229060000Z", "000229060000Z",
-       "Feb 29 06:00:00 2000 GMT"},
+      {-631152001, "19491231235959Z", nullptr, "Dec 31 23:59:59 1949 GMT",
+       make_tm(59, 59, 23, 31, 11, 49, 0, 0, 0, 0, nullptr)},
+      {-631152000, "19500101000000Z", "500101000000Z", "Jan  1 00:00:00 1950 GMT",
+       make_tm(0, 0, 0, 1, 0, 50, 0, 0, 0, 0, nullptr)},
+      {0, "19700101000000Z", "700101000000Z", "Jan  1 00:00:00 1970 GMT",
+       make_tm(0, 0, 0, 1, 0, 70, 0, 0, 0, 0, nullptr)},
+      {981173106, "20010203040506Z", "010203040506Z", "Feb  3 04:05:06 2001 GMT",
+       make_tm(6, 5, 4, 3, 1, 101, 0, 0, 0, 0, nullptr)},
+      {951804000, "20000229060000Z", "000229060000Z", "Feb 29 06:00:00 2000 GMT",
+       make_tm(0, 0, 6, 29, 1, 100, 0, 0, 0, 0, nullptr)},
       // NASA says this is the correct time for posterity.
-      {-16751025, "19690621025615Z", "690621025615Z",
-       "Jun 21 02:56:15 1969 GMT"},
+      {-16751025, "19690621025615Z", "690621025615Z", "Jun 21 02:56:15 1969 GMT",
+       make_tm(15, 56, 2, 21, 5, 69, 0, 0, 0, 0, nullptr)},
       // -1 is sometimes used as an error value. Ensure we correctly handle it.
-      {-1, "19691231235959Z", "691231235959Z", "Dec 31 23:59:59 1969 GMT"},
-      {2524607999, "20491231235959Z", "491231235959Z",
-       "Dec 31 23:59:59 2049 GMT"},
-      {2524608000, "20500101000000Z", nullptr, "Jan  1 00:00:00 2050 GMT"},
+      {-1, "19691231235959Z", "691231235959Z", "Dec 31 23:59:59 1969 GMT",
+       make_tm(59, 59, 23, 31, 11, 69, 0, 0, 0, 0, nullptr)},
+      {2524607999, "20491231235959Z", "491231235959Z", "Dec 31 23:59:59 2049 GMT",
+       make_tm(59, 59, 23, 31, 11, 149, 0, 0, 0, 0, nullptr)},
+      {2524608000, "20500101000000Z", nullptr, "Jan  1 00:00:00 2050 GMT",
+       make_tm(0, 0, 0, 1, 0, 150, 0, 0, 0, 0, nullptr)},
       // Test boundary conditions.
-      {-62167219200, "00000101000000Z", nullptr, "Jan  1 00:00:00 0 GMT"},
-      {-62167219201, nullptr, nullptr, nullptr},
-      {253402300799, "99991231235959Z", nullptr, "Dec 31 23:59:59 9999 GMT"},
-      {253402300800, nullptr, nullptr, nullptr},
+      {-62167219200, "00000101000000Z", nullptr, "Jan  1 00:00:00 0 GMT",
+       make_tm(0, 0, 0, 1, 0, -1900, 0, 0, 0, 0, nullptr)},
+      {-62167219201, nullptr, nullptr, nullptr,
+       make_tm(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, nullptr)},
+      {253402300799, "99991231235959Z", nullptr, "Dec 31 23:59:59 9999 GMT",
+       make_tm(59, 59, 23, 31, 11, 8099, 0, 0, 0, 0, nullptr)},
+      {253402300800, nullptr, nullptr, nullptr,
+       make_tm(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, nullptr)},
   };
   for (const auto &t : kTests) {
     int64_t tt;
+    struct tm actual_time_t;
+    OPENSSL_memset(&actual_time_t, 0, sizeof(actual_time_t));
     SCOPED_TRACE(t.time);
 
     bssl::UniquePtr<ASN1_UTCTIME> utc(ASN1_UTCTIME_set(nullptr, t.time));
+
     if (t.utc) {
       ASSERT_TRUE(utc);
       EXPECT_EQ(V_ASN1_UTCTIME, ASN1_STRING_type(utc.get()));
@@ -1008,6 +1043,8 @@ TEST(ASN1Test, SetTime) {
       EXPECT_EQ(tt, t.time);
       EXPECT_EQ(PrintStringToBIO(utc.get(), &ASN1_UTCTIME_print), t.printed);
       EXPECT_EQ(PrintStringToBIO(utc.get(), &ASN1_TIME_print), t.printed);
+      EXPECT_EQ(ASN1_TIME_to_tm(utc.get(), &actual_time_t), 1);
+      EXPECT_EQ(OPENSSL_memcmp(&t.expected_tm, &actual_time_t, sizeof(actual_time_t)), 0);
     } else {
       EXPECT_FALSE(utc);
     }
@@ -1026,6 +1063,8 @@ TEST(ASN1Test, SetTime) {
           t.printed);
       EXPECT_EQ(PrintStringToBIO(generalized.get(), &ASN1_TIME_print),
                 t.printed);
+      EXPECT_EQ(ASN1_TIME_to_tm(generalized.get(), &actual_time_t), 1);
+      EXPECT_EQ(OPENSSL_memcmp(&t.expected_tm, &actual_time_t, sizeof(actual_time_t)), 0);
     } else {
       EXPECT_FALSE(generalized);
     }
@@ -1043,12 +1082,33 @@ TEST(ASN1Test, SetTime) {
       EXPECT_TRUE(ASN1Time_check_posix(choice.get(), t.time));
       EXPECT_EQ(ASN1_TIME_to_posix(choice.get(), &tt), 1);
       EXPECT_EQ(tt, t.time);
+      EXPECT_EQ(ASN1_TIME_to_tm(choice.get(), &actual_time_t), 1);
+      EXPECT_EQ(OPENSSL_memcmp(&t.expected_tm, &actual_time_t, sizeof(actual_time_t)), 0);
     } else {
       EXPECT_FALSE(choice);
     }
   }
 }
 
+TEST(ASN1Test, ASN1_TIME_to_tm_default_behavior) {
+  struct tm actual_time_t;
+  OPENSSL_memset(&actual_time_t, 0, sizeof(actual_time_t));
+  // null ASN1_TIME should use the current time
+  EXPECT_EQ(ASN1_TIME_to_tm(nullptr, &actual_time_t), 1);
+  // The current time should be some point before 1900 (year 0)
+  EXPECT_GE(actual_time_t.tm_year, 0);
+
+  // null struct tm should just check that ASN1_TIME is valid
+  bssl::UniquePtr<ASN1_UTCTIME> date(ASN1_UTCTIME_set(nullptr, 1685142702));
+  EXPECT_EQ(ASN1_TIME_to_tm(date.get(), nullptr), 1);
+
+  // Make date an unknown type
+  date.get()->type = -100000000;
+  EXPECT_EQ(ASN1_TIME_to_tm(date.get(), nullptr), 0);
+
+  EXPECT_EQ(ASN1_TIME_to_tm(nullptr, nullptr), 0);
+}
+
 TEST(ASN1Test, TimeSetString) {
   bssl::UniquePtr<ASN1_STRING> s(ASN1_STRING_new());
   ASSERT_TRUE(s);
diff --git a/crypto/asn1/internal.h b/crypto/asn1/internal.h
index e32cc05e2..9fd8134a9 100644
--- a/crypto/asn1/internal.h
+++ b/crypto/asn1/internal.h
@@ -71,7 +71,7 @@ extern "C" {
 
 // Wrapper functions for time functions.
 
-// OPENSSL_posix_to_tm converts a int64_t POSIX time value in |time| whuch must
+// OPENSSL_posix_to_tm converts a int64_t POSIX time value in |time| which must
 // be in the range of year 0000 to 9999 to a broken out time value in |tm|. It
 // returns one on success and zero on error.
 OPENSSL_EXPORT int OPENSSL_posix_to_tm(int64_t time, struct tm *out_tm);
diff --git a/crypto/asn1/posix_time.c b/crypto/asn1/posix_time.c
index 5999bd62c..556a25cb7 100644
--- a/crypto/asn1/posix_time.c
+++ b/crypto/asn1/posix_time.c
@@ -21,6 +21,7 @@
 #include <string.h>
 #include <time.h>
 
+#include "../internal.h"
 #include "internal.h"
 
 #define SECS_PER_HOUR (60 * 60)
@@ -146,7 +147,11 @@ int OPENSSL_tm_to_posix(const struct tm *tm, int64_t *out) {
 }
 
 int OPENSSL_posix_to_tm(int64_t time, struct tm *out_tm) {
-  memset(out_tm, 0, sizeof(struct tm));
+  if (out_tm == NULL) {
+    OPENSSL_PUT_ERROR(ASN1, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+  OPENSSL_memset(out_tm, 0, sizeof(struct tm));
   if (!utc_from_posix_time(time, &out_tm->tm_year, &out_tm->tm_mon,
                            &out_tm->tm_mday, &out_tm->tm_hour, &out_tm->tm_min,
                            &out_tm->tm_sec)) {
diff --git a/include/openssl/asn1.h b/include/openssl/asn1.h
index de2f13e53..c9e06f8c7 100644
--- a/include/openssl/asn1.h
+++ b/include/openssl/asn1.h
@@ -1400,6 +1400,22 @@ OPENSSL_EXPORT ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(
 // GeneralizedTime. If |str| is neither, it returns zero.
 OPENSSL_EXPORT int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);
 
+
+// ASN1_TIME conversion functions.
+//
+// |struct| |tm| represents a calendar date: year, month, day... it is not
+// necessarily a valid day, e.g. month 13. |time_t| is a typedef for the system's
+// type that represents the seconds since the UNIX epoch. Posix time is
+// a signed 64-bit integer which also represents the seconds since the UNIX
+// epoch.
+
+// ASN1_TIME_to_tm converts the ASN1 time |t| to the calendar day representation
+// and writes it to |out|. If |t| is NULL, then the current time is converted.
+// The output time is GMT. The tm_sec, tm_min, tm_hour, tm_mday, tm_mon and
+// tm_year fields of |out| are set to proper values, all other fields are set
+// to 0. If tm is NULL this function performs a format check on |t| only.
+OPENSSL_EXPORT int ASN1_TIME_to_tm(const ASN1_TIME *t, struct tm *out);
+
 // ASN1_TIME_to_time_t converts |t| to a time_t value in |out|. On
 // success, one is returned. On failure zero is returned. This function
 // will fail if the time can not be represented in a time_t.
