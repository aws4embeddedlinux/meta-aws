From 38e636cc05b4212983e26d6bd8ede9791b4d2eea Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Thu, 28 Oct 2021 08:23:15 -0700
Subject: [PATCH] Add little-endian conversions for P-256 and P-384

On all little-endian platforms, in particular all x86 machines, these
just amount to size-specific copying functions. The existing big-endian
"bignum_tobytes_n" and "bignum_frombytes_n" are renamed to make the
endian-ness explicit, "bignum_tobebytes_n" and "bignum_frombebytes_n"
("be" = big-endian) and the new versions are "bignum_tolebytes_n" and
"bignum_fromlebytes_n" ("le" = little-endian).

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/96ced4b2b1807758468f508612260a5e6ca7958b
---
 arm/p384/Makefile                    |   1 +
 arm/p384/bignum_bigendian_6.S        |  14 +--
 arm/p384/bignum_littleendian_6.S     | 180 +++++++++++++++++++++++++++
 x86_att/p384/bignum_bigendian_6.S    |  12 +-
 x86_att/p384/bignum_littleendian_6.S |  73 +++++++++++
 5 files changed, 267 insertions(+), 13 deletions(-)
 create mode 100644 arm/p384/bignum_littleendian_6.S
 create mode 100644 x86_att/p384/bignum_littleendian_6.S

diff --git a/arm/p384/Makefile b/arm/p384/Makefile
index 2dae67242..f6e947c89 100644
--- a/arm/p384/Makefile
+++ b/arm/p384/Makefile
@@ -38,6 +38,7 @@ OBJ = bignum_add_p384.o \
       bignum_demont_p384.o \
       bignum_double_p384.o \
       bignum_half_p384.o \
+      bignum_littleendian_6.o \
       bignum_mod_n384.o \
       bignum_mod_n384_6.o \
       bignum_mod_p384.o \
diff --git a/arm/p384/bignum_bigendian_6.S b/arm/p384/bignum_bigendian_6.S
index 065b4a4e7..a55bd08f9 100644
--- a/arm/p384/bignum_bigendian_6.S
+++ b/arm/p384/bignum_bigendian_6.S
@@ -23,22 +23,22 @@
 // The same function is given two other prototypes whose names reflect the
 // treatment of one or other argument as a byte array rather than word array:
 //
-//    extern void bignum_frombytes_6
+//    extern void bignum_frombebytes_6
 //     (uint64_t z[static 6], uint8_t x[static 48]);
 //
-//    extern void bignum_tobytes_6
+//    extern void bignum_tobebytes_6
 //     (uint8_t z[static 48], uint64_t x[static 6]);
 //
 // The implementation works by loading in bytes and storing in words (i.e.
-// stylistically it is "frombytes"); in the more common little-endian
+// stylistically it is "frombebytes"); in the more common little-endian
 // usage of ARM, this is just byte reversal.
 //
 // Standard ARM ABI: X0 = z, X1 = x
 // ----------------------------------------------------------------------------
 
         .globl  bignum_bigendian_6
-        .globl  bignum_frombytes_6
-        .globl  bignum_tobytes_6
+        .globl  bignum_frombebytes_6
+        .globl  bignum_tobebytes_6
         .text
         .balign 4
 
@@ -55,8 +55,8 @@
 // intermediate registers.
 
 bignum_bigendian_6:
-bignum_frombytes_6:
-bignum_tobytes_6:
+bignum_frombebytes_6:
+bignum_tobebytes_6:
 
 // 0 and 5 words
 
diff --git a/arm/p384/bignum_littleendian_6.S b/arm/p384/bignum_littleendian_6.S
new file mode 100644
index 000000000..67df9feb3
--- /dev/null
+++ b/arm/p384/bignum_littleendian_6.S
@@ -0,0 +1,180 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert 6-digit (384-bit) bignum to/from little-endian form
+// Input x[6]; output z[6]
+//
+//    extern void bignum_littleendian_6
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// The same function is given two other prototypes whose names reflect the
+// treatment of one or other argument as a byte array rather than word array:
+//
+//    extern void bignum_fromlebytes_6
+//     (uint64_t z[static 6], uint8_t x[static 48]);
+//
+//    extern void bignum_tolebytes_6
+//     (uint8_t z[static 48], uint64_t x[static 6]);
+//
+// The implementation works by loading in bytes and storing in words (i.e.
+// stylistically it is "fromlebytes"); in the more common little-endian
+// usage of ARM, this is just copying.
+//
+// Standard ARM ABI: X0 = z, X1 = x
+// ----------------------------------------------------------------------------
+
+        .globl  bignum_littleendian_6
+        .globl  bignum_fromlebytes_6
+        .globl  bignum_tolebytes_6
+        .text
+        .balign 4
+
+#define z x0
+#define x x1
+
+#define d x2
+#define dshort w2
+#define a x3
+
+bignum_littleendian_6:
+bignum_fromlebytes_6:
+bignum_tolebytes_6:
+
+// word 0
+
+                ldrb    dshort, [x]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #1]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #2]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #3]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #4]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #5]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #6]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #7]
+                extr    a, d, a, #8
+                str     a, [z]
+
+// word 1
+
+                ldrb    dshort, [x, #8]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #9]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #10]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #11]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #12]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #13]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #14]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #15]
+                extr    a, d, a, #8
+                str     a, [z, #8]
+
+// word 2
+
+                ldrb    dshort, [x, #16]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #17]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #18]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #19]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #20]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #21]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #22]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #23]
+                extr    a, d, a, #8
+                str     a, [z, #16]
+
+// word 3
+
+                ldrb    dshort, [x, #24]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #25]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #26]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #27]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #28]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #29]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #30]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #31]
+                extr    a, d, a, #8
+                str     a, [z, #24]
+
+// word 4
+
+                ldrb    dshort, [x, #32]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #33]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #34]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #35]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #36]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #37]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #38]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #39]
+                extr    a, d, a, #8
+                str     a, [z, #32]
+
+// word 5
+
+                ldrb    dshort, [x, #40]
+                extr    a, d, xzr, #8
+                ldrb    dshort, [x, #41]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #42]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #43]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #44]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #45]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #46]
+                extr    a, d, a, #8
+                ldrb    dshort, [x, #47]
+                extr    a, d, a, #8
+                str     a, [z, #40]
+
+                ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_bigendian_6.S b/x86_att/p384/bignum_bigendian_6.S
index 3f31b4072..67a958a2e 100644
--- a/x86_att/p384/bignum_bigendian_6.S
+++ b/x86_att/p384/bignum_bigendian_6.S
@@ -23,10 +23,10 @@
 // The same function is given two other prototypes whose names reflect the
 // treatment of one or other argument as a byte array rather than word array:
 //
-//    extern void bignum_frombytes_6
+//    extern void bignum_frombebytes_6
 //     (uint64_t z[static 6], uint8_t x[static 48]);
 //
-//    extern void bignum_tobytes_6
+//    extern void bignum_tobebytes_6
 //     (uint8_t z[static 48], uint64_t x[static 6]);
 //
 // Since x86 is little-endian, and bignums are stored with little-endian
@@ -37,8 +37,8 @@
 
 
         .globl  bignum_bigendian_6
-        .globl  bignum_frombytes_6
-        .globl  bignum_tobytes_6
+        .globl  bignum_frombebytes_6
+        .globl  bignum_tobebytes_6
         .text
 
 #define z %rdi
@@ -53,8 +53,8 @@
 // without using more intermediate registers.
 
 bignum_bigendian_6:
-bignum_frombytes_6:
-bignum_tobytes_6:
+bignum_frombebytes_6:
+bignum_tobebytes_6:
 
 // 0 and 5 words
 
diff --git a/x86_att/p384/bignum_littleendian_6.S b/x86_att/p384/bignum_littleendian_6.S
new file mode 100644
index 000000000..58c5a8cc2
--- /dev/null
+++ b/x86_att/p384/bignum_littleendian_6.S
@@ -0,0 +1,73 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert 6-digit (384-bit) bignum to/from little-endian form
+// Input x[6]; output z[6]
+//
+//    extern void bignum_littleendian_6
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// The same function is given two other prototypes whose names reflect the
+// treatment of one or other argument as a byte array rather than word array:
+//
+//    extern void bignum_fromlebytes_6
+//     (uint64_t z[static 6], uint8_t x[static 48]);
+//
+//    extern void bignum_tolebytes_6
+//     (uint8_t z[static 48], uint64_t x[static 6]);
+//
+// Since x86 is little-endian, this is just copying.
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_littleendian_6
+        .globl  bignum_fromlebytes_6
+        .globl  bignum_tolebytes_6
+        .text
+
+#define z %rdi
+#define x %rsi
+#define a %rax
+
+bignum_littleendian_6:
+bignum_fromlebytes_6:
+bignum_tolebytes_6:
+
+                movq    (x), a
+                movq    a, (z)
+
+                movq    8(x), a
+                movq    a, 8(z)
+
+                movq    16(x), a
+                movq    a, 16(z)
+
+                movq    24(x), a
+                movq    a, 24(z)
+
+                movq    32(x), a
+                movq    a, 32(z)
+
+                movq    40(x), a
+                movq    a, 40(z)
+
+                ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
