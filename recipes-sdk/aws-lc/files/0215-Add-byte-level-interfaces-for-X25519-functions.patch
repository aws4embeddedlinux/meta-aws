From 97767f70f7770350d76d9ba2a2dba54348d6c7cf Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Tue, 21 Mar 2023 16:56:34 -0700
Subject: [PATCH] Add byte-level interfaces for X25519 functions

These provide alternative interfaces at the C level, with "_byte" in
their names to distinguish them, treating the arguments as arrays
of bytes (uint8_t) rather than of 64-bit words (uint64_t). This
better reflects how the X25519 function is generally specified and
used.

  void curve25519_x25519_byte(uint8_t res[static 32],uint8_t scalar[static 32],uint8_t point[static 32]);
  void curve25519_x25519_byte_alt(uint8_t res[static 32],uint8_t scalar[static 32],uint8_t point[static 32]);
  void curve25519_x25519base_byte(uint8_t res[static 32],uint8_t scalar[static 32]);
  void curve25519_x25519base_byte_alt(uint8_t res[static 32],uint8_t scalar[static 32]);

The underlying code is exactly the same in the x86 case, since
the platform is guaranteed to be little-endian, and the proofs
just rephrase the same results in terms of byte arrays.

The ARM functions are actually different code, using byte-level
loads and stores (ldrb, strb) at the beginning and end, and so
their proofs are also slightly different.

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/6cdfdde71663913f2b505d287cad66cf7346c0f2
---
 x86_att/curve25519/curve25519_x25519.S         | 10 ++++++++++
 x86_att/curve25519/curve25519_x25519_alt.S     | 10 ++++++++++
 x86_att/curve25519/curve25519_x25519base.S     | 12 +++++++++++-
 x86_att/curve25519/curve25519_x25519base_alt.S | 10 ++++++++++
 4 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/x86_att/curve25519/curve25519_x25519.S b/x86_att/curve25519/curve25519_x25519.S
index d103ec911..14293cbc2 100644
--- a/x86_att/curve25519/curve25519_x25519.S
+++ b/x86_att/curve25519/curve25519_x25519.S
@@ -8,6 +8,13 @@
 // extern void curve25519_x25519
 //   (uint64_t res[static 4],uint64_t scalar[static 4],uint64_t point[static 4])
 //
+// The function has a second prototype considering the arguments as arrays
+// of bytes rather than 64-bit words. The underlying code is the same, since
+// the x86 platform is little-endian.
+//
+// extern void curve25519_x25519_byte
+//   (uint8_t res[static 32],uint8_t scalar[static 32],uint8_t point[static 32])
+//
 // Given a scalar n and the X coordinate of an input point P = (X,Y) on
 // curve25519 (Y can live in any extension field of characteristic 2^255-19),
 // this returns the X coordinate of n * P = (X, Y), or 0 when n * P is the
@@ -23,6 +30,8 @@
 
         S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519)
         S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519)
+        S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519_byte)
+        S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519_byte)
         .text
 
 // Size of individual field elements
@@ -584,6 +593,7 @@
         movq    %rax, 24+P0
 
 S2N_BN_SYMBOL(curve25519_x25519):
+S2N_BN_SYMBOL(curve25519_x25519_byte):
 
 #if WINDOWS_ABI
         pushq   %rdi
diff --git a/x86_att/curve25519/curve25519_x25519_alt.S b/x86_att/curve25519/curve25519_x25519_alt.S
index 1d4ab64bc..981f6e741 100644
--- a/x86_att/curve25519/curve25519_x25519_alt.S
+++ b/x86_att/curve25519/curve25519_x25519_alt.S
@@ -8,6 +8,13 @@
 // extern void curve25519_x25519_alt
 //   (uint64_t res[static 4],uint64_t scalar[static 4],uint64_t point[static 4])
 //
+// The function has a second prototype considering the arguments as arrays
+// of bytes rather than 64-bit words. The underlying code is the same, since
+// the x86 platform is little-endian.
+//
+// extern void curve25519_x25519_byte_alt
+//   (uint8_t res[static 32],uint8_t scalar[static 32],uint8_t point[static 32])
+//
 // Given a scalar n and the X coordinate of an input point P = (X,Y) on
 // curve25519 (Y can live in any extension field of characteristic 2^255-19),
 // this returns the X coordinate of n * P = (X, Y), or 0 when n * P is the
@@ -23,6 +30,8 @@
 
         S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519_alt)
         S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519_alt)
+        S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519_byte_alt)
+        S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519_byte_alt)
         .text
 
 // Size of individual field elements
@@ -745,6 +754,7 @@
         movq    %rax, 24+P0
 
 S2N_BN_SYMBOL(curve25519_x25519_alt):
+S2N_BN_SYMBOL(curve25519_x25519_byte_alt):
 
 #if WINDOWS_ABI
         pushq   %rdi
diff --git a/x86_att/curve25519/curve25519_x25519base.S b/x86_att/curve25519/curve25519_x25519base.S
index 1f9ee2377..f7ffa2b83 100644
--- a/x86_att/curve25519/curve25519_x25519base.S
+++ b/x86_att/curve25519/curve25519_x25519base.S
@@ -6,7 +6,14 @@
 // Input scalar[4]; output res[4]
 //
 // extern void curve25519_x25519base
-//   (uint64_t res[static 4],uint64_t scalar[static 4]);
+//   (uint64_t res[static 4],uint64_t scalar[static 4])
+//
+// The function has a second prototype considering the arguments as arrays
+// of bytes rather than 64-bit words. The underlying code is the same, since
+// the x86 platform is little-endian.
+//
+// extern void curve25519_x25519base_byte
+//   (uint8_t res[static 32],uint8_t scalar[static 32])
 //
 // Given a scalar n, returns the X coordinate of n * G where G = (9,...) is
 // the standard generator. The scalar is first slightly modified/mangled
@@ -20,6 +27,8 @@
 
         S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519base)
         S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519base)
+        S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519base_byte)
+        S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519base_byte)
         .text
 
 // Size of individual field elements
@@ -328,6 +337,7 @@
         movq    %r11, 0x18+P0
 
 S2N_BN_SYMBOL(curve25519_x25519base):
+S2N_BN_SYMBOL(curve25519_x25519base_byte):
 
 // In this case the Windows form literally makes a subroutine call.
 // This avoids hassle arising from keeping code and data together.
diff --git a/x86_att/curve25519/curve25519_x25519base_alt.S b/x86_att/curve25519/curve25519_x25519base_alt.S
index 0027f47f9..c90bd1bc9 100644
--- a/x86_att/curve25519/curve25519_x25519base_alt.S
+++ b/x86_att/curve25519/curve25519_x25519base_alt.S
@@ -8,6 +8,13 @@
 // extern void curve25519_x25519base_alt
 //   (uint64_t res[static 4],uint64_t scalar[static 4]);
 //
+// The function has a second prototype considering the arguments as arrays
+// of bytes rather than 64-bit words. The underlying code is the same, since
+// the x86 platform is little-endian.
+//
+// extern void curve25519_x25519base_byte_alt
+//   (uint8_t res[static 32],uint8_t scalar[static 32])
+//
 // Given a scalar n, returns the X coordinate of n * G where G = (9,...) is
 // the standard generator. The scalar is first slightly modified/mangled
 // as specified in the relevant RFC (https://www.rfc-editor.org/rfc/rfc7748).
@@ -20,6 +27,8 @@
 
         S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519base_alt)
         S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519base_alt)
+        S2N_BN_SYM_VISIBILITY_DIRECTIVE(curve25519_x25519base_byte_alt)
+        S2N_BN_SYM_PRIVACY_DIRECTIVE(curve25519_x25519base_byte_alt)
         .text
 
 // Size of individual field elements
@@ -404,6 +413,7 @@
         movq    %r11, 0x18+P0
 
 S2N_BN_SYMBOL(curve25519_x25519base_alt):
+S2N_BN_SYMBOL(curve25519_x25519base_byte_alt):
 
 // In this case the Windows form literally makes a subroutine call.
 // This avoids hassle arising from keeping code and data together.
