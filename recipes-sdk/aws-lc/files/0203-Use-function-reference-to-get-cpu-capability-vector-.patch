From b00c3bd45e18a444aba486b9f29e0827d44f0e81 Mon Sep 17 00:00:00 2001
From: torben-hansen <50673096+torben-hansen@users.noreply.github.com>
Date: Thu, 16 Mar 2023 10:19:05 -0700
Subject: [PATCH] Use function reference to get cpu capability vector at the
 C-level (#856)

This is the first PR out of two PRs that bridge the performance gap.

This PR use a function reference instead of directly dereferences the global variable at the C-level. Some instances of dereferencing the variable directly were added in https://github.com/aws/aws-lc/pull/330/files, removing the function reference. Others seem to just have been dereferencing the global variable always. Make this consistent and only use the functional reference at the C-level. This avoids the push/pop of the carry-flags. And performance benchmark shows that this recovers some of the performance gap.
---
 crypto/fipsmodule/cpucap/internal.h | 41 ++++++++++++++++++-----------
 crypto/fipsmodule/ec/p384.c         |  4 +--
 crypto/fipsmodule/ec/p521.c         |  4 +--
 3 files changed, 30 insertions(+), 19 deletions(-)

diff --git a/crypto/fipsmodule/cpucap/internal.h b/crypto/fipsmodule/cpucap/internal.h
index 53cce625d..e3068f5cc 100644
--- a/crypto/fipsmodule/cpucap/internal.h
+++ b/crypto/fipsmodule/cpucap/internal.h
@@ -37,71 +37,82 @@ void OPENSSL_cpuid_setup(void);
 // bits in XCR0, so it is not necessary to check those.
 extern uint32_t OPENSSL_ia32cap_P[4];
 
+#if defined(BORINGSSL_FIPS) && !defined(BORINGSSL_SHARED_LIBRARY)
+// The FIPS module, as a static library, requires an out-of-line version of
+// |OPENSSL_ia32cap_get| so accesses can be rewritten by delocate. Mark the
+// function const so multiple accesses can be optimized together.
+const uint32_t *OPENSSL_ia32cap_get(void) __attribute__((const));
+#else
+OPENSSL_INLINE const uint32_t *OPENSSL_ia32cap_get(void) {
+  return OPENSSL_ia32cap_P;
+}
+#endif
+
 // See Intel manual, volume 2A, table 3-11.
 
 OPENSSL_INLINE int CRYPTO_is_FXSR_capable(void) {
-  return (OPENSSL_ia32cap_P[0] & (1 << 24)) != 0;
+  return (OPENSSL_ia32cap_get()[0] & (1 << 24)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_intel_cpu(void) {
   // The reserved bit 30 is used to indicate an Intel CPU.
-  return (OPENSSL_ia32cap_P[0] & (1 << 30)) != 0;
+  return (OPENSSL_ia32cap_get()[0] & (1 << 30)) != 0;
 }
 
 // See Intel manual, volume 2A, table 3-10.
 
 OPENSSL_INLINE int CRYPTO_is_PCLMUL_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 1)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 1)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_SSSE3_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 9)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 9)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_SSE4_1_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 19)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 19)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_MOVBE_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 22)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 22)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_AESNI_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 25)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 25)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_AVX_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 28)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 28)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_RDRAND_capable(void) {
-  return (OPENSSL_ia32cap_P[1] & (1u << 30)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1u << 30)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_AMD_XOP_support(void) {
-  return (OPENSSL_ia32cap_P[1] & (1 << 11)) != 0;
+  return (OPENSSL_ia32cap_get()[1] & (1 << 11)) != 0;
 }
 
 // See Intel manual, volume 2A, table 3-8.
 
 OPENSSL_INLINE int CRYPTO_is_BMI1_capable(void) {
-  return (OPENSSL_ia32cap_P[2] & (1 << 3)) != 0;
+  return (OPENSSL_ia32cap_get()[2] & (1 << 3)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_AVX2_capable(void) {
-  return (OPENSSL_ia32cap_P[2] & (1 << 5)) != 0;
+  return (OPENSSL_ia32cap_get()[2] & (1 << 5)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_BMI2_capable(void) {
-  return (OPENSSL_ia32cap_P[2] & (1 << 8)) != 0;
+  return (OPENSSL_ia32cap_get()[2] & (1 << 8)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_ADX_capable(void) {
-  return (OPENSSL_ia32cap_P[2] & (1 << 19)) != 0;
+  return (OPENSSL_ia32cap_get()[2] & (1 << 19)) != 0;
 }
 
 OPENSSL_INLINE int CRYPTO_is_SHAEXT_capable(void) {
-  return (OPENSSL_ia32cap_P[2] & (1 << 29)) != 0;
+  return (OPENSSL_ia32cap_get()[2] & (1 << 29)) != 0;
 }
 
 #endif  // OPENSSL_X86 || OPENSSL_X86_64
diff --git a/crypto/fipsmodule/ec/p384.c b/crypto/fipsmodule/ec/p384.c
index 72b93a063..8e9ca8a18 100644
--- a/crypto/fipsmodule/ec/p384.c
+++ b/crypto/fipsmodule/ec/p384.c
@@ -77,8 +77,8 @@ static const p384_felem p384_felem_one = {
 // every x86 CPU so we have to check if they are available and in case
 // they are not we fallback to slightly slower but generic implementation.
 static inline uint8_t p384_use_s2n_bignum_alt(void) {
-  return ((OPENSSL_ia32cap_P[2] & (1u <<  8)) == 0) || // bmi2
-         ((OPENSSL_ia32cap_P[2] & (1u << 19)) == 0);   // adx
+  return ((OPENSSL_ia32cap_get()[2] & (1u <<  8)) == 0) || // bmi2
+         ((OPENSSL_ia32cap_get()[2] & (1u << 19)) == 0);   // adx
 }
 #else
 // On aarch64 platforms s2n-bignum has two implementations of certain
diff --git a/crypto/fipsmodule/ec/p521.c b/crypto/fipsmodule/ec/p521.c
index d4c3ff165..200247814 100644
--- a/crypto/fipsmodule/ec/p521.c
+++ b/crypto/fipsmodule/ec/p521.c
@@ -80,8 +80,8 @@ static const p521_limb_t p521_felem_p[P521_NLIMBS] = {
 // every x86 CPU so we have to check if they are available and in case
 // they are not we fallback to slightly slower but generic implementation.
 static inline uint8_t p521_use_s2n_bignum_alt(void) {
-  return ((OPENSSL_ia32cap_P[2] & (1u <<  8)) == 0) || // bmi2
-         ((OPENSSL_ia32cap_P[2] & (1u << 19)) == 0);   // adx
+  return ((OPENSSL_ia32cap_get()[2] & (1u <<  8)) == 0) || // bmi2
+         ((OPENSSL_ia32cap_get()[2] & (1u << 19)) == 0);   // adx
 }
 #else
 // On aarch64 platforms s2n-bignum has two implementations of certain
