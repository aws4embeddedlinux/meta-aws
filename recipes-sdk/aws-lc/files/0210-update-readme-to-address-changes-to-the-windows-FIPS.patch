From 71949d5eab4dcfa203237ef7b0c89653ca531259 Mon Sep 17 00:00:00 2001
From: William Bo Yang <coolbillyang@gmail.com>
Date: Mon, 20 Mar 2023 10:55:18 -0700
Subject: [PATCH] update readme to address changes to the windows FIPS logic
 (#887)

---
 crypto/fipsmodule/FIPS.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/crypto/fipsmodule/FIPS.md b/crypto/fipsmodule/FIPS.md
index 0441da35a..072b151c6 100644
--- a/crypto/fipsmodule/FIPS.md
+++ b/crypto/fipsmodule/FIPS.md
@@ -81,7 +81,7 @@ The Shared Windows FIPS integrity test differs in two key ways:
 1. How the start and end of the module are marked
 2. How the correct integrity hash is calculated
 
-Microsoft Visual C compiler (MSVC) does not support linker scripts which add symbols to mark the start and end of the text and rodata sections on Linux. Instead, fips_shared_library_marker.c is compiled twice to generate two object files that contain start/end functions and variables. MSVC `pragma` segment definitions are used to place the markers in specific sections (e.g. `.fipstx$a`). This particular name format uses Portable Executable Grouped Sections to control what section the code is placed in and the order within the section. With the start and end markers placed at `$a` and `$z` respectively, BCM puts everything in the `$b` section. When the final crypto.dll is built all the code is in the `.fipstx` section, all data and constants is in `.fipsda`, and everything is in the correct order.
+Microsoft Visual C compiler (MSVC) does not support linker scripts which add symbols to mark the start and end of the text and rodata sections on Linux. Instead, fips_shared_library_marker.c is compiled twice to generate two object files that contain start/end functions and variables. MSVC `pragma` segment definitions are used to place the markers in specific sections (e.g. `.fipstx$a`). This particular name format uses Portable Executable Grouped Sections to control what section the code is placed in and the order within the section. With the start and end markers placed at `$a` and `$z` respectively, BCM puts everything in the `$b` section. When the final crypto.dll is built all the code is in the `.fipstx` section, all data is in `.fipsda`, all constants are in `.fipsco`, all unitialized items in `.fipsbs`, and everything is in the correct order.
 
 The process to generate the expected integrity fingerprint is also different from Linux:
 1. Build the required object files once: `bcm.obj` from `bcm.c` and the start/end object files
