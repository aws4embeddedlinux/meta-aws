From 9e5f4aa686eaf5f4aba23ecde47ef4901fa718ac Mon Sep 17 00:00:00 2001
From: Samuel Chiang <sachiang@amazon.com>
Date: Wed, 19 Apr 2023 16:02:26 -0700
Subject: [PATCH] Don't use a pre-calculated digest for signing and
 verification in the self tests (#964)

FIPS vendor feedback required us to do calculate digest along with the actual
signing and verification for RSA and ECDSA.
`EVP_DigestSign/Verify` functions aren't usable for this, since they would
result in an infinity loop. We've gotten feedback from our FIPS vendor, that we
can just calculate the digest and signature in the same function and continue
using the `*_no_self_tests` function. They just don't want us using a
pre-calculated digest in the self tests.
---
 crypto/fipsmodule/ecdsa/ecdsa.c           |  26 +++++
 crypto/fipsmodule/ecdsa/internal.h        |  17 +++
 crypto/fipsmodule/rsa/internal.h          |  20 +++-
 crypto/fipsmodule/rsa/rsa.c               |  26 +++++
 crypto/fipsmodule/self_check/self_check.c | 129 +++++++++++-----------
 5 files changed, 150 insertions(+), 68 deletions(-)

diff --git a/crypto/fipsmodule/ecdsa/ecdsa.c b/crypto/fipsmodule/ecdsa/ecdsa.c
index b475678e6..c26ce93cc 100644
--- a/crypto/fipsmodule/ecdsa/ecdsa.c
+++ b/crypto/fipsmodule/ecdsa/ecdsa.c
@@ -420,3 +420,29 @@ err:
   ECDSA_SIG_free(s);
   return ret;
 }
+
+ECDSA_SIG *ecdsa_digestsign_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                         size_t in_len, const EC_KEY *eckey,
+                                         const uint8_t *nonce,
+                                         size_t nonce_len) {
+  uint8_t digest[EVP_MAX_MD_SIZE];
+  unsigned int digest_len;
+  if (!EVP_Digest(input, in_len, digest, &digest_len, md, NULL)) {
+    return 0;
+  }
+
+  return ecdsa_sign_with_nonce_for_known_answer_test(digest, digest_len, eckey,
+                                                     nonce, nonce_len);
+}
+
+int ecdsa_digestverify_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                    size_t in_len, const ECDSA_SIG *sig,
+                                    const EC_KEY *eckey){
+  uint8_t digest[EVP_MAX_MD_SIZE];
+  unsigned int digest_len;
+  if (!EVP_Digest(input, in_len, digest, &digest_len, md, NULL)) {
+    return 0;
+  }
+
+  return ecdsa_do_verify_no_self_test(digest, digest_len, sig, eckey);
+}
diff --git a/crypto/fipsmodule/ecdsa/internal.h b/crypto/fipsmodule/ecdsa/internal.h
index 645959fb7..3e5ff03c0 100644
--- a/crypto/fipsmodule/ecdsa/internal.h
+++ b/crypto/fipsmodule/ecdsa/internal.h
@@ -37,6 +37,23 @@ ECDSA_SIG *ecdsa_sign_with_nonce_for_known_answer_test(const uint8_t *digest,
 int ecdsa_do_verify_no_self_test(const uint8_t *digest, size_t digest_len,
                                  const ECDSA_SIG *sig, const EC_KEY *eckey);
 
+// ecdsa_digestsign_no_self_test calculates the digest and calls
+// |ecdsa_sign_with_nonce_for_known_answer_test|, which doesn't try to run the
+// self-test first. This is for use in the self tests themselves, to prevent
+// an infinite loop.
+ECDSA_SIG *ecdsa_digestsign_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                         size_t in_len, const EC_KEY *eckey,
+                                         const uint8_t *nonce,
+                                         size_t nonce_len);
+
+// ecdsa_digestverify_no_self_test calculates the digest and calls
+// |ecdsa_do_verify_no_self_test|, which doesn't try to run the self-test
+// first. This is for use in the self tests themselves, to prevent an infinite
+// loop.
+int ecdsa_digestverify_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                    size_t in_len, const ECDSA_SIG *sig,
+                                    const EC_KEY *eckey);
+
 
 #if defined(__cplusplus)
 }
diff --git a/crypto/fipsmodule/rsa/internal.h b/crypto/fipsmodule/rsa/internal.h
index 2b9a16ac9..9d16d15c7 100644
--- a/crypto/fipsmodule/rsa/internal.h
+++ b/crypto/fipsmodule/rsa/internal.h
@@ -67,9 +67,9 @@ extern "C" {
 #endif
 
 typedef enum {
-    RSA_STRIPPED_KEY,
-    RSA_CRT_KEY,
-    RSA_PUBLIC_KEY
+  RSA_STRIPPED_KEY,
+  RSA_CRT_KEY,
+  RSA_PUBLIC_KEY
 } rsa_asn1_key_encoding_t;
 
 // Default implementations of RSA operations.
@@ -151,6 +151,20 @@ int rsa_sign_no_self_test(int hash_nid, const uint8_t *digest,
                           size_t digest_len, uint8_t *out, unsigned *out_len,
                           RSA *rsa);
 
+// rsa_digestsign_no_self_test calculates the digest and calls
+// |rsa_sign_no_self_test|, which doesn't try to run the self-test first. This
+// is for use in the self tests themselves, to prevent an infinite loop.
+int rsa_digestsign_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                size_t in_len, uint8_t *out, unsigned *out_len,
+                                RSA *rsa);
+
+// rsa_digestverify_no_self_test calculates the digest and calls
+// |rsa_verify_no_self_test|, which doesn't try to run the self-test first. This
+// is for use in the self tests themselves, to prevent an infinite loop.
+int rsa_digestverify_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                  size_t in_len, const uint8_t *sig,
+                                  size_t sig_len, RSA *rsa);
+
 
 #if defined(__cplusplus)
 }  // extern C
diff --git a/crypto/fipsmodule/rsa/rsa.c b/crypto/fipsmodule/rsa/rsa.c
index 28bcf4d0c..5eff5cfaf 100644
--- a/crypto/fipsmodule/rsa/rsa.c
+++ b/crypto/fipsmodule/rsa/rsa.c
@@ -621,6 +621,19 @@ int RSA_sign_pss_mgf1(RSA *rsa, size_t *out_len, uint8_t *out, size_t max_out,
   return ret;
 }
 
+int rsa_digestsign_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                size_t in_len, uint8_t *out, unsigned *out_len,
+                                RSA *rsa) {
+  uint8_t digest[EVP_MAX_MD_SIZE];
+  unsigned int digest_len;
+  if (!EVP_Digest(input, in_len, digest, &digest_len, md, NULL)) {
+    return 0;
+  }
+
+  return rsa_sign_no_self_test(EVP_MD_type(md), digest, digest_len, out,
+                               out_len, rsa);
+}
+
 int rsa_verify_no_self_test(int hash_nid, const uint8_t *digest,
                             size_t digest_len, const uint8_t *sig,
                             size_t sig_len, RSA *rsa) {
@@ -676,6 +689,19 @@ out:
   return ret;
 }
 
+int rsa_digestverify_no_self_test(const EVP_MD *md, const uint8_t *input,
+                                  size_t in_len, const uint8_t *sig,
+                                  size_t sig_len, RSA *rsa) {
+  uint8_t digest[EVP_MAX_MD_SIZE];
+  unsigned int digest_len;
+  if (!EVP_Digest(input, in_len, digest, &digest_len, md, NULL)) {
+    return 0;
+  }
+
+  return rsa_verify_no_self_test(EVP_MD_type(md), digest, digest_len, sig,
+                                 sig_len, rsa);
+}
+
 int RSA_verify(int hash_nid, const uint8_t *digest, size_t digest_len,
                const uint8_t *sig, size_t sig_len, RSA *rsa) {
   boringssl_ensure_rsa_self_test();
diff --git a/crypto/fipsmodule/self_check/self_check.c b/crypto/fipsmodule/self_check/self_check.c
index a375dbf09..067e42983 100644
--- a/crypto/fipsmodule/self_check/self_check.c
+++ b/crypto/fipsmodule/self_check/self_check.c
@@ -424,39 +424,39 @@ static int boringssl_self_test_rsa(void) {
 
   // RSA Sign KAT
 
-  static const uint8_t kRSASignDigest[32] = {
+  static const uint8_t kRSASignPlaintext[32] = {
       0xd2, 0xb5, 0x6e, 0x53, 0x30, 0x6f, 0x72, 0x0d, 0x79, 0x29, 0xd8,
       0x70, 0x8b, 0xf4, 0x6f, 0x1c, 0x22, 0x30, 0x03, 0x05, 0x58, 0x2b,
       0x11, 0x5b, 0xed, 0xca, 0xc7, 0x22, 0xd8, 0xaa, 0x5a, 0xb2,
   };
   static const uint8_t kRSASignSignature[256] = {
-      0x64, 0xce, 0xdd, 0x91, 0x27, 0xb0, 0x4f, 0xb9, 0x14, 0xea, 0xc0, 0xb4,
-      0xa2, 0x06, 0xc5, 0xd8, 0x40, 0x0f, 0x6c, 0x54, 0xac, 0xf7, 0x02, 0xde,
-      0x26, 0xbb, 0xfd, 0x33, 0xe5, 0x2f, 0x4d, 0xb1, 0x53, 0xc4, 0xff, 0xd0,
-      0x5f, 0xea, 0x15, 0x89, 0x83, 0x4c, 0xe3, 0x80, 0x0b, 0xe9, 0x13, 0x82,
-      0x1d, 0x71, 0x92, 0x1a, 0x03, 0x60, 0x2c, 0xaf, 0xe2, 0x16, 0xc7, 0x43,
-      0x3f, 0xde, 0x6b, 0x94, 0xfd, 0x6e, 0x08, 0x7b, 0x11, 0xf1, 0x34, 0x52,
-      0xe5, 0xc0, 0x97, 0x66, 0x4a, 0xe0, 0x91, 0x45, 0xc8, 0xb1, 0x3d, 0x6a,
-      0x54, 0xc1, 0x32, 0x0f, 0x32, 0xad, 0x25, 0x11, 0x3e, 0x49, 0xad, 0x41,
-      0xce, 0x7b, 0xca, 0x95, 0x6b, 0x54, 0x5e, 0x86, 0x1b, 0xce, 0xfa, 0x2a,
-      0x60, 0xe8, 0xfa, 0xbb, 0x23, 0xb2, 0x41, 0xbc, 0x7c, 0x98, 0xec, 0x73,
-      0x20, 0xed, 0xb3, 0xcf, 0xab, 0x07, 0x24, 0x85, 0x6a, 0x2a, 0x61, 0x76,
-      0x28, 0xf8, 0x00, 0x80, 0xeb, 0xd9, 0x3a, 0x63, 0xe2, 0x01, 0xb1, 0xee,
-      0x6d, 0xe9, 0x73, 0xe9, 0xb6, 0x75, 0x2e, 0xf9, 0x81, 0xd9, 0xa8, 0x79,
-      0xf6, 0x8f, 0xe3, 0x02, 0x7d, 0xf6, 0xea, 0xdc, 0x35, 0xe4, 0x62, 0x0d,
-      0x91, 0xba, 0x3e, 0x7d, 0x8b, 0x82, 0xbf, 0x15, 0x74, 0x6a, 0x4e, 0x29,
-      0xf8, 0x9b, 0x2c, 0x94, 0x8d, 0xa7, 0x00, 0x4d, 0x7b, 0xbf, 0x35, 0x07,
-      0xeb, 0xdd, 0x10, 0xef, 0xd5, 0x2f, 0xe6, 0x98, 0x4b, 0x7e, 0x24, 0x80,
-      0xe2, 0x01, 0xf2, 0x66, 0xb7, 0xd3, 0x93, 0xfe, 0x2a, 0xb3, 0x74, 0xed,
-      0xec, 0x4b, 0xb1, 0x5f, 0x5f, 0xee, 0x85, 0x44, 0xa7, 0x26, 0xdf, 0xc1,
-      0x2e, 0x7a, 0xf3, 0xa5, 0x8f, 0xf8, 0x64, 0xda, 0x65, 0xad, 0x91, 0xe2,
-      0x90, 0x94, 0x20, 0x16, 0xb8, 0x61, 0xa5, 0x0a, 0x7d, 0xb4, 0xbf, 0xc0,
-      0x10, 0xaf, 0x72, 0x67,
+      0xb7, 0xee, 0x25, 0x11, 0x66, 0xd4, 0xfd, 0x87, 0x10, 0x8f, 0x7c, 0x85,
+      0x9a, 0x1d, 0x35, 0x42, 0x2b, 0x02, 0x30, 0xaa, 0x8a, 0x81, 0xf7, 0x50,
+      0xb2, 0x64, 0xc0, 0x15, 0xe6, 0xbd, 0x5d, 0xe1, 0x03, 0x8b, 0xf4, 0xd3,
+      0x5b, 0x4a, 0x8c, 0xf1, 0x7f, 0x3f, 0xcd, 0x1f, 0xe0, 0x90, 0x78, 0x3a,
+      0xde, 0xef, 0xd2, 0x69, 0xe7, 0xe5, 0x59, 0xba, 0xc9, 0xde, 0x53, 0x74,
+      0x84, 0xaa, 0x33, 0x06, 0x29, 0x47, 0xd6, 0x0f, 0x00, 0xca, 0xe2, 0xde,
+      0xab, 0x6c, 0x86, 0x9d, 0xb2, 0xc6, 0x4f, 0xb6, 0x8e, 0xde, 0xbe, 0x1c,
+      0x26, 0x46, 0x2f, 0xbb, 0x05, 0xc1, 0x2b, 0x79, 0xb0, 0x82, 0x4e, 0xc9,
+      0x03, 0xb3, 0x1a, 0x27, 0xd0, 0xc8, 0x52, 0x2e, 0x22, 0x04, 0x70, 0x50,
+      0x1d, 0xcf, 0xd6, 0x6d, 0x7a, 0xa0, 0x88, 0x90, 0x3a, 0x49, 0x64, 0x65,
+      0x72, 0x88, 0x51, 0xe6, 0xdb, 0x8e, 0x8c, 0xbe, 0x1c, 0x50, 0xc7, 0x1a,
+      0xc0, 0x8b, 0x44, 0x3d, 0x84, 0x46, 0xb0, 0xa2, 0x7b, 0x37, 0xc8, 0x03,
+      0xf0, 0x01, 0x2e, 0x76, 0xc1, 0x0b, 0x7b, 0x0a, 0x5e, 0x62, 0xd9, 0x93,
+      0x4b, 0x86, 0xaf, 0xa8, 0x44, 0x20, 0x3f, 0xca, 0xe7, 0x6b, 0x8d, 0x27,
+      0x56, 0xf6, 0x03, 0xc1, 0xd5, 0x5e, 0xaa, 0x64, 0x34, 0xa4, 0xf6, 0xf2,
+      0x0b, 0x86, 0xc1, 0xd4, 0xa4, 0xa9, 0x6e, 0x58, 0x8c, 0x0a, 0x09, 0xca,
+      0xad, 0x4b, 0xd6, 0x6b, 0x3b, 0xfe, 0xfe, 0xfb, 0x09, 0x3c, 0x76, 0xdb,
+      0x33, 0x2d, 0x62, 0x28, 0x44, 0xc4, 0xd5, 0x43, 0xe4, 0x86, 0x2e, 0xa8,
+      0xa0, 0x26, 0xa8, 0x8c, 0xe9, 0x40, 0x7c, 0xf8, 0x59, 0x84, 0x07, 0xbd,
+      0x90, 0xe0, 0xc7, 0xcb, 0x76, 0x8b, 0x41, 0x0f, 0xba, 0xed, 0xc9, 0xbf,
+      0x14, 0x77, 0xc5, 0xdb, 0x16, 0xd1, 0xdb, 0x33, 0xbc, 0x20, 0xd0, 0xec,
+      0x04, 0xbf, 0xf8, 0xe3,
   };
 
   unsigned sig_len;
-  if (!rsa_sign_no_self_test(NID_sha256, kRSASignDigest, sizeof(kRSASignDigest),
-                             output, &sig_len, rsa_key) ||
+  if (!rsa_digestsign_no_self_test(EVP_sha256(), kRSASignPlaintext,
+                         sizeof(kRSASignPlaintext),output, &sig_len, rsa_key) ||
       !check_test(kRSASignSignature, output, sizeof(kRSASignSignature),
                   "RSA-sign KAT")) {
     fprintf(stderr, "RSA signing test failed.\n");
@@ -465,37 +465,37 @@ static int boringssl_self_test_rsa(void) {
 
   // RSA Verify KAT
 
-  static const uint8_t kRSAVerifyDigest[32] = {
+  static const uint8_t kRSAVerifyPlaintext[32] = {
       0x09, 0x65, 0x2f, 0xd8, 0xed, 0x9d, 0xc2, 0x6d, 0xbc, 0xbf, 0xf2,
       0xa7, 0xa5, 0xed, 0xe1, 0x37, 0x13, 0x78, 0x21, 0x36, 0xcf, 0x8d,
       0x22, 0x3d, 0xab, 0x93, 0xb4, 0x12, 0xa8, 0xb5, 0x15, 0x53,
   };
   static const uint8_t kRSAVerifySignature[256] = {
-      0xab, 0xe2, 0xcb, 0xc1, 0x3d, 0x6b, 0xd3, 0x9d, 0x48, 0xdb, 0x53, 0x34,
-      0xdd, 0xbf, 0x8d, 0x07, 0x0a, 0x93, 0xbd, 0xcb, 0x10, 0x4e, 0x2c, 0xc5,
-      0xd0, 0xee, 0x48, 0x6e, 0xe2, 0x95, 0xf6, 0xb3, 0x1b, 0xda, 0x12, 0x6c,
-      0x41, 0x89, 0x0b, 0x98, 0xb7, 0x3e, 0x70, 0xe6, 0xb6, 0x5d, 0x82, 0xf9,
-      0x5c, 0x66, 0x31, 0x21, 0x75, 0x5a, 0x90, 0x74, 0x4c, 0x8d, 0x1c, 0x21,
-      0x14, 0x8a, 0x19, 0x60, 0xbe, 0x0e, 0xca, 0x44, 0x6e, 0x9f, 0xf4, 0x97,
-      0xf1, 0x34, 0x5c, 0x53, 0x7e, 0xf8, 0x11, 0x9b, 0x9a, 0x43, 0x98, 0xe9,
-      0x5c, 0x5c, 0x6d, 0xe2, 0xb1, 0xc9, 0x55, 0x90, 0x5c, 0x52, 0x99, 0xd8,
-      0xce, 0x7a, 0x3b, 0x6a, 0xb7, 0x63, 0x80, 0xd9, 0xba, 0xbd, 0xd1, 0x5f,
-      0x61, 0x02, 0x37, 0xe1, 0xf3, 0xf2, 0xaa, 0x1c, 0x1f, 0x1e, 0x77, 0x0b,
-      0x62, 0xfb, 0xb5, 0x96, 0x38, 0x1b, 0x2e, 0xbd, 0xd7, 0x7e, 0xce, 0xf9,
-      0xc9, 0x0d, 0x4c, 0x92, 0xf7, 0xb6, 0xb0, 0x5f, 0xed, 0x29, 0x36, 0x28,
-      0x5f, 0xa9, 0x48, 0x26, 0xe6, 0x20, 0x55, 0x32, 0x2a, 0x33, 0xb6, 0xf0,
-      0x4c, 0x74, 0xce, 0x69, 0xe5, 0xd8, 0xd7, 0x37, 0xfb, 0x83, 0x8b, 0x79,
-      0xd2, 0xd4, 0x8e, 0x3d, 0xaf, 0x71, 0x38, 0x75, 0x31, 0x88, 0x25, 0x31,
-      0xa9, 0x5a, 0xc9, 0x64, 0xd0, 0x2e, 0xa4, 0x13, 0xbf, 0x85, 0x95, 0x29,
-      0x82, 0xbb, 0xc0, 0x89, 0x52, 0x7d, 0xaf, 0xf5, 0xb8, 0x45, 0xc9, 0xa0,
-      0xf4, 0xd1, 0x4e, 0xf1, 0x95, 0x6d, 0x9c, 0x3a, 0xca, 0xe8, 0x82, 0xd1,
-      0x2d, 0xa6, 0x6d, 0xa0, 0xf3, 0x57, 0x94, 0xf5, 0xee, 0x32, 0x23, 0x23,
-      0x33, 0x51, 0x7d, 0xb9, 0x31, 0x52, 0x32, 0xa1, 0x83, 0xb9, 0x91, 0x65,
-      0x4d, 0xbe, 0xa4, 0x16, 0x15, 0x34, 0x5c, 0x88, 0x53, 0x25, 0x92, 0x67,
-      0x44, 0xa5, 0x39, 0x15,
+      0xc5, 0xef, 0x03, 0x0d, 0x00, 0xa1, 0x3e, 0x3a, 0x70, 0x5b, 0x23, 0xe1,
+      0xe3, 0xde, 0x3f, 0x2c, 0x8e, 0x84, 0xb2, 0xe8, 0x2d, 0x1b, 0xec, 0x14,
+      0x11, 0x6f, 0x82, 0x45, 0xe5, 0xb6, 0xfa, 0x4b, 0x20, 0x7f, 0x12, 0xaf,
+      0xe7, 0x2c, 0x8d, 0x36, 0x67, 0x5a, 0xcb, 0x7d, 0x67, 0x0f, 0x6a, 0x5c,
+      0x59, 0x0e, 0x44, 0x71, 0x6c, 0x3d, 0xf3, 0x11, 0x04, 0xbe, 0xa8, 0x9f,
+      0x61, 0xbe, 0xcd, 0x6c, 0xc1, 0x88, 0x81, 0x48, 0x01, 0xd3, 0x08, 0xce,
+      0xec, 0x2a, 0x84, 0x3e, 0xc7, 0xf2, 0x5e, 0xbc, 0xdd, 0xe5, 0x88, 0xdd,
+      0x89, 0x80, 0x32, 0x69, 0x28, 0xb1, 0x08, 0x43, 0xc4, 0xb3, 0x19, 0x03,
+      0x38, 0xb0, 0xa0, 0x7c, 0x5a, 0x94, 0xa5, 0x3f, 0x6d, 0x84, 0xde, 0x79,
+      0x47, 0xf3, 0xdb, 0x3d, 0x9f, 0x73, 0x06, 0x10, 0xbf, 0x46, 0x3c, 0x29,
+      0x1f, 0xd9, 0x01, 0xab, 0x8a, 0x54, 0xe4, 0x7d, 0xbb, 0x19, 0x6d, 0x8a,
+      0xf5, 0x3e, 0xf1, 0x5f, 0xd0, 0x6b, 0x7a, 0xd0, 0xdd, 0xb6, 0x5c, 0x83,
+      0xc8, 0xfe, 0xe8, 0xd0, 0xa7, 0x08, 0x33, 0x47, 0x33, 0xcb, 0xe7, 0xb0,
+      0x33, 0x22, 0x69, 0x5d, 0x9a, 0x40, 0x6a, 0x68, 0x78, 0x67, 0xb3, 0x82,
+      0x94, 0xd8, 0x63, 0x48, 0x05, 0xd4, 0xcb, 0x68, 0x73, 0x73, 0x55, 0xd7,
+      0x76, 0x48, 0x4d, 0xf3, 0xcd, 0x8b, 0x8f, 0xeb, 0x51, 0xfd, 0x94, 0x60,
+      0x82, 0x18, 0xd8, 0x8e, 0xb2, 0xf2, 0xd0, 0x40, 0x64, 0x31, 0x2a, 0xd0,
+      0x41, 0x2e, 0x7a, 0x96, 0xd4, 0x9a, 0x9d, 0x71, 0xd7, 0x66, 0x06, 0xab,
+      0x7a, 0x5b, 0xd9, 0x9b, 0xc3, 0x1c, 0x37, 0x59, 0x3c, 0x83, 0x7f, 0x15,
+      0xba, 0x86, 0x01, 0x92, 0x6a, 0x1f, 0x69, 0x19, 0xd1, 0x11, 0x0b, 0x55,
+      0x90, 0x6e, 0x18, 0xe2, 0x9e, 0x2a, 0x94, 0x04, 0x5a, 0xe9, 0x21, 0x8b,
+      0xc6, 0xc8, 0xda, 0x74,
   };
-  if (!rsa_verify_no_self_test(NID_sha256, kRSAVerifyDigest,
-                               sizeof(kRSAVerifyDigest), kRSAVerifySignature,
+  if (!rsa_digestverify_no_self_test(EVP_sha256(), kRSAVerifyPlaintext,
+                               sizeof(kRSAVerifyPlaintext), kRSAVerifySignature,
                                sizeof(kRSAVerifySignature), rsa_key)) {
     fprintf(stderr, "RSA-verify KAT failed.\n");
     goto err;
@@ -526,7 +526,7 @@ static int boringssl_self_test_ecc(void) {
 
   // ECDSA Sign/Verify KAT
 
-  static const uint8_t kECDSASignDigest[32] = {
+  static const uint8_t kECDSASignPlaintext[32] = {
       0x1e, 0x35, 0x93, 0x0b, 0xe8, 0x60, 0xd0, 0x94, 0x2c, 0xa7, 0xbb,
       0xd6, 0xf6, 0xde, 0xd8, 0x7f, 0x15, 0x7e, 0x4d, 0xe2, 0x4f, 0x81,
       0xed, 0x4b, 0x87, 0x5c, 0x0e, 0x01, 0x8e, 0x89, 0xa8, 0x1f,
@@ -534,19 +534,18 @@ static int boringssl_self_test_ecc(void) {
   static const uint8_t kECDSASignSig[64] = {
       0x67, 0x80, 0xc5, 0xfc, 0x70, 0x27, 0x5e, 0x2c, 0x70, 0x61, 0xa0,
       0xe7, 0x87, 0x7b, 0xb1, 0x74, 0xde, 0xad, 0xeb, 0x98, 0x87, 0x02,
-      0x7f, 0x3f, 0xa8, 0x36, 0x54, 0x15, 0x8b, 0xa7, 0xf5, 0x0c, 0x68,
-      0x04, 0x73, 0x40, 0x94, 0xb2, 0xd1, 0x90, 0xac, 0x2d, 0x0c, 0xd7,
-      0xa5, 0x7f, 0x2f, 0x2e, 0xb2, 0x62, 0xb0, 0x09, 0x16, 0xe1, 0xa6,
-      0x70, 0xb5, 0xbb, 0x0d, 0xfd, 0x8e, 0x0c, 0x02, 0x3f,
+      0x7f, 0x3f, 0xa8, 0x36, 0x54, 0x15, 0x8b, 0xa7, 0xf5, 0x0c, 0x3a,
+      0x82, 0xd9, 0x65, 0xb2, 0xa7, 0x2a, 0xc5, 0xa6, 0x07, 0xbc, 0x56,
+      0xab, 0x37, 0x22, 0xc8, 0x42, 0xd9, 0x21, 0xc0, 0x49, 0x36, 0xe9,
+      0xe2, 0x5f, 0xd7, 0xb6, 0x00, 0xe7, 0xd8, 0xdc, 0x80,
   };
 
   // The 'k' value for ECDSA is fixed to avoid an entropy draw.
   uint8_t ecdsa_k[32] = {0};
   ecdsa_k[31] = 42;
 
-  sig = ecdsa_sign_with_nonce_for_known_answer_test(
-      kECDSASignDigest, sizeof(kECDSASignDigest), ec_key, ecdsa_k,
-      sizeof(ecdsa_k));
+  sig = ecdsa_digestsign_no_self_test(EVP_sha256(),kECDSASignPlaintext, sizeof
+                      (kECDSASignPlaintext), ec_key, ecdsa_k, sizeof(ecdsa_k));
 
   uint8_t ecdsa_sign_output[64];
   if (sig == NULL ||
@@ -557,7 +556,7 @@ static int boringssl_self_test_ecc(void) {
     goto err;
   }
 
-  static const uint8_t kECDSAVerifyDigest[32] = {
+  static const uint8_t kECDSAVerifyPlaintext[32] = {
       0x78, 0x7c, 0x50, 0x5c, 0x60, 0xc9, 0xe4, 0x13, 0x6c, 0xe4, 0x48,
       0xba, 0x93, 0xff, 0x71, 0xfa, 0x9c, 0x18, 0xf4, 0x17, 0x09, 0x4f,
       0xdf, 0x5a, 0xe2, 0x75, 0xc0, 0xcc, 0xd2, 0x67, 0x97, 0xad,
@@ -565,17 +564,17 @@ static int boringssl_self_test_ecc(void) {
   static const uint8_t kECDSAVerifySig[64] = {
       0x67, 0x80, 0xc5, 0xfc, 0x70, 0x27, 0x5e, 0x2c, 0x70, 0x61, 0xa0,
       0xe7, 0x87, 0x7b, 0xb1, 0x74, 0xde, 0xad, 0xeb, 0x98, 0x87, 0x02,
-      0x7f, 0x3f, 0xa8, 0x36, 0x54, 0x15, 0x8b, 0xa7, 0xf5, 0x0c, 0x2d,
-      0x36, 0xe5, 0x79, 0x97, 0x90, 0xbf, 0xbe, 0x21, 0x83, 0xd3, 0x3e,
-      0x96, 0xf3, 0xc5, 0x1f, 0x6a, 0x23, 0x2f, 0x2a, 0x24, 0x48, 0x8c,
-      0x8e, 0x5f, 0x64, 0xc3, 0x7e, 0xa2, 0xcf, 0x05, 0x29,
+      0x7f, 0x3f, 0xa8, 0x36, 0x54, 0x15, 0x8b, 0xa7, 0xf5, 0x0c, 0x3c,
+      0x77, 0xd1, 0xb6, 0xe0, 0x9e, 0x74, 0x7b, 0xc5, 0xab, 0x55, 0x01,
+      0xd7, 0x5e, 0x61, 0x8d, 0x8e, 0x5b, 0x27, 0x2e, 0x15, 0x9f, 0xf3,
+      0x41, 0x3c, 0xb7, 0x1a, 0x81, 0x40, 0x8d, 0x56, 0x05,
   };
 
   ECDSA_SIG_free(sig);
   sig = parse_ecdsa_sig(kECDSAVerifySig, sizeof(kECDSAVerifySig));
   if (!sig ||
-      !ecdsa_do_verify_no_self_test(kECDSAVerifyDigest,
-                                    sizeof(kECDSAVerifyDigest), sig, ec_key)) {
+      !ecdsa_digestverify_no_self_test(EVP_sha256(), kECDSAVerifyPlaintext,
+                                  sizeof(kECDSAVerifyPlaintext), sig, ec_key)) {
     fprintf(stderr, "ECDSA-verify KAT failed.\n");
     goto err;
   }
