From 672f02274e46b92bcd92a9f42cb88461d9e42cd6 Mon Sep 17 00:00:00 2001
From: David Benjamin <davidben@google.com>
Date: Fri, 3 Feb 2023 15:32:52 -0500
Subject: [PATCH] Fix leak in error-handling for issuingDistributionPoint

Handling of duplicate keys is all over the place. For set_reasons, it
tried to catch it but leaked memory. Also fix a hypothetical memory leak
in crldp_from_section, but I think it's actually impossible because any
list of CONF_VALUE from a section, rather than from X509V3_parse_list,
cannot have duplicates. It just overrides the previous value.

(Ideally we'd be consistent about whether duplicates override previous
values or are caught, but I'm opting to just leave the existing behavior
alone because no one should be using these APIs in the first place.)

Bug: oss-fuzz:55669
Change-Id: I95d23c257203dcd799d19f334ef847a97d060aad
Reviewed-on: https://boringssl-review.googlesource.com/c/boringssl/+/56865
Reviewed-by: Bob Beck <bbe@google.com>
Auto-Submit: David Benjamin <davidben@google.com>
Commit-Queue: David Benjamin <davidben@google.com>
(cherry picked from commit eb0b7e4df6eb5a082c2b977784f4270b55c58361)
---
 crypto/x509/x509_test.cc | 17 +++++++++++++++++
 crypto/x509v3/v3_crld.c  | 20 ++++++++++----------
 2 files changed, 27 insertions(+), 10 deletions(-)

diff --git a/crypto/x509/x509_test.cc b/crypto/x509/x509_test.cc
index 1235cf0df..cc12fe4bd 100644
--- a/crypto/x509/x509_test.cc
+++ b/crypto/x509/x509_test.cc
@@ -5427,6 +5427,23 @@ TEST(X509Test, ExtensionFromConf) {
       // value is not allowed.
       {"issuingDistributionPoint", "fullname", nullptr, {}},
 
+      // Duplicate reason keys are an error. Reaching this case is interesting.
+      // The value can a string like "key:value,key:value", or it can be
+      // "@section" and reference a config section. If using a string, duplicate
+      // keys are possible, but then it is impossible to put commas in the
+      // value, as onlysomereasons expects. If using a section reference, it is
+      // impossible to have a duplicate key because the config file parser
+      // overrides the old value.
+      {"issuingDistributionPoint",
+       "onlysomereasons:keyCompromise",
+       nullptr,
+       {0x30, 0x0d, 0x06, 0x03, 0x55, 0x1d, 0x1c, 0x04, 0x06, 0x30, 0x04, 0x83,
+        0x02, 0x06, 0x40}},
+      {"issuingDistributionPoint",
+       "onlysomereasons:keyCompromise,onlysomereasons:CACompromise\n",
+       nullptr,
+       {}},
+
       // subjectAltName has a series of string-based inputs for each name type.
       {"subjectAltName",
        "email:foo@example.com, URI:https://example.com, DNS:example.com, "
diff --git a/crypto/x509v3/v3_crld.c b/crypto/x509v3/v3_crld.c
index c431b0834..0206c7acf 100644
--- a/crypto/x509v3/v3_crld.c
+++ b/crypto/x509v3/v3_crld.c
@@ -209,26 +209,25 @@ static const BIT_STRING_BITNAME reason_flags[] = {
     {-1, NULL, NULL}};
 
 static int set_reasons(ASN1_BIT_STRING **preas, const char *value) {
-  STACK_OF(CONF_VALUE) *rsk = NULL;
-  const BIT_STRING_BITNAME *pbn;
-  const char *bnam;
-  size_t i;
-  int ret = 0;
-  rsk = X509V3_parse_list(value);
-  if (!rsk) {
+  if (*preas) {
+    // Duplicate "reasons" or "onlysomereasons" key.
+    OPENSSL_PUT_ERROR(X509V3, X509V3_R_INVALID_VALUE);
     return 0;
   }
-  if (*preas) {
+  int ret = 0;
+  STACK_OF(CONF_VALUE) *rsk = X509V3_parse_list(value);
+  if (!rsk) {
     return 0;
   }
-  for (i = 0; i < sk_CONF_VALUE_num(rsk); i++) {
-    bnam = sk_CONF_VALUE_value(rsk, i)->name;
+  for (size_t i = 0; i < sk_CONF_VALUE_num(rsk); i++) {
+    const char *bnam = sk_CONF_VALUE_value(rsk, i)->name;
     if (!*preas) {
       *preas = ASN1_BIT_STRING_new();
       if (!*preas) {
         goto err;
       }
     }
+    const BIT_STRING_BITNAME *pbn;
     for (pbn = reason_flags; pbn->lname; pbn++) {
       if (!strcmp(pbn->sname, bnam)) {
         if (!ASN1_BIT_STRING_set_bit(*preas, pbn->bitnum, 1)) {
@@ -292,6 +291,7 @@ static DIST_POINT *crldp_from_section(const X509V3_CTX *ctx,
         goto err;
       }
     } else if (!strcmp(cnf->name, "CRLissuer")) {
+      GENERAL_NAMES_free(point->CRLissuer);
       point->CRLissuer = gnames_from_sectname(ctx, cnf->value);
       if (!point->CRLissuer) {
         goto err;
