From 875b0936fcc14c34d1da91b0b5d7e8e9e6afa6a2 Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Mon, 4 Oct 2021 16:27:52 -0700
Subject: [PATCH] Add conversion into Montgomery form for P-521

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/73d32e36f0f6e981bb93abe9dd672f9e21e90a6c
---
 arm/p521/Makefile                 |   1 +
 arm/p521/bignum_tomont_p521.S     | 123 +++++++++++++++++++++++++++
 x86_att/p521/bignum_tomont_p521.S | 134 ++++++++++++++++++++++++++++++
 3 files changed, 258 insertions(+)
 create mode 100644 arm/p521/bignum_tomont_p521.S
 create mode 100644 x86_att/p521/bignum_tomont_p521.S

diff --git a/arm/p521/Makefile b/arm/p521/Makefile
index 646bb7d2a..b9a664f75 100644
--- a/arm/p521/Makefile
+++ b/arm/p521/Makefile
@@ -46,6 +46,7 @@ OBJ = bignum_add_p521.o \
       bignum_optneg_p521.o \
       bignum_sqr_p521.o \
       bignum_sub_p521.o \
+      bignum_tomont_p521.o \
       bignum_triple_p521.o
 
 %.o : %.S ; cpp $< | $(GAS) -o $@ -
diff --git a/arm/p521/bignum_tomont_p521.S b/arm/p521/bignum_tomont_p521.S
new file mode 100644
index 000000000..a8bed3f20
--- /dev/null
+++ b/arm/p521/bignum_tomont_p521.S
@@ -0,0 +1,123 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert to Montgomery form z := (2^576 * x) mod p_521
+// Input x[9]; output z[9]
+//
+//    extern void bignum_tomont_p521
+//     (uint64_t z[static 9], uint64_t x[static 9]);
+//
+// Standard ARM ABI: X0 = z, X1 = x
+// ----------------------------------------------------------------------------
+
+        .globl  bignum_tomont_p521
+        .text
+        .balign 4
+
+#define z x0
+#define x x1
+
+#define h x2
+#define t x3
+#define d0 x4
+#define d1 x5
+#define d2 x6
+#define d3 x7
+#define d4 x8
+#define d5 x9
+#define d6 x10
+#define d7 x11
+#define d8 x12
+
+bignum_tomont_p521:
+
+// Load top digit first and get its upper bits in h so that we
+// separate out x = 2^521 * H + L with h = H. Now x mod p_521 =
+// (H + L) mod p_521 = if H + L >= p_521 then H + L - p_521 else H + L.
+
+                ldr     d8, [x, #64]
+                lsr     h, d8, #9
+
+// Load in the other digits and decide whether H + L >= p_521. This is
+// equivalent to H + L + 1 >= 2^521, and since this can only happen if
+// digits d7,...,d1 consist entirely of 1 bits, we can condense the
+// carry chain by ANDing digits together, perhaps reducing its latency.
+// This condenses only three pairs; the payoff beyond that seems limited.
+// By stuffing in 1 bits from 521 position upwards, get CF directly
+
+                subs    xzr, xzr, xzr
+                ldp     d0, d1, [x]
+                adcs    xzr, d0, h
+                adcs    xzr, d1, xzr
+                ldp     d2, d3, [x, #16]
+                and     t, d2, d3
+                adcs    xzr, t, xzr
+                ldp     d4, d5, [x, #32]
+                and     t, d4, d5
+                adcs    xzr, t, xzr
+                ldp     d6, d7, [x, #48]
+                and     t, d6, d7
+                adcs    xzr, t, xzr
+                orr     t, d8, #~0x1FF
+                adcs    t, t, xzr
+
+// Now H + L >= p_521 <=> H + L + 1 >= 2^521 <=> CF from this comparison.
+// So if CF is set we want (H + L) - p_521 = (H + L + 1) - 2^521
+// while otherwise we want just H + L. So mask H + L + CF to 521 bits.
+
+                adcs    d0, d0, h
+                adcs    d1, d1, xzr
+                adcs    d2, d2, xzr
+                adcs    d3, d3, xzr
+                adcs    d4, d4, xzr
+                adcs    d5, d5, xzr
+                adcs    d6, d6, xzr
+                adcs    d7, d7, xzr
+                adc     d8, d8, xzr
+
+// So far, this is just a modular reduction as in bignum_mod_p521_9,
+// except that the final masking of d8 is skipped since that comes out
+// in the wash anyway from the next block, which is the Montgomery map,
+// multiplying by 2^576 modulo p_521. Because 2^521 == 1 (mod p_521)
+// this is just rotation left by 576 - 521 = 55 bits. To rotate in a
+// right-to-left fashion, which might blend better with the carry
+// chain above, the digit register indices themselves get shuffled up.
+
+                lsl     t, d0, #55
+                extr    d0, d1, d0, #9
+                extr    d1, d2, d1, #9
+                extr    d2, d3, d2, #9
+                extr    d3, d4, d3, #9
+                extr    d4, d5, d4, #9
+                extr    d5, d6, d5, #9
+                extr    d6, d7, d6, #9
+                extr    d7, d8, d7, #9
+                lsr     d8, d7, #9
+                orr     t, t, d8
+                and     d7, d7, #0x1FF
+
+// Store the result from the shuffled registers [d7;d6;...;d1;d0;t]
+
+                stp     t, d0, [z]
+                stp     d1, d2, [z, #16]
+                stp     d3, d4, [z, #32]
+                stp     d5, d6, [z, #48]
+                str     d7, [z, #64]
+                ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p521/bignum_tomont_p521.S b/x86_att/p521/bignum_tomont_p521.S
new file mode 100644
index 000000000..3eceb50dd
--- /dev/null
+++ b/x86_att/p521/bignum_tomont_p521.S
@@ -0,0 +1,134 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert to Montgomery form z := (2^576 * x) mod p_521
+// Input x[9]; output z[9]
+//
+//    extern void bignum_tomont_p521
+//     (uint64_t z[static 9], uint64_t x[static 9]);
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_tomont_p521
+        .text
+
+#define z %rdi
+#define x %rsi
+
+#define d0 %rax
+#define d1 %rcx
+#define d2 %r8
+#define d3 %r9
+#define d4 %r10
+#define d5 %r11
+#define d6 %rbx
+
+#define d8 %rdx
+
+#define d8short %edx
+
+// Re-use the input pointer as other variable once safe to do so
+
+#define d7 %rsi
+
+bignum_tomont_p521:
+
+// Save one more register
+
+        pushq   %rbx
+
+// Separate out the input into x = 2^521 * H + L, so that x mod p_521 =
+// (H + L) mod p_521 = if H + L >= p_521 then H + L - p_521 else H + L.
+
+        movq    64(x), d0
+        movl    $0x1FF, d8short
+        andq    d0, d8
+        shrq    $9, d0
+
+// Force carry-in to get s = [d8;d7;d6;d5;d4;d3;d2;d1;d0] = H + L + 1.
+
+        stc
+        adcq    (x), d0
+        movq    8(x), d1
+        adcq    $0, d1
+        movq    16(x), d2
+        adcq    $0, d2
+        movq    24(x), d3
+        adcq    $0, d3
+        movq    32(x), d4
+        adcq    $0, d4
+        movq    40(x), d5
+        adcq    $0, d5
+        movq    48(x), d6
+        adcq    $0, d6
+        movq    56(x), d7
+        adcq    $0, d7
+        adcq    $0, d8
+
+// Set CF <=> s < 2^521 <=> H + L < p_521, so that if CF is set
+// we want H + L = s - 1, otherwise (H + L) - p_521 = s - 2^521.
+// This is done with just s - CF then masking to 521 bits.
+
+        cmpq    $512, d8
+
+        sbbq    $0, d0
+        sbbq    $0, d1
+        sbbq    $0, d2
+        sbbq    $0, d3
+        sbbq    $0, d4
+        sbbq    $0, d5
+        sbbq    $0, d6
+        sbbq    $0, d7
+        sbbq    $0, d8
+
+// So far, this is just a modular reduction as in bignum_mod_p521_9,
+// except that the final masking of d8 is skipped since that comes out
+// in the wash anyway from the next block, which is the Montgomery map,
+// multiplying by 2^576 modulo p_521. Because 2^521 == 1 (mod p_521)
+// this is just rotation left by 576 - 521 = 55 bits. Store back
+// digits as created, though in a slightly peculiar order because we
+// want to avoid using another register.
+
+        shldq   $55, d7, d8
+        shldq   $55, d6, d7
+        movq    d7, 56(z)
+        shldq   $55, d5, d6
+        movq    d6, 48(z)
+        shldq   $55, d4, d5
+        movq    d5, 40(z)
+        shldq   $55, d3, d4
+        movq    d4, 32(z)
+        shldq   $55, d2, d3
+        movq    d3, 24(z)
+        shldq   $55, d1, d2
+        movq    d2, 16(z)
+        shldq   $55, d0, d1
+        movq    d1, 8(z)
+        shldq   $55, d8, d0
+        movq    d0, (z)
+        andq    $0x1FF, d8
+        movq    d8, 64(z)
+
+// Restore register
+
+        popq    %rbx
+        ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
