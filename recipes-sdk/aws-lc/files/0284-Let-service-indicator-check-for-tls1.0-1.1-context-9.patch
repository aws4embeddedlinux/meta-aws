From 46a85c367249723311c093124f349b4cc9e6cbd5 Mon Sep 17 00:00:00 2001
From: Samuel Chiang <sachiang@amazon.com>
Date: Thu, 13 Apr 2023 11:31:37 -0700
Subject: [PATCH] Let service indicator check for tls1.0/1.1 context (#927)

OpenSSL's way of doing this is checking the label and throwing an error when the
label "master secret"  is used. This is because "master secret" implies that the
PRF is used in a TLS1.0/1.1 context. In TLS1.2, the label is expected to be
"extended master secret". However, they only check if "master secret" is used
instead of checking if "extended master secret" is used, because the PRF can be
used for other purposes as well.
For our service indicator, we check if "extended master secret" is being used
in TLS1.2. In TLS1.0/1.1, both the labels "master secret" and "extended master
secret" can be used. We use the digests as an indicator of what TLS context
the PRF is being used in.
---
 .../fipsmodule/service_indicator/internal.h   |  7 +-
 .../service_indicator/service_indicator.c     | 25 ++++---
 .../service_indicator_test.cc                 | 68 +++++++++++++++----
 crypto/fipsmodule/tls/kdf.c                   |  2 +-
 4 files changed, 78 insertions(+), 24 deletions(-)

diff --git a/crypto/fipsmodule/service_indicator/internal.h b/crypto/fipsmodule/service_indicator/internal.h
index 426f6d41b..e05c4d620 100644
--- a/crypto/fipsmodule/service_indicator/internal.h
+++ b/crypto/fipsmodule/service_indicator/internal.h
@@ -51,7 +51,8 @@ void HKDFExpand_verify_service_indicator(const EVP_MD *evp_md);
 void PBKDF2_verify_service_indicator(const EVP_MD *evp_md, size_t password_len,
                                      size_t salt_len, unsigned iterations);
 void SSHKDF_verify_service_indicator(const EVP_MD *evp_md);
-void TLSKDF_verify_service_indicator(const EVP_MD *dgst);
+void TLSKDF_verify_service_indicator(const EVP_MD *dgst, const char *label,
+                                     size_t label_len);
 
 #else
 
@@ -111,7 +112,9 @@ OPENSSL_INLINE void SSHKDF_verify_service_indicator(
     OPENSSL_UNUSED const EVP_MD *evp_md) {}
 
 OPENSSL_INLINE void TLSKDF_verify_service_indicator(
-    OPENSSL_UNUSED const EVP_MD *dgst) {}
+    OPENSSL_UNUSED const EVP_MD *dgst,
+    OPENSSL_UNUSED const char *label,
+    OPENSSL_UNUSED size_t label_len) {}
 
 #endif // AWSLC_FIPS
 
diff --git a/crypto/fipsmodule/service_indicator/service_indicator.c b/crypto/fipsmodule/service_indicator/service_indicator.c
index ebaaa42c8..d56c728c6 100644
--- a/crypto/fipsmodule/service_indicator/service_indicator.c
+++ b/crypto/fipsmodule/service_indicator/service_indicator.c
@@ -20,6 +20,8 @@ int is_fips_build(void) {
 #if defined(AWSLC_FIPS)
 
 #define STATE_UNLOCKED 0
+#define TLS_MD_EXTENDED_MASTER_SECRET_CONST "extended master secret"
+#define TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE 22
 
 // fips_service_indicator_state is a thread-local structure that stores the
 // state of the FIPS service indicator.
@@ -443,20 +445,27 @@ void SSHKDF_verify_service_indicator(const EVP_MD *evp_md) {
   }
 }
 
-void TLSKDF_verify_service_indicator(const EVP_MD *dgst) {
-  // HMAC-MD5, HMAC-SHA1, and HMAC-MD5/HMAC-SHA1 (both used concurrently) are
-  // approved for use in the KDF in TLS 1.0/1.1.
+void TLSKDF_verify_service_indicator(const EVP_MD *dgst, const char *label,
+                                     size_t label_len) {
+  // HMAC-MD5/HMAC-SHA1 (both used concurrently) is approved for use in the KDF
+  // in TLS 1.0/1.1.
+  if(dgst->type == NID_md5_sha1) {
+    FIPS_service_indicator_update_state();
+    return;
+  }
   // HMAC-SHA{256, 384, 512} are approved for use in the KDF in TLS 1.2.
   // These Key Derivation functions are to be used in the context of the TLS
-  // protocol.
+  // protocol. Only the label "extended master secret" is allowed because
+  // it implies that the PRF is being used within a TLS 1.2 context.
   switch (dgst->type) {
-    case NID_md5:
-    case NID_sha1:
-    case NID_md5_sha1:
     case NID_sha256:
     case NID_sha384:
     case NID_sha512:
-      FIPS_service_indicator_update_state();
+      if (label_len >= TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE &&
+          memcmp(label, TLS_MD_EXTENDED_MASTER_SECRET_CONST,
+                 TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE) == 0) {
+          FIPS_service_indicator_update_state();
+      }
       break;
     default:
       break;
diff --git a/crypto/fipsmodule/service_indicator/service_indicator_test.cc b/crypto/fipsmodule/service_indicator/service_indicator_test.cc
index 7fe5823fb..ef5c4c245 100644
--- a/crypto/fipsmodule/service_indicator/service_indicator_test.cc
+++ b/crypto/fipsmodule/service_indicator/service_indicator_test.cc
@@ -434,6 +434,8 @@ static const uint8_t kTLSSecret[32] = {
     0x5f, 0x64, 0x55, 0xcd, 0xd5, 0x77, 0xa4, 0xc7, 0x09, 0x61,
 };
 static const char kTLSLabel[] = "FIPS self test";
+static const char extendedMasterSecretLabel[] = "extended master secret";
+
 static const uint8_t kTLSSeed1[16] = {
     0x8f, 0x0d, 0xe8, 0xb6, 0x90, 0x8f, 0xb1, 0xd2,
     0x6d, 0x51, 0xf4, 0x79, 0x18, 0x63, 0x51, 0x65,
@@ -443,7 +445,7 @@ static const uint8_t kTLSSeed2[16] = {
     0x31, 0x1e, 0x2b, 0x21, 0x41, 0x8d, 0x32, 0x81,
 };
 
-static const uint8_t kTLSOutput_mdsha1[32] = {
+static const uint8_t kTLSOutput1_mdsha1[32] = {
     0x36, 0xa9, 0x31, 0xb0, 0x43, 0xe3, 0x64, 0x72, 0xb9, 0x47, 0x54,
     0x0d, 0x8a, 0xfc, 0xe3, 0x5c, 0x1c, 0x15, 0x67, 0x7e, 0xa3, 0x5d,
     0xf2, 0x3a, 0x57, 0xfd, 0x50, 0x16, 0xe1, 0xa4, 0xa6, 0x37,
@@ -467,24 +469,48 @@ static const uint8_t kTLSOutput_sha224[32] = {
     0x5e, 0x39, 0x12, 0xc0, 0xd4, 0x30, 0xdf, 0x0c, 0xdf, 0x6b,
 };
 
-static const uint8_t kTLSOutput_sha256[32] = {
+static const uint8_t kTLSOutput1_sha256[32] = {
     0x67, 0x85, 0xde, 0x60, 0xfc, 0x0a, 0x83, 0xe9, 0xa2, 0x2a, 0xb3,
     0xf0, 0x27, 0x0c, 0xba, 0xf7, 0xfa, 0x82, 0x3d, 0x14, 0x77, 0x1d,
     0x86, 0x29, 0x79, 0x39, 0x77, 0x8a, 0xd5, 0x0e, 0x9d, 0x32,
 };
 
-static const uint8_t kTLSOutput_sha384[32] = {
+static const uint8_t kTLSOutput1_sha384[32] = {
     0x75, 0x15, 0x3f, 0x44, 0x7a, 0xfd, 0x34, 0xed, 0x2b, 0x67, 0xbc,
     0xd8, 0x57, 0x96, 0xab, 0xff, 0xf4, 0x0c, 0x05, 0x94, 0x02, 0x23,
     0x81, 0xbf, 0x0e, 0xd2, 0xec, 0x7c, 0xe0, 0xa7, 0xc3, 0x7d,
 };
 
-static const uint8_t kTLSOutput_sha512[32] = {
+static const uint8_t kTLSOutput1_sha512[32] = {
     0x68, 0xb9, 0xc8, 0x4c, 0xf5, 0x51, 0xfc, 0x7a, 0x1f, 0x6c, 0xe5,
     0x43, 0x73, 0x80, 0x53, 0x7c, 0xae, 0x76, 0x55, 0x67, 0xe0, 0x79,
     0xbf, 0x3a, 0x53, 0x71, 0xb7, 0x9c, 0xb5, 0x03, 0x15, 0x3f,
 };
 
+static const uint8_t kTLSOutput2_mdsha1[32] = {
+    0x21, 0x72, 0x18, 0xbe, 0x5a, 0xdc, 0xf7, 0x29, 0x1e, 0x81, 0x15,
+    0x46, 0x8d, 0x7f, 0x7e, 0x93, 0xac, 0xe5, 0x45, 0x26, 0x1a, 0x17,
+    0x7c, 0x3a, 0xd4, 0x17, 0xaa, 0xe6, 0xfc, 0x15, 0x55, 0x69
+};
+
+static const uint8_t kTLSOutput2_sha256[32] = {
+    0xfc, 0xa0, 0x34, 0x55, 0x73, 0x01, 0x22, 0x19, 0x93, 0x40, 0x56,
+    0x09, 0xfc, 0x8e, 0x42, 0xe4, 0x1a, 0x0c, 0xfa, 0x55, 0xaf, 0x19,
+    0xbb, 0x38, 0x64, 0x63, 0x4b, 0xfb, 0x79, 0x19, 0x8a, 0xfc
+};
+
+static const uint8_t kTLSOutput2_sha384[32] = {
+    0xc5, 0x37, 0xd2, 0x5e, 0x6d, 0xaf, 0x50, 0xd2, 0x1e, 0xe6, 0xd6,
+    0x26, 0x50, 0xbc, 0x36, 0xb3, 0xc5, 0xf9, 0x1c, 0x8f, 0x59, 0xfd,
+    0xf9, 0x0e, 0xcb, 0xe4, 0x0b, 0xa9, 0xaf, 0xa5, 0x48, 0x01
+};
+
+static const uint8_t kTLSOutput2_sha512[32] = {
+    0x12, 0xfe, 0x4f, 0xd9, 0x98, 0x64, 0x27, 0x3f, 0x82, 0xbb, 0xde,
+    0x87, 0x1b, 0x43, 0x01, 0xc2, 0x6c, 0x9b, 0xaa, 0x89, 0xd0, 0x47,
+    0x3d, 0x56, 0xa8, 0xf5, 0x9f, 0x2e, 0x8d, 0xbb, 0x77, 0x57
+};
+
 static const uint8_t kAESGCMCiphertext_128[64 + 16] = {
     0x38, 0x71, 0xcb, 0x61, 0x70, 0x60, 0x13, 0x8b, 0x2f, 0x91, 0x09, 0x7f,
     0x83, 0x20, 0x0f, 0x1f, 0x71, 0xe2, 0x47, 0x46, 0x6f, 0x5f, 0xa8, 0xad,
@@ -2569,16 +2595,32 @@ TEST_P(ECDH_ServiceIndicatorTest, ECDH) {
 static const struct KDFTestVector {
   // func is the hash function for KDF to test.
   const EVP_MD *(*func)();
+  const char *label;
+  const size_t label_len;
   const uint8_t *expected_output;
   const FIPSStatus expect_approved;
 } kKDFTestVectors[] = {
-    {EVP_md5, kTLSOutput_md, AWSLC_APPROVED},
-    {EVP_sha1, kTLSOutput_sha1, AWSLC_APPROVED},
-    {EVP_md5_sha1, kTLSOutput_mdsha1, AWSLC_APPROVED},
-    {EVP_sha224, kTLSOutput_sha224, AWSLC_NOT_APPROVED},
-    {EVP_sha256, kTLSOutput_sha256, AWSLC_APPROVED},
-    {EVP_sha384, kTLSOutput_sha384, AWSLC_APPROVED},
-    {EVP_sha512, kTLSOutput_sha512, AWSLC_APPROVED},
+    {EVP_md5, kTLSLabel, sizeof(kTLSLabel), kTLSOutput_md, AWSLC_NOT_APPROVED},
+    {EVP_sha1, kTLSLabel, sizeof(kTLSLabel), kTLSOutput_sha1,
+     AWSLC_NOT_APPROVED},
+    {EVP_md5_sha1, kTLSLabel, sizeof(kTLSLabel), kTLSOutput1_mdsha1,
+     AWSLC_APPROVED},
+    {EVP_md5_sha1, extendedMasterSecretLabel, sizeof(extendedMasterSecretLabel),
+     kTLSOutput2_mdsha1, AWSLC_APPROVED},
+    {EVP_sha224, kTLSLabel, sizeof(kTLSLabel), kTLSOutput_sha224,
+     AWSLC_NOT_APPROVED},
+    {EVP_sha256, kTLSLabel, sizeof(kTLSLabel), kTLSOutput1_sha256,
+     AWSLC_NOT_APPROVED},
+    {EVP_sha256, extendedMasterSecretLabel, sizeof(extendedMasterSecretLabel),
+     kTLSOutput2_sha256, AWSLC_APPROVED},
+    {EVP_sha384, kTLSLabel, sizeof(kTLSLabel), kTLSOutput1_sha384,
+     AWSLC_NOT_APPROVED},
+    {EVP_sha384, extendedMasterSecretLabel, sizeof(extendedMasterSecretLabel),
+     kTLSOutput2_sha384, AWSLC_APPROVED},
+    {EVP_sha512, kTLSLabel, sizeof(kTLSLabel), kTLSOutput1_sha512,
+     AWSLC_NOT_APPROVED},
+    {EVP_sha512, extendedMasterSecretLabel, sizeof(extendedMasterSecretLabel),
+     kTLSOutput2_sha512, AWSLC_APPROVED}
 };
 
 class KDF_ServiceIndicatorTest : public TestWithNoErrors<KDFTestVector> {};
@@ -2594,8 +2636,8 @@ TEST_P(KDF_ServiceIndicatorTest, TLSKDF) {
   uint8_t output[32];
   CALL_SERVICE_AND_CHECK_APPROVED(
       approved, ASSERT_TRUE(CRYPTO_tls1_prf(test.func(), output, sizeof(output),
-                                kTLSSecret, sizeof(kTLSSecret), kTLSLabel,
-                                sizeof(kTLSLabel), kTLSSeed1, sizeof(kTLSSeed1),
+                                kTLSSecret, sizeof(kTLSSecret), test.label,
+                                test.label_len, kTLSSeed1, sizeof(kTLSSeed1),
                                 kTLSSeed2, sizeof(kTLSSeed2))));
   EXPECT_EQ(Bytes(test.expected_output, sizeof(output)),
             Bytes(output, sizeof(output)));
diff --git a/crypto/fipsmodule/tls/kdf.c b/crypto/fipsmodule/tls/kdf.c
index 7383b3e6a..bb2de5deb 100644
--- a/crypto/fipsmodule/tls/kdf.c
+++ b/crypto/fipsmodule/tls/kdf.c
@@ -172,7 +172,7 @@ int CRYPTO_tls1_prf(const EVP_MD *digest,
 end:
   FIPS_service_indicator_unlock_state();
   if(ret) {
-    TLSKDF_verify_service_indicator(original_digest);
+    TLSKDF_verify_service_indicator(original_digest, label, label_len);
   }
   return ret;
 }
