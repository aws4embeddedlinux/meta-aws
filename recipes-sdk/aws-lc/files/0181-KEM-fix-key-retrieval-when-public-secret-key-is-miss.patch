From f0be3f046c78235a02d20a2999af26a2682e5c07 Mon Sep 17 00:00:00 2001
From: dkostic <25055813+dkostic@users.noreply.github.com>
Date: Thu, 9 Mar 2023 06:52:30 -0800
Subject: [PATCH] KEM: fix key retrieval when public/secret key is missing
 (#855)

Fixes key retrieval when public/secret key is missing. Specifically,
when `EVP_PKEY_get_raw_private_key` is called on a key that has
only the public key an error will be returned. The same when calling
`EVP_PKEY_get_raw_public_key` with a key that has only the
private key.

Got rid of the `has_secret_key field` in the `KEM_KEY` structure
because it is not necessary.

Made KEM `encapsulate` function a bit stricter with the function
arguments. Now, the arguments `ciphertext` and `shared_secret`
have to be either both NULL or both non-NULL. When both NULL
it's assumed the caller is performing a parameter length check.
When both non-NULL, the actual encapsulation is done. Otherwise,
the function fails.

---------

Co-authored-by: dkostic <dkostic@amazon.com>
---
 crypto/evp_extra/evp_extra_test.cc | 31 +++++++++++++++++++++++++++++-
 crypto/evp_extra/p_kem.c           | 20 +++++++++++++++----
 crypto/evp_extra/p_kem_asn1.c      | 10 ++++++++++
 crypto/kem/internal.h              |  1 -
 crypto/kem/kem.c                   |  3 ---
 include/openssl/evp.h              | 25 +++++++++++++++---------
 6 files changed, 72 insertions(+), 18 deletions(-)

diff --git a/crypto/evp_extra/evp_extra_test.cc b/crypto/evp_extra/evp_extra_test.cc
index 4ca932a00..7f9b5d755 100644
--- a/crypto/evp_extra/evp_extra_test.cc
+++ b/crypto/evp_extra/evp_extra_test.cc
@@ -1832,11 +1832,22 @@ TEST_P(PerKEMTest, Encapsulation) {
   EXPECT_EQ(ct_len, GetParam().ciphertext_len);
   EXPECT_EQ(ss_len, GetParam().shared_secret_len);
 
+  // When only one of |ct| or |ss| is NULL the function fails.
+  ASSERT_FALSE(EVP_PKEY_encapsulate(ctx.get(), ct.data(), &ct_len, nullptr, &ss_len));
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_MISSING_PARAMETERS, ERR_GET_REASON(err));
+
+  ASSERT_FALSE(EVP_PKEY_encapsulate(ctx.get(), nullptr, &ct_len, ss.data(), &ss_len));
+  err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_MISSING_PARAMETERS, ERR_GET_REASON(err));
+
   // ---- 4. Test calling encapsulate with different lengths ----
   // Set ct length to be less than expected -- should fail.
   ct_len = GetParam().ciphertext_len - 1;
   ASSERT_FALSE(EVP_PKEY_encapsulate(ctx.get(), ct.data(), &ct_len, ss.data(), &ss_len));
-  uint32_t err = ERR_get_error();
+  err = ERR_get_error();
   EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
   EXPECT_EQ(EVP_R_BUFFER_TOO_SMALL, ERR_GET_REASON(err));
 
@@ -2077,6 +2088,24 @@ TEST_P(PerKEMTest, RawKeyOperations) {
   EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
   EXPECT_EQ(EVP_R_BUFFER_TOO_SMALL, ERR_GET_REASON(err));
 
+  //   Missing public/private key.
+  pk_len = GetParam().public_key_len;
+  sk_len = GetParam().secret_key_len;
+  pkey_pk_new.reset(EVP_PKEY_kem_new_raw_public_key(nid, pk.data(), pk_len));
+  pkey_sk_new.reset(EVP_PKEY_kem_new_raw_secret_key(nid, sk.data(), sk_len));
+  ASSERT_TRUE(pkey_pk_new);
+  ASSERT_TRUE(pkey_sk_new);
+
+  ASSERT_FALSE(EVP_PKEY_get_raw_private_key(pkey_pk_new.get(), sk.data(), &sk_len));
+  err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_NO_KEY_SET, ERR_GET_REASON(err));
+
+  ASSERT_FALSE(EVP_PKEY_get_raw_public_key(pkey_sk_new.get(), pk.data(), &pk_len));
+  err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_NO_KEY_SET, ERR_GET_REASON(err));
+
   // Failures for new keys from raw data.
   pk_len = GetParam().public_key_len;
   sk_len = GetParam().secret_key_len;
diff --git a/crypto/evp_extra/p_kem.c b/crypto/evp_extra/p_kem.c
index 63a93456e..50c923dc7 100644
--- a/crypto/evp_extra/p_kem.c
+++ b/crypto/evp_extra/p_kem.c
@@ -53,8 +53,6 @@ static int pkey_kem_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey) {
     return 0;
   }
 
-  key->has_secret_key = 1;
-
   return 1;
 }
 
@@ -74,12 +72,19 @@ static int pkey_kem_encapsulate(EVP_PKEY_CTX *ctx,
   }
 
   // Caller is getting parameter values.
-  if (ciphertext == NULL) {
+  if (ciphertext == NULL && shared_secret == NULL) {
     *ciphertext_len = kem->ciphertext_len;
     *shared_secret_len = kem->shared_secret_len;
     return 1;
   }
 
+  // If not getting parameter values, then both
+  // output buffers need to be valid (non-NULL)
+  if (ciphertext == NULL || shared_secret == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_MISSING_PARAMETERS);
+    return 0;
+  }
+
   // The output buffers need to be large enough.
   if (*ciphertext_len < kem->ciphertext_len ||
       *shared_secret_len < kem->shared_secret_len) {
@@ -95,7 +100,13 @@ static int pkey_kem_encapsulate(EVP_PKEY_CTX *ctx,
       return 0;
   }
 
+  // Check that the key has a public key set.
   KEM_KEY *key = ctx->pkey->pkey.kem_key;
+  if (key->public_key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NO_KEY_SET);
+    return 0;
+  }
+
   if (!kem->method->encaps(ciphertext, shared_secret, key->public_key)) {
     return 0;
   }
@@ -144,8 +155,9 @@ static int pkey_kem_decapsulate(EVP_PKEY_CTX *ctx,
       return 0;
   }
 
+  // Check that the key has a secret key set.
   KEM_KEY *key = ctx->pkey->pkey.kem_key;
-  if (!key->has_secret_key) {
+  if (key->secret_key == NULL) {
     OPENSSL_PUT_ERROR(EVP, EVP_R_NO_KEY_SET);
     return 0;
   }
diff --git a/crypto/evp_extra/p_kem_asn1.c b/crypto/evp_extra/p_kem_asn1.c
index 15e38435b..b57b70311 100644
--- a/crypto/evp_extra/p_kem_asn1.c
+++ b/crypto/evp_extra/p_kem_asn1.c
@@ -39,6 +39,11 @@ static int kem_get_priv_raw(const EVP_PKEY *pkey, uint8_t *out,
     return 0;
   }
 
+  if (key->secret_key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NO_KEY_SET);
+    return 0;
+  }
+
   OPENSSL_memcpy(out, key->secret_key, kem->secret_key_len);
   *out_len = kem->secret_key_len;
 
@@ -69,6 +74,11 @@ static int kem_get_pub_raw(const EVP_PKEY *pkey, uint8_t *out,
     return 0;
   }
 
+  if (key->public_key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NO_KEY_SET);
+    return 0;
+  }
+
   OPENSSL_memcpy(out, key->public_key, kem->public_key_len);
   *out_len = kem->public_key_len;
 
diff --git a/crypto/kem/internal.h b/crypto/kem/internal.h
index 39413d8e3..825ced2f4 100644
--- a/crypto/kem/internal.h
+++ b/crypto/kem/internal.h
@@ -49,7 +49,6 @@ struct kem_key_st {
   const KEM *kem;
   uint8_t *public_key;
   uint8_t *secret_key;
-  uint8_t has_secret_key;
 };
 
 KEM_KEY *KEM_KEY_new(void);
diff --git a/crypto/kem/kem.c b/crypto/kem/kem.c
index c6cfcc20c..85375d71d 100644
--- a/crypto/kem/kem.c
+++ b/crypto/kem/kem.c
@@ -101,7 +101,6 @@ int KEM_KEY_init(KEM_KEY *key, const KEM *kem) {
   key->kem = kem;
   key->public_key = OPENSSL_malloc(kem->public_key_len);
   key->secret_key = OPENSSL_malloc(kem->secret_key_len);
-  key->has_secret_key = 0;
   if (key->public_key == NULL || key->secret_key == NULL) {
     OPENSSL_PUT_ERROR(EVP, ERR_R_MALLOC_FAILURE);
     KEM_KEY_clear(key);
@@ -139,7 +138,6 @@ int KEM_KEY_set_raw_secret_key(KEM_KEY *key, const uint8_t *in) {
     OPENSSL_PUT_ERROR(EVP, ERR_R_MALLOC_FAILURE);
     return 0;
   }
-  key->has_secret_key = 1;
 
   return 1;
 }
@@ -153,7 +151,6 @@ int KEM_KEY_set_raw_key(KEM_KEY *key, const uint8_t *in_public,
     KEM_KEY_clear(key);
     return 0;
   }
-  key->has_secret_key = 1;
 
   return 1;
 }
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 8661e9f2a..77f6493a0 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -710,12 +710,18 @@ OPENSSL_EXPORT int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **out_pkey);
 //   3. writes the length of |ciphertext| and |shared_secret| to
 //      |ciphertext_len| and |shared_secret_len|.
 //
-// If the given |ciphertext| is NULL it is assumed that the caller is doing
-// a size check: the function will write the size of the ciphertext and the
-// shared secret in |ciphertext_len| and |shared_secret_len| and return 1.
-// If |ciphertext| is non-NULL it is assumed that the caller is performing
-// the actual operation, so it is checked if the lengths of the output buffers,
-// |ciphertext_len| and |shared_secret_len|, are large enough for the KEM.
+// The function requires that output buffers, |ciphertext| and |shared_secret|,
+// be either both NULL or both non-NULL. Otherwise, a failure is returned.
+//
+// If both |ciphertext| and |shared_secret| are NULL it is assumed that
+// the caller is doing a size check: the function will write the size of
+// the ciphertext and the shared secret in |ciphertext_len| and
+// |shared_secret_len| and return successfully.
+//
+// If both |ciphertext| and |shared_secret| are not NULL it is assumed that
+// the caller is performing the actual operation. The function will check
+// additionally if the lengths of the output buffers, |ciphertext_len| and
+// |shared_secret_len|, are large enough for the KEM.
 //
 // NOTE: no allocation is done in the function, the caller is expected to
 // provide large enough |ciphertext| and |shared_secret| buffers.
@@ -735,10 +741,11 @@ OPENSSL_EXPORT int EVP_PKEY_encapsulate(EVP_PKEY_CTX *ctx          /* IN  */,
 //
 // If the given |shared_secret| is NULL it is assumed that the caller is doing
 // a size check: the function will write the size of the shared secret in
-// |shared_secret_len| and return 1.
+// |shared_secret_len| and return successfully.
+//
 // If |shared_secret| is non-NULL it is assumed that the caller is performing
-// the actual operation, so it is checked if the length of the output buffer,
-// |shared_secret_len|, is large enough for the KEM.
+// the actual operation. The functions will check additionally if the length of
+// the output buffer |shared_secret_len| is large enough for the KEM.
 //
 // NOTE: no allocation is done in the function, the caller is expected to
 // provide large enough |shared_secret| buffer.
