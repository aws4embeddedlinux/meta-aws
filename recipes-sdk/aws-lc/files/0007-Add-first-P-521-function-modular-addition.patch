From 1205f5510a2c90d90825c668767189c9d744ff69 Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Fri, 9 Jul 2021 14:14:08 -0700
Subject: [PATCH] Add first P-521 function, modular addition

This starts a new section "p521" devoted to special optimizations
related to the NIST P-521 curve, where the underlying field has
characteristic 2^521 - 1, a Mersenne prime. The function
bignum_add_p521 is modular addition w.r.t. this prime, by analogy with
the existing bignum_add_p256 and bignum_add_p384 functions.

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/ed9baaf833efe8299063790674b985770a493dbc
---
 arm/p521/Makefile          | 40 ++++++++++++++++
 arm/p521/bignum_add_p521.S | 98 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 138 insertions(+)
 create mode 100644 arm/p521/Makefile
 create mode 100644 arm/p521/bignum_add_p521.S

diff --git a/arm/p521/Makefile b/arm/p521/Makefile
new file mode 100644
index 000000000..fc7c912d8
--- /dev/null
+++ b/arm/p521/Makefile
@@ -0,0 +1,40 @@
+#############################################################################
+# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License").
+# You may not use this file except in compliance with the License.
+# A copy of the License is located at
+#
+#  http://aws.amazon.com/apache2.0
+#
+# or in the "LICENSE" file accompanying this file. This file is distributed
+# on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+# express or implied. See the License for the specific language governing
+# permissions and limitations under the License.
+#############################################################################
+
+# If actually on an ARM8 machine, just use the GNU assmbler (as). Otherwise
+# use a cross-assembling version so that the code can still be assembled
+# and the proofs checked against the object files (though you won't be able
+# to run code without additional emulation infrastructure). The aarch64
+# cross-assembling version can be installed manually by something like:
+#
+#  sudo apt-get install binutils-aarch64-linux-gnu
+
+UNAME_RESULT=$(shell uname -p)
+
+ifeq ($(UNAME_RESULT),aarch64)
+GAS=as
+else
+GAS=aarch64-linux-gnu-as
+endif
+
+# List of object files
+
+OBJ = bignum_add_p521.o
+
+%.o : %.S ; cpp $< | $(GAS) -o $@ -
+
+default: $(OBJ);
+
+clean:; rm -f *.o *.correct
diff --git a/arm/p521/bignum_add_p521.S b/arm/p521/bignum_add_p521.S
new file mode 100644
index 000000000..771b2b15a
--- /dev/null
+++ b/arm/p521/bignum_add_p521.S
@@ -0,0 +1,98 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Add modulo p_521, z := (x + y) mod p_521, assuming x and y reduced
+// Inputs x[9], y[9]; output z[9]
+//
+//    extern void bignum_add_p521
+//     (uint64_t z[static 9], uint64_t x[static 9], uint64_t y[static 9]);
+//
+// Standard ARM ABI: X0 = z, X1 = x, X2 = y
+// ----------------------------------------------------------------------------
+
+#define z x0
+#define x x1
+#define y x2
+#define h x3
+#define l x4
+#define d0 x5
+#define d1 x6
+#define d2 x7
+#define d3 x8
+#define d4 x9
+#define d5 x10
+#define d6 x11
+#define d7 x12
+#define d8 x13
+
+.text
+.globl bignum_add_p521
+
+bignum_add_p521:
+
+// Force carry-in to get s = [d8;d7;d6;d5;d4;d3;d2;d1;d0] = x + y + 1.
+// We ignore the carry-out, assuming inputs are reduced so there is none.
+
+                subs    xzr, xzr, xzr
+                ldp     d0, d1, [x]
+                ldp     l, h, [y]
+                adcs    d0, d0, l
+                adcs    d1, d1, h
+                ldp     d2, d3, [x, 16]
+                ldp     l, h, [y, 16]
+                adcs    d2, d2, l
+                adcs    d3, d3, h
+                ldp     d4, d5, [x, 32]
+                ldp     l, h, [y, 32]
+                adcs    d4, d4, l
+                adcs    d5, d5, h
+                ldp     d6, d7, [x, 48]
+                ldp     l, h, [y, 48]
+                adcs    d6, d6, l
+                adcs    d7, d7, h
+                ldr     d8, [x, 64]
+                ldr     l, [y, 64]
+                adc     d8, d8, l
+
+// Now x + y >= p_521 <=> s = x + y + 1 >= 2^521
+// Set CF <=> s = x + y + 1 >= 2^521 and make it a mask in l as well
+
+                subs    l, d8, 512
+                csetm   l, cs
+
+// Now if CF is set (and l is all 1s), we want (x + y) - p_521 = s - 2^521
+// while otherwise we want x + y = s - 1 (from existing CF, which is nice)
+
+                sbcs    d0, d0, xzr
+                and     l, l, 512
+                sbcs    d1, d1, xzr
+                sbcs    d2, d2, xzr
+                sbcs    d3, d3, xzr
+                sbcs    d4, d4, xzr
+                sbcs    d5, d5, xzr
+                sbcs    d6, d6, xzr
+                sbcs    d7, d7, xzr
+                sbc     d8, d8, l
+
+// Store the result
+
+                stp     d0, d1, [z]
+                stp     d2, d3, [z, 16]
+                stp     d4, d5, [z, 32]
+                stp     d6, d7, [z, 48]
+                str     d8, [z, 64]
+
+                ret
