From 17325c4a588f7125ec75ef653aab7c72006baf7d Mon Sep 17 00:00:00 2001
From: David Benjamin <davidben@google.com>
Date: Tue, 23 May 2023 11:45:10 -0400
Subject: [PATCH] Add int casts as needed around STACK_OF(T) sizes and indices

We now ensure STACK_OF(T) sizes and indices fit in INT_MAX, so it's safe
to cast to int.

Bug: 516
Change-Id: I33dd1de6d60a852d510b9b5c3ac70e2eacbc8905
Reviewed-on: https://boringssl-review.googlesource.com/c/boringssl/+/60066
Reviewed-by: Adam Langley <agl@google.com>
Commit-Queue: David Benjamin <davidben@google.com>
(cherry picked from commit 89a625375753303ec57710ba0f4d31b3b509bdea)
---
 crypto/x509/x509_att.c |  2 +-
 crypto/x509/x509_lu.c  |  5 ++---
 crypto/x509/x509_req.c |  4 ++--
 crypto/x509/x509_v3.c  | 20 ++++++++------------
 crypto/x509/x509_vfy.c | 33 ++++++++++++++++-----------------
 crypto/x509/x509name.c | 26 +++++++++++---------------
 crypto/x509/x_name.c   |  2 +-
 crypto/x509v3/v3_lib.c |  5 ++---
 8 files changed, 43 insertions(+), 54 deletions(-)

diff --git a/crypto/x509/x509_att.c b/crypto/x509/x509_att.c
index 23e92f294..062168eaf 100644
--- a/crypto/x509/x509_att.c
+++ b/crypto/x509/x509_att.c
@@ -189,7 +189,7 @@ err:
 }
 
 int X509_ATTRIBUTE_count(const X509_ATTRIBUTE *attr) {
-  return sk_ASN1_TYPE_num(attr->set);
+  return (int)sk_ASN1_TYPE_num(attr->set);
 }
 
 ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr) {
diff --git a/crypto/x509/x509_lu.c b/crypto/x509/x509_lu.c
index a9ee622ad..b1e4ca033 100644
--- a/crypto/x509/x509_lu.c
+++ b/crypto/x509/x509_lu.c
@@ -430,9 +430,8 @@ static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
   }
 
   if (pnmatch != NULL) {
-    int tidx;
     *pnmatch = 1;
-    for (tidx = idx + 1; tidx < (int)sk_X509_OBJECT_num(h); tidx++) {
+    for (size_t tidx = idx + 1; tidx < sk_X509_OBJECT_num(h); tidx++) {
       const X509_OBJECT *tobj = sk_X509_OBJECT_value(h, tidx);
       if (x509_object_cmp(tobj, &stmp)) {
         break;
@@ -441,7 +440,7 @@ static int x509_object_idx_cnt(STACK_OF(X509_OBJECT) *h, int type,
     }
   }
 
-  return idx;
+  return (int)idx;
 }
 
 int X509_OBJECT_idx_by_subject(STACK_OF(X509_OBJECT) *h, int type,
diff --git a/crypto/x509/x509_req.c b/crypto/x509/x509_req.c
index c659e0e36..9745cba9f 100644
--- a/crypto/x509/x509_req.c
+++ b/crypto/x509/x509_req.c
@@ -161,7 +161,7 @@ int X509_REQ_add_extensions(X509_REQ *req,
 }
 
 int X509_REQ_get_attr_count(const X509_REQ *req) {
-  return sk_X509_ATTRIBUTE_num(req->req_info->attributes);
+  return (int)sk_X509_ATTRIBUTE_num(req->req_info->attributes);
 }
 
 int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos) {
@@ -181,7 +181,7 @@ int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, const ASN1_OBJECT *obj,
   if (lastpos < 0) {
     lastpos = 0;
   }
-  int n = sk_X509_ATTRIBUTE_num(req->req_info->attributes);
+  int n = (int)sk_X509_ATTRIBUTE_num(req->req_info->attributes);
   for (; lastpos < n; lastpos++) {
     const X509_ATTRIBUTE *attr =
         sk_X509_ATTRIBUTE_value(req->req_info->attributes, lastpos);
diff --git a/crypto/x509/x509_v3.c b/crypto/x509/x509_v3.c
index 0d4ecfa22..0f506c9d1 100644
--- a/crypto/x509/x509_v3.c
+++ b/crypto/x509/x509_v3.c
@@ -69,7 +69,7 @@ int X509v3_get_ext_count(const STACK_OF(X509_EXTENSION) *x) {
   if (x == NULL) {
     return 0;
   }
-  return (sk_X509_EXTENSION_num(x));
+  return (int)sk_X509_EXTENSION_num(x);
 }
 
 int X509v3_get_ext_by_NID(const STACK_OF(X509_EXTENSION) *x, int nid,
@@ -83,9 +83,6 @@ int X509v3_get_ext_by_NID(const STACK_OF(X509_EXTENSION) *x, int nid,
 
 int X509v3_get_ext_by_OBJ(const STACK_OF(X509_EXTENSION) *sk,
                           const ASN1_OBJECT *obj, int lastpos) {
-  int n;
-  X509_EXTENSION *ex;
-
   if (sk == NULL) {
     return -1;
   }
@@ -93,9 +90,9 @@ int X509v3_get_ext_by_OBJ(const STACK_OF(X509_EXTENSION) *sk,
   if (lastpos < 0) {
     lastpos = 0;
   }
-  n = sk_X509_EXTENSION_num(sk);
+  int n = (int)sk_X509_EXTENSION_num(sk);
   for (; lastpos < n; lastpos++) {
-    ex = sk_X509_EXTENSION_value(sk, lastpos);
+    const X509_EXTENSION *ex = sk_X509_EXTENSION_value(sk, lastpos);
     if (OBJ_cmp(ex->object, obj) == 0) {
       return lastpos;
     }
@@ -115,7 +112,7 @@ int X509v3_get_ext_by_critical(const STACK_OF(X509_EXTENSION) *sk, int crit,
   }
 
   crit = !!crit;
-  int n = sk_X509_EXTENSION_num(sk);
+  int n = (int)sk_X509_EXTENSION_num(sk);
   for (; lastpos < n; lastpos++) {
     const X509_EXTENSION *ex = sk_X509_EXTENSION_value(sk, lastpos);
     if (X509_EXTENSION_get_critical(ex) == crit) {
@@ -146,13 +143,12 @@ X509_EXTENSION *X509v3_delete_ext(STACK_OF(X509_EXTENSION) *x, int loc) {
 STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
                                          const X509_EXTENSION *ex, int loc) {
   X509_EXTENSION *new_ex = NULL;
-  int n;
   STACK_OF(X509_EXTENSION) *sk = NULL;
   int free_sk = 0;
 
   if (x == NULL) {
     OPENSSL_PUT_ERROR(X509, ERR_R_PASSED_NULL_PARAMETER);
-    goto err2;
+    goto err;
   }
 
   if (*x == NULL) {
@@ -164,7 +160,7 @@ STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
     sk = *x;
   }
 
-  n = sk_X509_EXTENSION_num(sk);
+  int n = (int)sk_X509_EXTENSION_num(sk);
   if (loc > n) {
     loc = n;
   } else if (loc < 0) {
@@ -172,7 +168,7 @@ STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
   }
 
   if ((new_ex = X509_EXTENSION_dup(ex)) == NULL) {
-    goto err2;
+    goto err;
   }
   if (!sk_X509_EXTENSION_insert(sk, new_ex, loc)) {
     goto err;
@@ -181,8 +177,8 @@ STACK_OF(X509_EXTENSION) *X509v3_add_ext(STACK_OF(X509_EXTENSION) **x,
     *x = sk;
   }
   return sk;
+
 err:
-err2:
   X509_EXTENSION_free(new_ex);
   if (free_sk) {
     sk_X509_EXTENSION_free(sk);
diff --git a/crypto/x509/x509_vfy.c b/crypto/x509/x509_vfy.c
index fe6c59651..a11a9e160 100644
--- a/crypto/x509/x509_vfy.c
+++ b/crypto/x509/x509_vfy.c
@@ -217,7 +217,7 @@ int X509_verify_cert(X509_STORE_CTX *ctx) {
     goto end;
   }
 
-  num = sk_X509_num(ctx->chain);
+  num = (int)sk_X509_num(ctx->chain);
   x = sk_X509_value(ctx->chain, num - 1);
   depth = param->depth;
 
@@ -284,7 +284,7 @@ int X509_verify_cert(X509_STORE_CTX *ctx) {
 
   do {
     // Examine last certificate in chain and see if it is self signed.
-    i = sk_X509_num(ctx->chain);
+    i = (int)sk_X509_num(ctx->chain);
     x = sk_X509_value(ctx->chain, i - 1);
 
     int is_self_signed;
@@ -396,7 +396,7 @@ int X509_verify_cert(X509_STORE_CTX *ctx) {
             X509_free(xtmp);
             num--;
           }
-          ctx->last_untrusted = sk_X509_num(ctx->chain);
+          ctx->last_untrusted = (int)sk_X509_num(ctx->chain);
           retry = 1;
           break;
         }
@@ -630,7 +630,7 @@ static int check_name_constraints(X509_STORE_CTX *ctx) {
   int i, j, rv;
   int has_name_constraints = 0;
   // Check name constraints for all certificates
-  for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--) {
+  for (i = (int)sk_X509_num(ctx->chain) - 1; i >= 0; i--) {
     X509 *x = sk_X509_value(ctx->chain, i);
     // Ignore self issued certs unless last in chain
     if (i && (x->ex_flags & EXFLAG_SI)) {
@@ -640,7 +640,7 @@ static int check_name_constraints(X509_STORE_CTX *ctx) {
     // including trust anchor. Trust anchor not strictly speaking needed
     // but if it includes constraints it is to be assumed it expects them
     // to be obeyed.
-    for (j = sk_X509_num(ctx->chain) - 1; j > i; j--) {
+    for (j = (int)sk_X509_num(ctx->chain) - 1; j > i; j--) {
       NAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;
       if (nc) {
         has_name_constraints = 1;
@@ -750,11 +750,10 @@ static int check_id(X509_STORE_CTX *ctx) {
 }
 
 static int check_trust(X509_STORE_CTX *ctx) {
-  size_t i;
   int ok;
   X509 *x = NULL;
   // Check all trusted certificates in chain
-  for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
+  for (size_t i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
     x = sk_X509_value(ctx->chain, i);
     ok = X509_check_trust(x, ctx->param->trust, 0);
     // If explicitly trusted return trusted
@@ -764,7 +763,7 @@ static int check_trust(X509_STORE_CTX *ctx) {
     // If explicitly rejected notify callback and reject if not
     // overridden.
     if (ok == X509_TRUST_REJECTED) {
-      ctx->error_depth = i;
+      ctx->error_depth = (int)i;
       ctx->current_cert = x;
       ctx->error = X509_V_ERR_CERT_REJECTED;
       ok = ctx->verify_cb(0, ctx);
@@ -796,12 +795,12 @@ static int check_trust(X509_STORE_CTX *ctx) {
 }
 
 static int check_revocation(X509_STORE_CTX *ctx) {
-  int i, last, ok;
   if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK)) {
     return 1;
   }
+  int last;
   if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL) {
-    last = sk_X509_num(ctx->chain) - 1;
+    last = (int)sk_X509_num(ctx->chain) - 1;
   } else {
     // If checking CRL paths this isn't the EE certificate
     if (ctx->parent) {
@@ -809,9 +808,9 @@ static int check_revocation(X509_STORE_CTX *ctx) {
     }
     last = 0;
   }
-  for (i = 0; i <= last; i++) {
+  for (int i = 0; i <= last; i++) {
     ctx->error_depth = i;
-    ok = check_cert(ctx);
+    int ok = check_cert(ctx);
     if (!ok) {
       return ok;
     }
@@ -1480,9 +1479,9 @@ done:
 static int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl) {
   X509 *issuer = NULL;
   EVP_PKEY *ikey = NULL;
-  int ok = 0, chnum, cnum;
-  cnum = ctx->error_depth;
-  chnum = sk_X509_num(ctx->chain) - 1;
+  int ok = 0;
+  int cnum = ctx->error_depth;
+  int chnum = (int)sk_X509_num(ctx->chain) - 1;
   // if we have an alternative CRL issuer cert use that
   if (ctx->current_issuer) {
     issuer = ctx->current_issuer;
@@ -1692,11 +1691,11 @@ static int check_cert_time(X509_STORE_CTX *ctx, X509 *x) {
 }
 
 static int internal_verify(X509_STORE_CTX *ctx) {
-  int ok = 0, n;
+  int ok = 0;
   X509 *xs, *xi;
   EVP_PKEY *pkey = NULL;
 
-  n = sk_X509_num(ctx->chain);
+  int n = (int)sk_X509_num(ctx->chain);
   ctx->error_depth = n - 1;
   n--;
   xi = sk_X509_value(ctx->chain, n);
diff --git a/crypto/x509/x509name.c b/crypto/x509/x509name.c
index 25f7b8b35..eec2c8e02 100644
--- a/crypto/x509/x509name.c
+++ b/crypto/x509/x509name.c
@@ -99,7 +99,7 @@ int X509_NAME_entry_count(const X509_NAME *name) {
   if (name == NULL) {
     return 0;
   }
-  return (sk_X509_NAME_ENTRY_num(name->entries));
+  return (int)sk_X509_NAME_ENTRY_num(name->entries);
 }
 
 int X509_NAME_get_index_by_NID(const X509_NAME *name, int nid, int lastpos) {
@@ -109,26 +109,22 @@ int X509_NAME_get_index_by_NID(const X509_NAME *name, int nid, int lastpos) {
   if (obj == NULL) {
     return -2;
   }
-  return (X509_NAME_get_index_by_OBJ(name, obj, lastpos));
+  return X509_NAME_get_index_by_OBJ(name, obj, lastpos);
 }
 
 // NOTE: you should be passsing -1, not 0 as lastpos
 int X509_NAME_get_index_by_OBJ(const X509_NAME *name, const ASN1_OBJECT *obj,
                                int lastpos) {
-  int n;
-  X509_NAME_ENTRY *ne;
-  STACK_OF(X509_NAME_ENTRY) *sk;
-
   if (name == NULL) {
     return -1;
   }
   if (lastpos < 0) {
     lastpos = -1;
   }
-  sk = name->entries;
-  n = sk_X509_NAME_ENTRY_num(sk);
+  const STACK_OF(X509_NAME_ENTRY) *sk = name->entries;
+  int n = (int)sk_X509_NAME_ENTRY_num(sk);
   for (lastpos++; lastpos < n; lastpos++) {
-    ne = sk_X509_NAME_ENTRY_value(sk, lastpos);
+    const X509_NAME_ENTRY *ne = sk_X509_NAME_ENTRY_value(sk, lastpos);
     if (OBJ_cmp(ne->object, obj) == 0) {
       return lastpos;
     }
@@ -153,9 +149,9 @@ X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc) {
 
   STACK_OF(X509_NAME_ENTRY) *sk = name->entries;
   X509_NAME_ENTRY *ret = sk_X509_NAME_ENTRY_delete(sk, loc);
-  int n = sk_X509_NAME_ENTRY_num(sk);
+  size_t n = sk_X509_NAME_ENTRY_num(sk);
   name->modified = 1;
-  if (loc == n) {
+  if ((size_t)loc == n) {
     return ret;
   }
 
@@ -170,7 +166,7 @@ X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc) {
   // If we removed a singleton RDN, update the RDN indices so they are
   // consecutive again.
   if (set_prev + 1 < set_next) {
-    for (int i = loc; i < n; i++) {
+    for (size_t i = loc; i < n; i++) {
       sk_X509_NAME_ENTRY_value(sk, i)->set--;
     }
   }
@@ -221,14 +217,14 @@ int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,
 int X509_NAME_add_entry(X509_NAME *name, const X509_NAME_ENTRY *entry, int loc,
                         int set) {
   X509_NAME_ENTRY *new_name = NULL;
-  int n, i, inc;
+  int i, inc;
   STACK_OF(X509_NAME_ENTRY) *sk;
 
   if (name == NULL) {
     return 0;
   }
   sk = name->entries;
-  n = sk_X509_NAME_ENTRY_num(sk);
+  int n = (int)sk_X509_NAME_ENTRY_num(sk);
   if (loc > n) {
     loc = n;
   } else if (loc < 0) {
@@ -266,7 +262,7 @@ int X509_NAME_add_entry(X509_NAME *name, const X509_NAME_ENTRY *entry, int loc,
     goto err;
   }
   if (inc) {
-    n = sk_X509_NAME_ENTRY_num(sk);
+    n = (int)sk_X509_NAME_ENTRY_num(sk);
     for (i = loc + 1; i < n; i++) {
       sk_X509_NAME_ENTRY_value(sk, i)->set += 1;
     }
diff --git a/crypto/x509/x_name.c b/crypto/x509/x_name.c
index 846398246..96eed9c71 100644
--- a/crypto/x509/x_name.c
+++ b/crypto/x509/x_name.c
@@ -232,7 +232,7 @@ static int x509_name_ex_d2i(ASN1_VALUE **val, const unsigned char **in,
     entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname, i);
     for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
       entry = sk_X509_NAME_ENTRY_value(entries, j);
-      entry->set = i;
+      entry->set = (int)i;
       if (!sk_X509_NAME_ENTRY_push(nm->entries, entry)) {
         goto err;
       }
diff --git a/crypto/x509v3/v3_lib.c b/crypto/x509v3/v3_lib.c
index 52528eac0..fd58937e0 100644
--- a/crypto/x509v3/v3_lib.c
+++ b/crypto/x509v3/v3_lib.c
@@ -193,7 +193,6 @@ void *X509V3_EXT_d2i(const X509_EXTENSION *ext) {
 void *X509V3_get_d2i(const STACK_OF(X509_EXTENSION) *extensions, int nid,
                      int *out_critical, int *out_idx) {
   int lastpos;
-  size_t i;
   X509_EXTENSION *ex, *found_ex = NULL;
   if (!extensions) {
     if (out_idx) {
@@ -212,13 +211,13 @@ void *X509V3_get_d2i(const STACK_OF(X509_EXTENSION) *extensions, int nid,
   if (lastpos < 0) {
     lastpos = 0;
   }
-  for (i = lastpos; i < sk_X509_EXTENSION_num(extensions); i++) {
+  for (size_t i = lastpos; i < sk_X509_EXTENSION_num(extensions); i++) {
     ex = sk_X509_EXTENSION_value(extensions, i);
     if (OBJ_obj2nid(ex->object) == nid) {
       if (out_idx) {
         // TODO(https://crbug.com/boringssl/379): Consistently reject
         // duplicate extensions.
-        *out_idx = i;
+        *out_idx = (int)i;
         found_ex = ex;
         break;
       } else if (found_ex) {
