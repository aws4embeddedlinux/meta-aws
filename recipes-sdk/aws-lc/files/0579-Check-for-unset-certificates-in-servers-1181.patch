From 230231b54d04988e2b89da62d64967dd72435d90 Mon Sep 17 00:00:00 2001
From: Samuel Chiang <sachiang@amazon.com>
Date: Thu, 14 Sep 2023 09:22:45 -0700
Subject: [PATCH] Check for unset certificates in servers (#1181)

Static analysis revealed that we were expecting a certificate to always
exist with the paired private key. This may not always be the case
however. Connecting with a private key set, but no certificate set will
lead to a segfault. This commit resolves that and fails the connection
accordingly.
---
 ssl/internal.h     |  5 ++++
 ssl/ssl_cert.cc    |  6 ++--
 ssl/ssl_privkey.cc | 50 ++++++++++++++++++-------------
 ssl/ssl_test.cc    | 75 ++++++++++++++++++++++++++++++++++++++++++----
 4 files changed, 105 insertions(+), 31 deletions(-)

diff --git a/ssl/internal.h b/ssl/internal.h
index f44c26ac9..a0c5ec09f 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -1421,6 +1421,11 @@ OPENSSL_EXPORT bool ssl_cert_check_key_usage(const CBS *in,
 // nullptr and pushes to the error queue.
 UniquePtr<EVP_PKEY> ssl_cert_parse_pubkey(const CBS *in);
 
+// ssl_cert_parse_leaf_pubkey calls |ssl_cert_parse_pubkey| and extracts the
+// public key from the first element of |chain|. It's expected that the first
+// element of |chain| is the leaf certificate.
+UniquePtr<EVP_PKEY> ssl_cert_parse_leaf_pubkey(STACK_OF(CRYPTO_BUFFER) *chain);
+
 // ssl_parse_client_CA_list parses a CA list from |cbs| in the format used by a
 // TLS CertificateRequest message. On success, it returns a newly-allocated
 // |CRYPTO_BUFFER| list and advances |cbs|. Otherwise, it returns nullptr and
diff --git a/ssl/ssl_cert.cc b/ssl/ssl_cert.cc
index bf140fb0f..163c3f4cd 100644
--- a/ssl/ssl_cert.cc
+++ b/ssl/ssl_cert.cc
@@ -824,15 +824,13 @@ bool ssl_handshake_load_local_pubkey(SSL_HANDSHAKE *hs) {
       hs->config->cert
           ->cert_private_keys[hs->config->cert->cert_private_key_idx]
           .chain.get();
-  CBS leaf;
-  CRYPTO_BUFFER_init_CBS(sk_CRYPTO_BUFFER_value(chain, 0), &leaf);
 
   if (ssl_signing_with_dc(hs)) {
     hs->local_pubkey = UpRef(hs->config->cert->dc->pkey);
   } else {
-    hs->local_pubkey = ssl_cert_parse_pubkey(&leaf);
+    hs->local_pubkey = ssl_cert_parse_leaf_pubkey(chain);
   }
-  return hs->local_pubkey != NULL;
+  return hs->local_pubkey != nullptr;
 }
 
 
diff --git a/ssl/ssl_privkey.cc b/ssl/ssl_privkey.cc
index 9a4d39d50..2a6ec0a95 100644
--- a/ssl/ssl_privkey.cc
+++ b/ssl/ssl_privkey.cc
@@ -397,10 +397,14 @@ bool ssl_public_key_supports_signature_algorithm(SSL_HANDSHAKE *hs,
   return true;
 }
 
-static UniquePtr<EVP_PKEY> ssl_cert_parse_leaf_pubkey(
+UniquePtr<EVP_PKEY> ssl_cert_parse_leaf_pubkey(
     STACK_OF(CRYPTO_BUFFER) *chain) {
+  const CRYPTO_BUFFER *buf = sk_CRYPTO_BUFFER_value(chain, 0);
+  if (buf == nullptr) {
+    return nullptr;
+  }
   CBS leaf;
-  CRYPTO_BUFFER_init_CBS(sk_CRYPTO_BUFFER_value(chain, 0), &leaf);
+  CRYPTO_BUFFER_init_CBS(buf, &leaf);
   return ssl_cert_parse_pubkey(&leaf);
 }
 
@@ -416,20 +420,24 @@ bool ssl_cert_private_keys_supports_legacy_signature_algorithm(
 
   for (size_t i = 0; i < cert->cert_private_keys.size(); i++) {
     EVP_PKEY *private_key = cert->cert_private_keys[i].privatekey.get();
-    if (private_key != nullptr &&
-        // We may have a private key that supports the signature algorithm,
-        // but we need to verify that the negotiated cipher allows it.
-        hs->new_cipher->algorithm_auth &
-            ssl_cipher_auth_mask_for_key(private_key) &&
-        tls1_get_legacy_signature_algorithm(out, private_key)) {
-      // Update certificate slot index if all checks have passed.
-      //
-      // If the server has a valid private key available to use, we switch to
-      // using that certificate for the rest of the connection.
-      cert->cert_private_key_idx = (int)i;
-      hs->local_pubkey =
-          ssl_cert_parse_leaf_pubkey(cert->cert_private_keys[i].chain.get());
-      return true;
+    UniquePtr<EVP_PKEY> public_key =
+        ssl_cert_parse_leaf_pubkey(cert->cert_private_keys[i].chain.get());
+
+    if (private_key != nullptr && public_key != nullptr) {
+      // We may have a private key that supports the signature algorithm,
+      // but we need to verify that the negotiated cipher allows it.
+      const uint32_t auth_allowed = hs->new_cipher->algorithm_auth &
+                                    ssl_cipher_auth_mask_for_key(private_key);
+      if (auth_allowed &&
+          tls1_get_legacy_signature_algorithm(out, private_key)) {
+        // Update certificate slot index if all checks have passed.
+        //
+        // If the server has a valid private key available to use, we switch to
+        // using that certificate for the rest of the connection.
+        cert->cert_private_key_idx = (int)i;
+        hs->local_pubkey = std::move(public_key);
+        return true;
+      }
     }
   }
 
@@ -448,11 +456,11 @@ bool ssl_cert_private_keys_supports_signature_algorithm(SSL_HANDSHAKE *hs,
 
   for (size_t i = 0; i < cert->cert_private_keys.size(); i++) {
     EVP_PKEY *private_key = cert->cert_private_keys[i].privatekey.get();
-    if (private_key != nullptr &&
-        pkey_supports_algorithm(ssl, private_key, sigalg)) {
-      UniquePtr<EVP_PKEY> pubkey =
+    UniquePtr<EVP_PKEY> public_key =
           ssl_cert_parse_leaf_pubkey(cert->cert_private_keys[i].chain.get());
-      if (!ssl_public_key_rsa_pss_check(pubkey.get(), sigalg)) {
+    if (private_key != nullptr && public_key != nullptr &&
+        pkey_supports_algorithm(ssl, private_key, sigalg)) {
+      if (!ssl_public_key_rsa_pss_check(public_key.get(), sigalg)) {
         return false;
       }
 
@@ -461,7 +469,7 @@ bool ssl_cert_private_keys_supports_signature_algorithm(SSL_HANDSHAKE *hs,
       // If the server has a valid private key available to use, we switch to
       // using that certificate for the rest of the connection.
       cert->cert_private_key_idx = (int)i;
-      hs->local_pubkey = std::move(pubkey);
+      hs->local_pubkey = std::move(public_key);
       return true;
     }
   }
diff --git a/ssl/ssl_test.cc b/ssl/ssl_test.cc
index 925b25b5c..6c77139ca 100644
--- a/ssl/ssl_test.cc
+++ b/ssl/ssl_test.cc
@@ -5170,7 +5170,8 @@ class MultipleCertificateSlotTest
   const void StandardCertificateSlotIndexTests(SSL_CTX *client_ctx,
                                                SSL_CTX *server_ctx,
                                                std::vector<uint16_t> sigalgs,
-                                               int last_cert_type_set) {
+                                               int last_cert_type_set,
+                                               int should_fail) {
     EXPECT_TRUE(SSL_CTX_set_signing_algorithm_prefs(client_ctx, sigalgs.data(),
                                                     sigalgs.size()));
     EXPECT_TRUE(SSL_CTX_set_verify_algorithm_prefs(client_ctx, sigalgs.data(),
@@ -5184,8 +5185,12 @@ class MultipleCertificateSlotTest
     ClientConfig config;
     bssl::UniquePtr<SSL> client, server;
 
-    ASSERT_TRUE(ConnectClientAndServer(&client, &server, client_ctx, server_ctx,
-                                       config, false));
+    EXPECT_EQ(ConnectClientAndServer(&client, &server, client_ctx, server_ctx,
+                                     config, false),
+              should_fail);
+    if (!should_fail) {
+      return;
+    }
 
     ASSERT_TRUE(CompleteHandshakes(client.get(), server.get()));
 
@@ -5222,7 +5227,7 @@ TEST_P(MultipleCertificateSlotTest, CertificateSlotIndex) {
       client_ctx.get(), server_ctx.get(),
       {SSL_SIGN_ED25519, SSL_SIGN_ECDSA_SECP256R1_SHA256,
        SSL_SIGN_RSA_PSS_RSAE_SHA256},
-      slot_index);
+      slot_index, true);
 }
 
 // Sets up the |SSL_CTX| with |SSL_CTX_set_chain_and_key|.
@@ -5252,7 +5257,7 @@ TEST_P(MultipleCertificateSlotTest, SetChainAndKeyIndex) {
       client_ctx.get(), server_ctx.get(),
       {SSL_SIGN_ED25519, SSL_SIGN_ECDSA_SECP256R1_SHA256,
        SSL_SIGN_RSA_PSS_RSAE_SHA256},
-      slot_index);
+      slot_index, true);
 }
 
 TEST_P(MultipleCertificateSlotTest, AutomaticSelection) {
@@ -5287,9 +5292,67 @@ TEST_P(MultipleCertificateSlotTest, AutomaticSelection) {
 
   StandardCertificateSlotIndexTests(
       client_ctx.get(), server_ctx.get(),
-      {certificate_key_param().corresponding_sigalg}, SSL_PKEY_ED25519);
+      {certificate_key_param().corresponding_sigalg}, SSL_PKEY_ED25519, true);
+}
+
+TEST_P(MultipleCertificateSlotTest, MissingCertificate) {
+  if ((version == TLS1_1_VERSION || version == TLS1_VERSION) &&
+      slot_index == SSL_PKEY_ED25519) {
+    // ED25519 is not supported in versions prior to TLS1.2.
+    return;
+  }
+
+  bssl::UniquePtr<SSL_CTX> client_ctx(SSL_CTX_new(TLS_method()));
+  bssl::UniquePtr<SSL_CTX> server_ctx(SSL_CTX_new(TLS_method()));
+
+  ASSERT_TRUE(SSL_CTX_use_PrivateKey(server_ctx.get(), GetTestKey().get()));
+  ASSERT_TRUE(
+      SSL_CTX_use_PrivateKey(server_ctx.get(), GetECDSATestKey().get()));
+  ASSERT_TRUE(
+      SSL_CTX_use_PrivateKey(server_ctx.get(), GetED25519TestKey().get()));
+
+  // Versions prior to TLS1.3 need a valid authentication cipher suite to pair
+  // with the certificate.
+  if (version < TLS1_3_VERSION) {
+    ASSERT_TRUE(SSL_CTX_set_cipher_list(client_ctx.get(),
+                                        certificate_key_param().suite));
+  }
+
+  StandardCertificateSlotIndexTests(
+      client_ctx.get(), server_ctx.get(),
+      {certificate_key_param().corresponding_sigalg}, -1, false);
+}
+
+TEST_P(MultipleCertificateSlotTest, MissingPrivateKey) {
+  if ((version == TLS1_1_VERSION || version == TLS1_VERSION) &&
+      slot_index == SSL_PKEY_ED25519) {
+    // ED25519 is not supported in versions prior to TLS1.2.
+    return;
+  }
+
+  bssl::UniquePtr<SSL_CTX> client_ctx(SSL_CTX_new(TLS_method()));
+  bssl::UniquePtr<SSL_CTX> server_ctx(SSL_CTX_new(TLS_method()));
+
+  ASSERT_TRUE(
+      SSL_CTX_use_certificate(server_ctx.get(), GetTestCertificate().get()));
+  ASSERT_TRUE(SSL_CTX_use_certificate(server_ctx.get(),
+                                      GetECDSATestCertificate().get()));
+  ASSERT_TRUE(SSL_CTX_use_certificate(server_ctx.get(),
+                                      GetED25519TestCertificate().get()));
+
+  // Versions prior to TLS1.3 need a valid authentication cipher suite to pair
+  // with the certificate.
+  if (version < TLS1_3_VERSION) {
+    ASSERT_TRUE(SSL_CTX_set_cipher_list(client_ctx.get(),
+                                        certificate_key_param().suite));
+  }
+
+  StandardCertificateSlotIndexTests(
+      client_ctx.get(), server_ctx.get(),
+      {certificate_key_param().corresponding_sigalg}, -1, false);
 }
 
+
 struct MultiTransferReadWriteTestParams {
   const char suite[50];
   bool tls13;
