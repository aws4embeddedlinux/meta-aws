From a45c9b642ca33158fc8cb856480f6e5965fa471d Mon Sep 17 00:00:00 2001
From: Will Childs-Klein <childw@amazon.com>
Date: Tue, 16 May 2023 13:00:39 -0400
Subject: [PATCH] Merge integrate-pq into main (#897)

See PR #897 on the GitHub repo for full context.

Here's a summary of Dilithium-related changes from the integrate-pq branch that
are included in this squash:

- Import Reference PQCrystals Dilithium3 Implementation PR #614
- Add Dilithium3 higher level API integration PR #674
- Add Dilithium to bssl speed benchmarks PR #724
- Add Dilithium3 as choice of public key algorithm to x509 PR #759
- Dilithium3 - added fixed public/private key decoding tests PR #805

Here's a summary of changes made as part of PR #897's non-merge commits:

- Remove AES-mode dilithium code, fix error and doc comment
- Rename pqcrystals-dilithium_dilithium_common to pqcrystals_dilithium_ref_common
- Move dilithium KAT to dilithium folder
- Move dilithium key constants outside of test function
- Temporarily remove dilithium documentation
- Temporarily remove dilithium KATs and fuzz corpus
- Add opt-in build feature guard for Dilithium
- Fix speed.cc to work with new dilithium guard
- Add Dilithium3 case to POSIX tests, enable dilithium in benchmarks
- Rename DILITHIUM3 OID/NID to DILITHIUM3_R3

    This change qualifies the public DILITHIUM3 identifiers with a "round 3"
    (`_R3`) suffix. Internal function, variable, etc. are left as-is because
    they are not exposed to callers and can be updated if/when a materially
    different round 4 comes down the pipeline.

    Ideally, we'd be able to exclude this NID/OID entirely in non-dilithium
    builds, but this is not currently possible with the current
    `crypto/obj/` code. A next-best option would have been to put the
    Dilithium3 NID into an "experimental" NID namespace _well_ above the
    number of anticipated algorithms over the library's lifetime. I
    prototyped this out with an NID of 10,001 but as it turns out the
    tooling will expand NUM_NID and the `kObjects[]` in `obj_dat.h` and
    backfill all ~9000 ivervening array values with NULL/0-valued entries.
    This space tradeoff seemed unacceptable, so this implementation presents
    the `DILITHIUM3_R3` NID in all builds.

    The next commit will add a test to assert the behavior of trying to
    specify `DILITHIUM3_R3` in non-`DILITHIUM_ENABLED=ON` builds.

- Add disablement test when ENABLE_DILITHIUM=OFF
- Rename dilithium3_ref.c to dilithium3r3_ref.c
---
 CMakeLists.txt                                |   6 +
 crypto/CMakeLists.txt                         |  14 +
 crypto/dilithium/dilithium3r3_ref.c           |  26 +
 crypto/dilithium/p_dilithium3.c               | 114 +++
 crypto/dilithium/p_dilithium3_asn1.c          | 211 ++++
 crypto/dilithium/p_dilithium_test.cc          | 678 +++++++++++++
 .../pqcrystals_dilithium_ref_common/api.h     | 203 ++++
 .../pqcrystals_dilithium_ref_common/config.h  |  32 +
 .../pqcrystals_dilithium_ref_common/fips202.c | 774 +++++++++++++++
 .../pqcrystals_dilithium_ref_common/fips202.h |  64 ++
 .../pqcrystals_dilithium_ref_common/ntt.c     |  98 ++
 .../pqcrystals_dilithium_ref_common/ntt.h     |  13 +
 .../pqcrystals_dilithium_ref_common/packing.c | 237 +++++
 .../pqcrystals_dilithium_ref_common/packing.h |  38 +
 .../pqcrystals_dilithium_ref_common/params.h  |  74 ++
 .../pqcrystals_dilithium_ref_common/poly.c    | 907 ++++++++++++++++++
 .../pqcrystals_dilithium_ref_common/poly.h    |  79 ++
 .../pqcrystals_dilithium_ref_common/polyvec.c | 390 ++++++++
 .../pqcrystals_dilithium_ref_common/polyvec.h |  93 ++
 .../pqcrystals_dilithium_ref_common/reduce.c  |  69 ++
 .../pqcrystals_dilithium_ref_common/reduce.h  |  22 +
 .../rounding.c                                | 102 ++
 .../rounding.h                                |  19 +
 .../pqcrystals_dilithium_ref_common/sign.c    | 334 +++++++
 .../pqcrystals_dilithium_ref_common/sign.h    |  36 +
 .../symmetric-shake.c                         |  28 +
 .../symmetric.h                               |  34 +
 crypto/dilithium/sig_dilithium.h              |  45 +
 crypto/dilithium/sig_dilithium3.c             |  36 +
 crypto/evp_extra/evp_extra_test.cc            | 350 +++++++
 crypto/evp_extra/internal.h                   |  14 +
 crypto/evp_extra/p_methods.c                  |   6 +
 crypto/evp_extra/print.c                      |  60 ++
 crypto/fipsmodule/evp/digestsign.c            |   4 +-
 crypto/fipsmodule/evp/internal.h              |   6 +
 .../pqcrystals_kyber_ref_common/fips202.h     |   1 -
 crypto/obj/obj_dat.h                          |  19 +-
 crypto/obj/obj_mac.num                        |   1 +
 crypto/obj/obj_xref.c                         |   1 +
 crypto/obj/objects.txt                        |   5 +
 crypto/x509/algorithm.c                       |  10 +
 crypto/x509/x509_test.cc                      | 437 +++++++++
 include/openssl/evp.h                         |  37 +-
 include/openssl/nid.h                         |   4 +
 include/openssl/pem.h                         |   6 +
 tests/ci/run_benchmark_build_tests.sh         |   6 +-
 tests/ci/run_posix_tests.sh                   |   3 +
 tool/speed.cc                                 |  74 +-
 48 files changed, 5800 insertions(+), 20 deletions(-)
 create mode 100644 crypto/dilithium/dilithium3r3_ref.c
 create mode 100644 crypto/dilithium/p_dilithium3.c
 create mode 100644 crypto/dilithium/p_dilithium3_asn1.c
 create mode 100644 crypto/dilithium/p_dilithium_test.cc
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/api.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/config.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/packing.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/packing.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/params.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/poly.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/poly.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/sign.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/sign.h
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric-shake.c
 create mode 100644 crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric.h
 create mode 100644 crypto/dilithium/sig_dilithium.h
 create mode 100644 crypto/dilithium/sig_dilithium3.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 3cbbb6e13..43b21b436 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -18,6 +18,7 @@ endif()
 
 option(BUILD_TESTING "Build all test targets for AWS-LC" ON)
 option(BUILD_LIBSSL "Build libssl for AWS-LC" ON)
+option(ENABLE_DILITHIUM "Enable Dilithium signatures in the EVP API" OFF)
 option(DISABLE_PERL "Disable Perl for AWS-LC" OFF)
 option(DISABLE_GO "Disable Go for AWS-LC" OFF)
 include(cmake/go.cmake)
@@ -86,6 +87,11 @@ if(NOT PERL_EXECUTABLE OR NOT GO_EXECUTABLE)
   set(GENERATE_CODE_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/generated-src")
 endif()
 
+
+if(ENABLE_DILITHIUM)
+  add_definitions(-DENABLE_DILITHIUM)
+endif()
+
 if(USE_CUSTOM_LIBCXX)
   set(BORINGSSL_ALLOW_CXX_RUNTIME 1)
 endif()
diff --git a/crypto/CMakeLists.txt b/crypto/CMakeLists.txt
index e1e4018dc..d34602184 100644
--- a/crypto/CMakeLists.txt
+++ b/crypto/CMakeLists.txt
@@ -261,6 +261,18 @@ if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/rust_wrapper.c)
   list(APPEND CRYPTO_RUST_SOURCES rust_wrapper.c)
 endif()
 
+set(DILITHIUM_SOURCES)
+if(ENABLE_DILITHIUM)
+  set(
+    DILITHIUM_SOURCES
+
+    dilithium/dilithium3r3_ref.c
+    dilithium/p_dilithium3.c
+    dilithium/p_dilithium3_asn1.c
+    dilithium/sig_dilithium3.c
+  )
+endif()
+
 add_library(
   crypto_objects
   OBJECT
@@ -335,6 +347,7 @@ add_library(
   dh_extra/params.c
   dh_extra/dh_asn1.c
   digest_extra/digest_extra.c
+  ${DILITHIUM_SOURCES}
   dsa/dsa.c
   dsa/dsa_asn1.c
   ecdh_extra/ecdh_extra.c
@@ -681,6 +694,7 @@ if(BUILD_TESTING)
     ecdh_extra/ecdh_test.cc
     dh_extra/dh_test.cc
     digest_extra/digest_test.cc
+    dilithium/p_dilithium_test.cc
     dsa/dsa_test.cc
     err/err_test.cc
     evp_extra/evp_extra_test.cc
diff --git a/crypto/dilithium/dilithium3r3_ref.c b/crypto/dilithium/dilithium3r3_ref.c
new file mode 100644
index 000000000..fd7567911
--- /dev/null
+++ b/crypto/dilithium/dilithium3r3_ref.c
@@ -0,0 +1,26 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+
+#define DILITHIUM_MODE 3
+
+#include "./pqcrystals_dilithium_ref_common/config.h"
+#include "./pqcrystals_dilithium_ref_common/fips202.h"
+#include "./pqcrystals_dilithium_ref_common/ntt.h"
+#include "./pqcrystals_dilithium_ref_common/packing.h"
+#include "./pqcrystals_dilithium_ref_common/poly.h"
+#include "./pqcrystals_dilithium_ref_common/polyvec.h"
+#include "./pqcrystals_dilithium_ref_common/reduce.h"
+#include "./pqcrystals_dilithium_ref_common/rounding.h"
+#include "./pqcrystals_dilithium_ref_common/sign.h"
+#include "./pqcrystals_dilithium_ref_common/symmetric.h"
+
+#include "./pqcrystals_dilithium_ref_common/fips202.c"
+#include "./pqcrystals_dilithium_ref_common/ntt.c"
+#include "./pqcrystals_dilithium_ref_common/packing.c"
+#include "./pqcrystals_dilithium_ref_common/poly.c"
+#include "./pqcrystals_dilithium_ref_common/polyvec.c"
+#include "./pqcrystals_dilithium_ref_common/reduce.c"
+#include "./pqcrystals_dilithium_ref_common/rounding.c"
+#include "./pqcrystals_dilithium_ref_common/sign.c"
+#include "./pqcrystals_dilithium_ref_common/symmetric-shake.c"
diff --git a/crypto/dilithium/p_dilithium3.c b/crypto/dilithium/p_dilithium3.c
new file mode 100644
index 000000000..02de35e76
--- /dev/null
+++ b/crypto/dilithium/p_dilithium3.c
@@ -0,0 +1,114 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+#include <openssl/evp.h>
+#include <openssl/err.h>
+#include <openssl/mem.h>
+
+#include "../fipsmodule/evp/internal.h"
+#include "../evp_extra/internal.h"
+#include "sig_dilithium.h"
+
+static int pkey_dilithium3_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey) {
+  DILITHIUM3_KEY *key = OPENSSL_malloc(sizeof(DILITHIUM3_KEY));
+  if (key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, ERR_R_MALLOC_FAILURE);
+    goto err;
+  }
+
+  if (pkey == NULL || ctx == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_MISSING_PARAMETERS);
+    goto err;
+  }
+
+  if (!EVP_PKEY_set_type(pkey, EVP_PKEY_DILITHIUM3)) {
+    goto err;
+  }
+
+  if (DILITHIUM3_keypair(key->pub, key->priv) != 0) {
+    goto err;
+  }
+
+  key->has_private = 1;
+
+  OPENSSL_free(pkey->pkey.ptr);
+  pkey->pkey.ptr = key;
+  return 1;
+
+err:
+  OPENSSL_free(key);
+  return 0;
+
+}
+
+static int pkey_dilithium3_sign_message(EVP_PKEY_CTX *ctx, uint8_t *sig,
+                                        size_t *siglen, const uint8_t *tbs,
+                                        size_t tbslen) {
+  if (ctx == NULL || ctx->pkey->pkey.ptr == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_MISSING_PARAMETERS);
+    return 0;
+  }
+
+  DILITHIUM3_KEY *key = ctx->pkey->pkey.ptr;
+
+  if (!key->has_private) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NOT_A_PRIVATE_KEY);
+    return 0;
+  }
+  // Caller is getting parameter values.
+  if (sig == NULL) {
+    *siglen = DILITHIUM3_SIGNATURE_BYTES;
+    return 1;
+  }
+
+  if (*siglen < DILITHIUM3_SIGNATURE_BYTES) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_BUFFER_TOO_SMALL);
+    return 0;
+  }
+
+  if (DILITHIUM3_sign(sig, siglen, tbs, tbslen, key->priv) != 0) {
+    OPENSSL_PUT_ERROR(EVP, ERR_R_INTERNAL_ERROR);
+    return 0;
+  }
+  return 1;
+}
+
+static int pkey_dilithium3_verify_message(EVP_PKEY_CTX *ctx, const uint8_t *sig,
+                                          size_t siglen, const uint8_t *tbs,
+                                          size_t tbslen) {
+  if (ctx == NULL || ctx->pkey->pkey.ptr == NULL) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_MISSING_PARAMETERS);
+    return 0;
+  }
+
+  DILITHIUM3_KEY *key = ctx->pkey->pkey.ptr;
+
+  if (siglen != DILITHIUM3_SIGNATURE_BYTES ||
+      DILITHIUM3_verify(tbs, tbslen, sig, siglen, key->pub) != 0) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_INVALID_SIGNATURE);
+    return 0;
+  }
+  return 1;
+}
+
+const EVP_PKEY_METHOD dilithium3_pkey_meth = {
+    EVP_PKEY_DILITHIUM3,
+    NULL /* init */,
+    NULL /* copy */,
+    NULL /* cleanup */,
+    pkey_dilithium3_keygen,
+    NULL /* sign_init */,
+    NULL /* sign */,
+    pkey_dilithium3_sign_message,
+    NULL /* verify_init */,
+    NULL /* verify */,
+    pkey_dilithium3_verify_message,
+    NULL /* verify_recover */,
+    NULL /* encrypt */,
+    NULL /* decrypt */,
+    NULL /* derive */,
+    NULL /* paramgen */,
+    NULL /* ctrl */,
+    NULL /* encapsulate */,
+    NULL /* decapsulate */,
+};
diff --git a/crypto/dilithium/p_dilithium3_asn1.c b/crypto/dilithium/p_dilithium3_asn1.c
new file mode 100644
index 000000000..3e8956142
--- /dev/null
+++ b/crypto/dilithium/p_dilithium3_asn1.c
@@ -0,0 +1,211 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+#include <openssl/evp.h>
+
+#include <openssl/bytestring.h>
+#include <openssl/err.h>
+#include <openssl/mem.h>
+
+#include "../evp_extra/internal.h"
+#include "../fipsmodule/evp/internal.h"
+#include "../internal.h"
+#include "sig_dilithium.h"
+
+
+static void dilithium3_free(EVP_PKEY *pkey) {
+  OPENSSL_free(pkey->pkey.ptr);
+  pkey->pkey.ptr = NULL;
+}
+
+static int dilithium3_set_priv_raw(EVP_PKEY *pkey, const uint8_t *privkey,
+        size_t privkey_len, const uint8_t *pubkey, size_t pubkey_len) {
+  if (privkey_len != DILITHIUM3_PRIVATE_KEY_BYTES) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_DECODE_ERROR);
+    return 0;
+  }
+
+  DILITHIUM3_KEY *key = OPENSSL_malloc(sizeof(DILITHIUM3_KEY));
+  if (key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, ERR_R_MALLOC_FAILURE);
+    return 0;
+  }
+
+  OPENSSL_memcpy(key->priv, privkey, privkey_len);
+  key->has_private = 1;
+
+  dilithium3_free(pkey);
+  pkey->pkey.ptr = key;
+  return 1;
+}
+
+static int dilithium3_set_pub_raw(EVP_PKEY *pkey, const uint8_t *in, size_t len) {
+  if (len != DILITHIUM3_PUBLIC_KEY_BYTES) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_INVALID_KEYBITS);
+    return 0;
+  }
+
+  DILITHIUM3_KEY *key = OPENSSL_malloc(sizeof(DILITHIUM3_KEY));
+  if (key == NULL) {
+    OPENSSL_PUT_ERROR(EVP, ERR_R_MALLOC_FAILURE);
+    return 0;
+  }
+
+  OPENSSL_memcpy(key->pub, in, len);
+  key->has_private = 0;
+
+  dilithium3_free(pkey);
+  pkey->pkey.ptr = key;
+  return 1;
+}
+
+static int dilithium3_get_priv_raw(const EVP_PKEY *pkey, uint8_t *out,
+                                   size_t *out_len) {
+  const DILITHIUM3_KEY *key = pkey->pkey.ptr;
+  if (!key->has_private) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NOT_A_PRIVATE_KEY);
+    return 0;
+  }
+
+  if (out == NULL) {
+    *out_len = DILITHIUM3_PRIVATE_KEY_BYTES;
+    return 1;
+  }
+
+  if (*out_len < DILITHIUM3_PRIVATE_KEY_BYTES) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_BUFFER_TOO_SMALL);
+    return 0;
+  }
+
+  OPENSSL_memcpy(out, key->priv, DILITHIUM3_PRIVATE_KEY_BYTES);
+  *out_len = DILITHIUM3_PRIVATE_KEY_BYTES;
+  return 1;
+}
+
+static int dilithium3_get_pub_raw(const EVP_PKEY *pkey, uint8_t *out,
+                                  size_t *out_len) {
+  const DILITHIUM3_KEY *key = pkey->pkey.ptr;
+  if (out == NULL) {
+    *out_len = DILITHIUM3_PUBLIC_KEY_BYTES;
+    return 1;
+  }
+
+  if (*out_len < DILITHIUM3_PUBLIC_KEY_BYTES) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_BUFFER_TOO_SMALL);
+    return 0;
+  }
+
+  OPENSSL_memcpy(out, key->pub, DILITHIUM3_PUBLIC_KEY_BYTES);
+  *out_len = DILITHIUM3_PUBLIC_KEY_BYTES;
+  return 1;
+}
+
+static int dilithium3_pub_decode(EVP_PKEY *out, CBS *params, CBS *key) {
+  // See https://datatracker.ietf.org/doc/draft-ietf-lamps-dilithium-certificates/ section 4.
+  // The parameters must be omitted.
+  if (CBS_len(params) != 0) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_DECODE_ERROR);
+    return 0;
+  }
+
+  return dilithium3_set_pub_raw(out, CBS_data(key), CBS_len(key));
+}
+
+static int dilithium3_pub_encode(CBB *out, const EVP_PKEY *pkey) {
+  const DILITHIUM3_KEY *key = pkey->pkey.ptr;
+
+  // See https://datatracker.ietf.org/doc/draft-ietf-lamps-dilithium-certificates/ section 4.
+  // TODO: finalize this definition - OCTETSTRING to BITSTRING conversion.
+  CBB spki, algorithm, oid, key_bitstring;
+  if (!CBB_add_asn1(out, &spki, CBS_ASN1_SEQUENCE) ||
+      !CBB_add_asn1(&spki, &algorithm, CBS_ASN1_SEQUENCE) ||
+      !CBB_add_asn1(&algorithm, &oid, CBS_ASN1_OBJECT) ||
+      !CBB_add_bytes(&oid, dilithium3_asn1_meth.oid, dilithium3_asn1_meth.oid_len) ||
+      !CBB_add_asn1(&spki, &key_bitstring, CBS_ASN1_BITSTRING) ||
+      !CBB_add_u8(&key_bitstring, 0 /* padding */) ||
+      !CBB_add_bytes(&key_bitstring, key->pub, DILITHIUM3_PUBLIC_KEY_BYTES) ||
+      !CBB_flush(out)) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_ENCODE_ERROR);
+    return 0;
+  }
+
+  return 1;
+}
+
+static int dilithium3_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b) {
+  const DILITHIUM3_KEY *a_key = a->pkey.ptr;
+  const DILITHIUM3_KEY *b_key = b->pkey.ptr;
+  return OPENSSL_memcmp(a_key->pub, b_key->pub, DILITHIUM3_PUBLIC_KEY_BYTES) == 0;
+}
+
+static int dilithium3_priv_decode(EVP_PKEY *out, CBS *params, CBS *key, CBS *pubkey) {
+  // See https://datatracker.ietf.org/doc/draft-ietf-lamps-dilithium-certificates/ section 6.
+
+  // The parameters must be omitted.
+  if (CBS_len(params) != 0 ) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_DECODE_ERROR);
+    return 0;
+  }
+
+  return dilithium3_set_priv_raw(out, CBS_data(key), CBS_len(key), NULL, 0);
+}
+
+static int dilithium3_priv_encode(CBB *out, const EVP_PKEY *pkey) {
+  DILITHIUM3_KEY *key = pkey->pkey.ptr;
+  if (!key->has_private) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_NOT_A_PRIVATE_KEY);
+    return 0;
+  }
+  // See https://datatracker.ietf.org/doc/draft-ietf-lamps-dilithium-certificates/ section 6.
+  CBB pkcs8, algorithm, oid, private_key;
+  if (!CBB_add_asn1(out, &pkcs8, CBS_ASN1_SEQUENCE) ||
+      !CBB_add_asn1_uint64(&pkcs8, 0 /* version */) ||
+      !CBB_add_asn1(&pkcs8, &algorithm, CBS_ASN1_SEQUENCE) ||
+      !CBB_add_asn1(&algorithm, &oid, CBS_ASN1_OBJECT) ||
+      !CBB_add_bytes(&oid, dilithium3_asn1_meth.oid, dilithium3_asn1_meth.oid_len) ||
+      !CBB_add_asn1(&pkcs8, &private_key, CBS_ASN1_OCTETSTRING) ||
+      !CBB_add_bytes(&private_key, key->priv, DILITHIUM3_PRIVATE_KEY_BYTES) ||
+      !CBB_flush(out)) {
+    OPENSSL_PUT_ERROR(EVP, EVP_R_ENCODE_ERROR);
+    return 0;
+  }
+
+  return 1;
+}
+
+static int dilithium3_size(const EVP_PKEY *pkey) {
+  return DILITHIUM3_SIGNATURE_BYTES;
+}
+
+static int dilithium3_bits(const EVP_PKEY *pkey) {
+  return 8 * (DILITHIUM3_PUBLIC_KEY_BYTES);
+}
+
+const EVP_PKEY_ASN1_METHOD dilithium3_asn1_meth = {
+    EVP_PKEY_DILITHIUM3,
+    // 1.3.6.1.4.1.2.267.7.6.5 = Dilithium SIG Round-3. These are temp values from
+    // https://github.com/IETF-Hackathon/pqc-certificates/blob/master/docs/oid_mapping.md
+    // as we await NIST to release OIDs.
+    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x02, 0x82, 0x0B, 0x07, 0x06, 0x05},
+    11,
+    dilithium3_pub_decode,
+    dilithium3_pub_encode,
+    dilithium3_pub_cmp,
+    dilithium3_priv_decode,
+    dilithium3_priv_encode,
+    NULL /*priv_encode_v2*/,
+    dilithium3_set_priv_raw,
+    dilithium3_set_pub_raw,
+    dilithium3_get_priv_raw,
+    dilithium3_get_pub_raw,
+    NULL /* pkey_opaque */,
+    dilithium3_size,
+    dilithium3_bits,
+    NULL /* param_missing */,
+    NULL /* param_copy */,
+    NULL /* param_cmp */,
+    dilithium3_free,
+};
+
+
+
diff --git a/crypto/dilithium/p_dilithium_test.cc b/crypto/dilithium/p_dilithium_test.cc
new file mode 100644
index 000000000..08304120e
--- /dev/null
+++ b/crypto/dilithium/p_dilithium_test.cc
@@ -0,0 +1,678 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+#include <gtest/gtest.h>
+#include <openssl/base.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/mem.h>
+#include <openssl/obj.h>
+#include "../test/test_util.h"
+
+#include <vector>
+#include "../crypto/evp_extra/internal.h"
+#include "../fipsmodule/evp/internal.h"
+#include "../internal.h"
+
+#ifdef ENABLE_DILITHIUM
+
+#include "sig_dilithium.h"
+
+static const uint8_t kPublicKey[] = { 0xBB, 0x0A, 0x41, 0x1A, 0x53, 0x91, 0x4E,
+    0x67, 0x77, 0x78, 0xD0, 0xBC, 0xF0, 0xFD, 0x8A, 0x39, 0x65, 0x96, 0x48,
+    0x54, 0xF5, 0x91, 0xCE, 0xDB, 0x3B, 0x92, 0xBF, 0x2A, 0xC4, 0x01, 0xCD,
+    0xBE, 0x9E, 0x60, 0x05, 0x45, 0x68, 0x3E, 0xC0, 0xC6, 0xDC, 0xBB, 0x76,
+    0x42, 0x2D, 0x91, 0x47, 0xC2, 0x7C, 0x96, 0xAA, 0x5B, 0x28, 0x0D, 0x3B,
+    0x24, 0x50, 0x12, 0x4E, 0x05, 0x0F, 0xBD, 0x09, 0xB5, 0x51, 0xF5, 0xD6,
+    0x12, 0x93, 0xF8, 0x62, 0x69, 0x92, 0x25, 0x3B, 0x2E, 0x1B, 0xC8, 0x47,
+    0xFA, 0x06, 0x2C, 0x21, 0x8A, 0x62, 0xA2, 0x0A, 0x3F, 0x1B, 0xD3, 0x6D,
+    0x2D, 0x82, 0x4D, 0x7D, 0xDE, 0x80, 0xBB, 0x08, 0x79, 0x53, 0xD8, 0xDB,
+    0xCD, 0x73, 0xF8, 0x8F, 0x85, 0xA8, 0xB4, 0xB5, 0x63, 0xF5, 0x6A, 0x9C,
+    0xD5, 0x58, 0xAC, 0xD7, 0x9C, 0x96, 0x3C, 0xEA, 0x5A, 0x66, 0x69, 0xD6,
+    0x5E, 0xC3, 0xD5, 0x81, 0xFE, 0x6B, 0x42, 0xA0, 0xB6, 0x58, 0x54, 0xFA,
+    0x2F, 0xBE, 0x92, 0x9A, 0x41, 0xF8, 0x32, 0x10, 0x10, 0x86, 0x77, 0x01,
+    0xD6, 0xEF, 0x81, 0x14, 0x1B, 0xA3, 0x8B, 0xF4, 0x33, 0x94, 0x4E, 0x85,
+    0xDC, 0x94, 0x7C, 0x01, 0x9E, 0x6D, 0x9E, 0x7A, 0x26, 0x0F, 0xCF, 0xA0,
+    0x7D, 0x92, 0xB0, 0x84, 0x95, 0x76, 0xDF, 0x40, 0x85, 0x87, 0xEF, 0xF5,
+    0x33, 0x52, 0x2E, 0xF6, 0x73, 0x9E, 0xDA, 0x27, 0x6C, 0xEE, 0x08, 0xFE,
+    0x7A, 0x67, 0x43, 0x88, 0xC6, 0xF0, 0xF1, 0x0C, 0x08, 0xA5, 0x67, 0xC4,
+    0xB0, 0x01, 0xFB, 0x5B, 0x59, 0xFC, 0xAE, 0xCF, 0x07, 0x14, 0x52, 0x45,
+    0xD0, 0xEB, 0x97, 0xAB, 0x0E, 0x52, 0x65, 0x12, 0x41, 0xA2, 0x03, 0xB1,
+    0xE5, 0x1E, 0xA6, 0x33, 0xCE, 0x9A, 0x5C, 0x8F, 0xDF, 0x1A, 0x42, 0x6C,
+    0xB6, 0xCB, 0x78, 0xDD, 0x02, 0x78, 0xD9, 0xD8, 0xAE, 0x31, 0x5F, 0x13,
+    0xEB, 0x71, 0xD3, 0xAD, 0x6B, 0xD0, 0x98, 0x18, 0x7A, 0x5B, 0x0D, 0xA9,
+    0x5D, 0x35, 0xB4, 0x26, 0x5E, 0xCA, 0xF6, 0x7D, 0xC3, 0x9F, 0xE1, 0xBD,
+    0xFB, 0x73, 0xA6, 0xF1, 0xE0, 0x26, 0x0F, 0xCA, 0x1B, 0xC3, 0xA9, 0xD0,
+    0x27, 0x46, 0x82, 0x49, 0x73, 0xED, 0x3A, 0x6B, 0x61, 0x05, 0xD8, 0xA7,
+    0x7F, 0x2B, 0x36, 0x1C, 0x69, 0x31, 0x73, 0x29, 0xDE, 0x6D, 0x28, 0xB6,
+    0xEA, 0xFE, 0x37, 0xC2, 0xC0, 0x94, 0x4B, 0x3E, 0xD4, 0x21, 0x3F, 0xE0,
+    0x02, 0xFA, 0x5F, 0x16, 0xCE, 0x16, 0x66, 0xB5, 0xC9, 0xF6, 0x3F, 0x2A,
+    0x5C, 0x83, 0x00, 0x5F, 0xDA, 0x0B, 0x6E, 0xE7, 0xB6, 0x55, 0x55, 0xBF,
+    0x50, 0x29, 0x8E, 0x39, 0xA2, 0xB7, 0x85, 0x79, 0xC3, 0xCE, 0x93, 0x63,
+    0x57, 0xD1, 0xF2, 0x03, 0x6E, 0x42, 0x78, 0xB3, 0x5F, 0x72, 0x5C, 0x7D,
+    0xB0, 0xE0, 0x55, 0x96, 0xE1, 0x34, 0x0B, 0x5C, 0x75, 0xA9, 0xEF, 0x17,
+    0x47, 0x5B, 0xDC, 0x4F, 0x01, 0x5D, 0x80, 0x60, 0x14, 0xA7, 0x9A, 0xD3,
+    0x38, 0x07, 0xDA, 0x61, 0x0D, 0x7F, 0x37, 0xEC, 0x0A, 0xD3, 0x54, 0x91,
+    0x53, 0x16, 0x3D, 0xAD, 0xC8, 0x2C, 0xAC, 0xBB, 0x1B, 0x03, 0xD7, 0x96,
+    0x8D, 0x6D, 0x2D, 0x81, 0xBB, 0x57, 0xDB, 0x10, 0x3E, 0xFD, 0xCF, 0xA9,
+    0xA3, 0xA4, 0xAF, 0xF7, 0xA1, 0x9F, 0x4B, 0xB0, 0x3E, 0x3D, 0x51, 0x15,
+    0xEA, 0x63, 0x8C, 0x75, 0x59, 0x78, 0xBB, 0xEC, 0x94, 0x47, 0xA8, 0x81,
+    0x7B, 0x98, 0xF1, 0x6E, 0x0A, 0xAD, 0xE6, 0x42, 0x58, 0x37, 0x76, 0x8E,
+    0x06, 0xA5, 0x43, 0xBF, 0xE9, 0xFA, 0x53, 0x2E, 0xAC, 0x2E, 0xBC, 0x6A,
+    0x99, 0x08, 0x51, 0x98, 0xAC, 0x3A, 0x23, 0x52, 0x19, 0x07, 0x81, 0x14,
+    0x4C, 0x62, 0x3F, 0x38, 0x2C, 0xB6, 0x70, 0x33, 0xD8, 0xB3, 0x97, 0x5B,
+    0x9C, 0x54, 0x62, 0x63, 0x03, 0xA8, 0xAD, 0xC1, 0xB3, 0xC6, 0x3A, 0x74,
+    0x5D, 0x6E, 0x9C, 0x3F, 0xCE, 0xE8, 0x79, 0xF4, 0x02, 0x90, 0x3A, 0x2B,
+    0x51, 0x50, 0x9F, 0x88, 0xF5, 0x98, 0xA7, 0xC4, 0xD2, 0xE9, 0x4F, 0xCA,
+    0x52, 0xE9, 0xE1, 0xB2, 0xB3, 0x78, 0xB0, 0xA2, 0x33, 0x9F, 0xA8, 0xC3,
+    0xD9, 0xB6, 0xDD, 0x6A, 0x05, 0x5B, 0xC7, 0x52, 0xC3, 0x68, 0xC2, 0x30,
+    0x7F, 0x74, 0x1E, 0x07, 0x66, 0xC3, 0xA4, 0x2D, 0x84, 0xAA, 0x17, 0xD6,
+    0x49, 0x89, 0x60, 0x31, 0x0E, 0x4E, 0xAE, 0xCF, 0x56, 0x93, 0x40, 0x3C,
+    0x9B, 0xC9, 0x13, 0x5C, 0x5D, 0x38, 0x94, 0xAE, 0x6F, 0xE9, 0x04, 0xB7,
+    0xA6, 0x1E, 0xAB, 0xB9, 0xD4, 0x04, 0xFF, 0x3C, 0x99, 0x2F, 0xE4, 0x80,
+    0x69, 0xDB, 0x50, 0x5B, 0xAC, 0x34, 0x48, 0x77, 0xF6, 0xB2, 0x00, 0x02,
+    0x8D, 0x75, 0xA0, 0x2E, 0x93, 0x0A, 0x20, 0x22, 0x2F, 0x73, 0x15, 0xEA,
+    0xEA, 0xBD, 0x8B, 0xE6, 0x85, 0xFD, 0x30, 0x97, 0xF7, 0x24, 0xB9, 0xD5,
+    0x30, 0xA0, 0x7A, 0x36, 0x0E, 0xA4, 0xE1, 0xEA, 0xFD, 0xE6, 0xDD, 0xB6,
+    0xFF, 0xC6, 0xFC, 0x20, 0xD6, 0x71, 0x36, 0x1B, 0x5D, 0xF2, 0x63, 0xCA,
+    0xC6, 0xDE, 0x55, 0xF2, 0x39, 0x05, 0x9A, 0x88, 0x0C, 0x7C, 0xAC, 0x5C,
+    0xC0, 0x50, 0x05, 0x1F, 0xDE, 0xBB, 0x6E, 0xF2, 0x06, 0x77, 0x9A, 0xC7,
+    0x03, 0x14, 0x26, 0xD4, 0x5D, 0xE0, 0xA9, 0x02, 0xC6, 0xA1, 0xCA, 0x4B,
+    0x8D, 0xAC, 0x0B, 0x54, 0xC1, 0xF7, 0x91, 0xBF, 0xD0, 0xE6, 0xEE, 0x4B,
+    0x21, 0x82, 0xE2, 0x33, 0xD2, 0xB4, 0xC0, 0x14, 0x64, 0xC8, 0x6B, 0xD0,
+    0x50, 0xE5, 0x4A, 0x84, 0xF2, 0x25, 0x23, 0x2E, 0xD2, 0x65, 0x3B, 0x4A,
+    0x72, 0x03, 0xAA, 0x0C, 0x82, 0x98, 0x14, 0x11, 0x8E, 0x4A, 0x1F, 0x77,
+    0xE1, 0x82, 0xBE, 0xB4, 0x5C, 0xE4, 0x7A, 0x74, 0xFE, 0x29, 0x42, 0xCD,
+    0x9D, 0xED, 0x40, 0xC8, 0x88, 0x85, 0xFA, 0x98, 0xBA, 0xBC, 0x45, 0xC7,
+    0xCE, 0x5B, 0xB8, 0x36, 0x1B, 0x2A, 0x69, 0x55, 0xF5, 0x98, 0xCF, 0xD7,
+    0x4E, 0x7F, 0x2F, 0x59, 0x4D, 0x26, 0x33, 0x54, 0xD2, 0x5F, 0x51, 0xFD,
+    0xD2, 0xB9, 0xBB, 0xE0, 0x99, 0x5A, 0xDD, 0xD0, 0x11, 0xEA, 0xFC, 0x84,
+    0xD2, 0x21, 0x06, 0x26, 0xEA, 0x2E, 0xBA, 0x52, 0xEB, 0x39, 0xF0, 0x97,
+    0x5B, 0xCC, 0x76, 0xAF, 0x87, 0x94, 0x9F, 0xB0, 0xA0, 0xD1, 0x59, 0x9F,
+    0x73, 0x83, 0x69, 0x50, 0x76, 0x03, 0x0D, 0x44, 0x13, 0xE1, 0x2B, 0x31,
+    0xF9, 0xF4, 0xE2, 0x6D, 0xCD, 0x31, 0xBF, 0x39, 0xFC, 0x61, 0xA1, 0x40,
+    0x52, 0x56, 0xF5, 0xD7, 0x12, 0x12, 0xAB, 0x5E, 0x81, 0x48, 0x8A, 0x2E,
+    0xE8, 0x85, 0xDC, 0xE7, 0x65, 0x16, 0x6B, 0xBE, 0x28, 0x93, 0x95, 0x0B,
+    0x0E, 0x20, 0xFE, 0x4F, 0xF7, 0xEB, 0x0E, 0xEF, 0x2D, 0x41, 0x0C, 0x24,
+    0x0C, 0x3F, 0xA6, 0x62, 0x61, 0xB3, 0x7A, 0x5E, 0x9A, 0xEF, 0xF6, 0xAE,
+    0x93, 0x51, 0xD5, 0xD7, 0x94, 0xBB, 0xA0, 0x9E, 0xDF, 0x90, 0x87, 0xBD,
+    0xD3, 0xF8, 0x4B, 0x86, 0x9E, 0xFF, 0xC5, 0xD7, 0xAF, 0x32, 0x72, 0xC4,
+    0xB8, 0x4D, 0x4C, 0x3E, 0xCD, 0xB1, 0xEE, 0xAE, 0xDD, 0x31, 0x12, 0xC6,
+    0xD8, 0xC8, 0xFA, 0x20, 0x90, 0xB1, 0x83, 0xAA, 0x33, 0x1F, 0x07, 0xA6,
+    0xC1, 0xA1, 0x31, 0x05, 0x3F, 0xE3, 0xA5, 0x4D, 0x41, 0x8B, 0x1C, 0x5B,
+    0x51, 0x10, 0x03, 0x0B, 0x0B, 0x2C, 0x3F, 0x97, 0xC5, 0xA2, 0x38, 0x0D,
+    0xCB, 0xEF, 0x53, 0x45, 0xBE, 0x28, 0x35, 0x6E, 0x02, 0x10, 0xE8, 0x29,
+    0x23, 0xE7, 0xE4, 0xC8, 0x90, 0x99, 0x72, 0xDB, 0xB9, 0x32, 0xB7, 0x87,
+    0x52, 0x85, 0x7C, 0x92, 0x47, 0xAF, 0x71, 0x0B, 0x51, 0xC7, 0x8F, 0x24,
+    0xE4, 0x7C, 0xE2, 0xF3, 0x33, 0x05, 0xFF, 0x92, 0x0C, 0xC0, 0x01, 0xF0,
+    0xF5, 0xEF, 0x52, 0xA1, 0x69, 0xA3, 0x58, 0xFC, 0x48, 0x58, 0x28, 0xBA,
+    0x53, 0xA2, 0x3D, 0x03, 0x89, 0x34, 0x12, 0x78, 0xBC, 0x31, 0x5A, 0x93,
+    0x62, 0x32, 0xE5, 0xE2, 0x10, 0x56, 0xC0, 0xCA, 0xED, 0x1E, 0x2E, 0x6E,
+    0x23, 0x6B, 0xA1, 0x46, 0x6D, 0x7D, 0x58, 0x0B, 0xCC, 0xB0, 0x5B, 0x7B,
+    0xA1, 0x48, 0x89, 0xF6, 0x10, 0xBE, 0x8C, 0x30, 0x10, 0xE6, 0xE1, 0x87,
+    0x3C, 0xD0, 0x27, 0x47, 0x06, 0xAA, 0xB9, 0x73, 0x26, 0xED, 0x7F, 0x38,
+    0xCA, 0xC5, 0xD0, 0x3F, 0x27, 0xEE, 0xA9, 0x5F, 0xF0, 0x31, 0xA9, 0x88,
+    0x26, 0x7D, 0x32, 0x34, 0x13, 0xD1, 0xDC, 0x39, 0x7F, 0xAC, 0x3B, 0xB6,
+    0xC6, 0x97, 0x5E, 0x44, 0xCA, 0x68, 0xA4, 0x84, 0x90, 0xD0, 0x90, 0x6F,
+    0x93, 0xB4, 0xDA, 0x61, 0x43, 0x23, 0xE8, 0x31, 0x34, 0xCD, 0x2F, 0xCA,
+    0xB8, 0x63, 0x5F, 0x59, 0x71, 0xE2, 0x2A, 0x11, 0x4F, 0xD0, 0x12, 0xF6,
+    0x70, 0x5F, 0xEE, 0xA8, 0xB2, 0x98, 0x89, 0x6C, 0xED, 0x76, 0xCD, 0xE3,
+    0x81, 0x1E, 0x5C, 0xEC, 0x7D, 0xB6, 0x21, 0xCE, 0x49, 0x25, 0x7F, 0x97,
+    0x8F, 0x1F, 0xBA, 0x81, 0x0B, 0x9F, 0x58, 0xA9, 0x16, 0x19, 0xA2, 0x56,
+    0x2F, 0x89, 0x59, 0xA6, 0x8D, 0x97, 0x7C, 0xF7, 0x02, 0xB3, 0x39, 0x37,
+    0x4B, 0x79, 0xCF, 0x84, 0x6B, 0xDE, 0x40, 0x6D, 0x1D, 0x17, 0x5E, 0x48,
+    0x62, 0x6C, 0x07, 0xE8, 0xBC, 0x0E, 0xD6, 0xD4, 0xEC, 0xA7, 0x55, 0x16,
+    0x57, 0x05, 0xC2, 0x5B, 0xA8, 0xBB, 0xA1, 0x8B, 0x63, 0x04, 0x63, 0x99,
+    0xC2, 0x11, 0x29, 0xCC, 0x37, 0xC7, 0xB1, 0x70, 0x34, 0x27, 0x1F, 0xD7,
+    0xB4, 0x4D, 0xD6, 0xF3, 0x4A, 0x92, 0xF6, 0xA6, 0xAA, 0x8F, 0xC6, 0xC8,
+    0x6B, 0xE1, 0xFC, 0x97, 0xAF, 0xC9, 0x6F, 0x68, 0xF1, 0x41, 0xA1, 0xB2,
+    0x8C, 0x9E, 0xE2, 0xD7, 0x64, 0xA3, 0xD9, 0x47, 0xBD, 0xBA, 0xFC, 0x84,
+    0x14, 0x6C, 0x4B, 0xCC, 0xE6, 0xB4, 0x93, 0x54, 0x03, 0xA6, 0x14, 0xD5,
+    0xB1, 0xFB, 0xBC, 0x8E, 0x96, 0x88, 0xB4, 0xD6, 0x86, 0xE5, 0xEE, 0x5B,
+    0x1A, 0xA1, 0x7C, 0x43, 0x46, 0x6B, 0x80, 0x2C, 0xAD, 0xDE, 0x4B, 0xA9,
+    0x75, 0xA1, 0x42, 0xC7, 0x0B, 0x72, 0xCF, 0x10, 0xA7, 0x5A, 0xD8, 0x96,
+    0x0D, 0xC1, 0xB2, 0xAB, 0x5D, 0xD2, 0xA5, 0x5E, 0xE6, 0x72, 0xE6, 0x46,
+    0x72, 0x85, 0xAF, 0xC3, 0xD0, 0x09, 0x81, 0xF8, 0x9F, 0xA2, 0xD6, 0x40,
+    0xB4, 0x50, 0x0D, 0x35, 0x6A, 0xEB, 0x9F, 0xC2, 0xF1, 0x41, 0x5A, 0x2B,
+    0x87, 0xE5, 0x1D, 0xA3, 0x36, 0x6F, 0x5A, 0x95, 0x49, 0xD5, 0x67, 0x1E,
+    0xD5, 0x6D, 0xCF, 0x8A, 0xF7, 0xF9, 0x53, 0x9C, 0xCC, 0x7E, 0xD1, 0x3A,
+    0xBD, 0xB9, 0x36, 0xEB, 0x82, 0xC5, 0xB5, 0xAC, 0xE7, 0x60, 0x4B, 0x1F,
+    0x96, 0xF8, 0xF5, 0x6F, 0x4D, 0x11, 0x76, 0xAF, 0xD0, 0x79, 0x86, 0xD7,
+    0xCF, 0x49, 0x61, 0x93, 0x2E, 0xDA, 0xFD, 0x64, 0x4E, 0xB3, 0x27, 0xFA,
+    0x38, 0x91, 0x27, 0xA0, 0x94, 0x35, 0xD6, 0x8E, 0x03, 0x6E, 0xB8, 0x67,
+    0x2B, 0x35, 0x8E, 0x56, 0x49, 0x52, 0xF1, 0x82, 0x9A, 0x6A, 0x9C, 0xE4,
+    0x4E, 0x56, 0xD1, 0x2E, 0xCB, 0xD4, 0x1E, 0x27, 0x69, 0xA9, 0xA4, 0xFE,
+    0xB4, 0x33, 0x0C, 0xCD, 0x7A, 0xA9, 0xC2, 0x60, 0x64, 0xB2, 0x4A, 0x34,
+    0xBF, 0x8F, 0x67, 0x9A, 0x82, 0x1E, 0x03, 0x0B, 0x85, 0x6F, 0xA6, 0xA0,
+    0x2A, 0x7B, 0x27, 0xC6, 0xEA, 0x67, 0x8C, 0xD9, 0xB4, 0x57, 0xAB, 0xBA,
+    0x97, 0x6E, 0x51, 0x94, 0x20, 0x00, 0x8B, 0x0C, 0x2B, 0xF9, 0x9D, 0xEA,
+    0xB6, 0xAC, 0x56, 0x6F, 0xEF, 0x29, 0x6D, 0x15, 0xC5, 0x30, 0xAB, 0x10,
+    0xA7, 0x2F, 0x82, 0x95, 0xAC, 0x78, 0xE1, 0x91, 0x61, 0xE4, 0xA0, 0x40,
+    0x98, 0x84, 0x91, 0xDF, 0xD9, 0x6C, 0x78, 0x2F, 0xC3, 0x37, 0x81, 0xC7,
+    0x4E, 0xE0, 0x74, 0x0A, 0xD9, 0xBB, 0xBE, 0x30, 0x2C, 0x18, 0x14, 0x88,
+    0xAF, 0xDB, 0xD1, 0x56, 0x3C, 0x3D, 0x8E, 0xA7, 0xD8, 0x4E, 0x4C, 0xFE,
+    0x29, 0x59, 0x44, 0x0B, 0x39, 0x90, 0x3C, 0x7A, 0xE2, 0xDE, 0x74, 0xB3,
+    0xAD, 0xFC, 0xBD, 0x69, 0xAD, 0x23, 0x85, 0x61, 0x49, 0x36, 0x88, 0x26,
+    0xED, 0x3A, 0x5A, 0xB0, 0x68, 0x11, 0x34, 0x5A, 0x91, 0xD1, 0x6F, 0x88,
+    0xDE, 0x9A, 0x11, 0x43, 0xCD, 0x26, 0xDB, 0x14, 0x80, 0x17, 0xF7, 0xFD,
+    0x78, 0x87, 0xA5, 0x14, 0x5A, 0x59, 0x2C, 0x45, 0x54, 0xE7, 0x6D, 0x30,
+    0x77, 0x06, 0x2F, 0xF9, 0xD4, 0xDB, 0xCC, 0xDE, 0x60, 0x82, 0x45, 0x14,
+    0x19, 0xB7, 0x38, 0x22, 0xDA, 0xC1, 0x6E, 0x51, 0xA4, 0xD6, 0xD1, 0xBF,
+    0x6F, 0xA0, 0x47, 0x95, 0x0C, 0x76, 0x50, 0xBA, 0x07, 0xF4, 0xC4, 0x4A,
+    0xD0, 0x43, 0x86, 0x3E, 0x40, 0x1B, 0xFB, 0xCB, 0xB4, 0x56, 0x83, 0xD5,
+    0xD1, 0xEE, 0x24, 0xB7, 0xB5, 0x40, 0x78, 0x0B, 0xA0, 0x9E, 0x4B, 0x83,
+    0xBE, 0x0C, 0x26, 0x76, 0xBF, 0x5E, 0xF2, 0xE9, 0x1B, 0x1D, 0x29, 0x70,
+    0x62, 0x38, 0x97, 0xD2, 0xC5, 0x37, 0xFA, 0xE8, 0xF1, 0xE6, 0x79, 0xC2,
+    0x20, 0x1C, 0xC7, 0x27, 0x65, 0xA6, 0xD1, 0x7F, 0xE7, 0x7B, 0x28, 0x84,
+    0x0A, 0x29, 0x28, 0x6B, 0xD2, 0xDD, 0x1B, 0xF9, 0x12, 0xDE, 0xFC, 0xA9,
+    0x09, 0x61, 0xD9, 0xF6, 0x63, 0x7C, 0x8A, 0x00, 0xD8, 0x73, 0xA7, 0x98,
+    0xD8, 0xB2, 0xB4, 0x80, 0x98, 0xCA, 0x7D, 0x40, 0xC6, 0x4E, 0x51, 0x41,
+    0x84, 0x25, 0x57, 0xD6, 0xED, 0x67, 0x4A, 0x76, 0xC3, 0xFA, 0x4D, 0x37,
+    0xA5, 0x4E, 0xCF, 0x19, 0x38, 0xDA, 0x34, 0x02, 0x5D, 0xD9, 0x66, 0xA9,
+    0xDF, 0x78, 0xE1, 0x4F, 0xD7, 0xB1, 0x37, 0xC6, 0x60, 0x94, 0x09, 0xD3,
+    0xE6, 0xC4, 0xDA, 0x03, 0x84, 0xE6, 0x6F, 0xAB, 0x26, 0xBA, 0xDF, 0xF4,
+    0x23, 0xD2, 0x00, 0xCE, 0x85, 0x6E, 0x8C, 0xE9, 0x17, 0xB2, 0x8D, 0x81,
+    0x32, 0x01, 0xCC, 0x21, 0xE9, 0x47, 0x43, 0x6F, 0x47, 0xF4, 0x5B, 0x6F,
+    0x2B, 0x31, 0xE5, 0x4A, 0x0B, 0xF2, 0x77, 0x28, 0x0A, 0xAC, 0xAF, 0x7A,
+    0xF0, 0xF0, 0x33, 0x59, 0xBB, 0xCC, 0xB9, 0xF8, 0x08, 0x94, 0x3D, 0x25,
+    0x4E, 0x0C, 0x92, 0x68, 0xDE, 0x7F, 0x82, 0x15, 0xBB, 0x42, 0xF2, 0x94,
+    0x8C, 0xE0, 0x72, 0x90, 0x9E, 0x58, 0xF0, 0x6E, 0x29, 0x1E, 0xAD, 0xFC,
+    0x35, 0x87, 0xD9, 0x88, 0xDD, 0xA6, 0xFE, 0xAF, 0x3B, 0x2E, 0xD9, 0x0C,
+    0x9B, 0x0A, 0x91, 0xE6, 0x0E, 0xD4, 0xD0, 0xFF, 0xD9, 0x64, 0x7E, 0xCF,
+    0xF9, 0x7D, 0x10, 0x10, 0x16, 0x5D, 0xE2, 0x9F, 0xD4, 0x54, 0x47, 0xC1,
+    0xCF, 0xF1, 0x6D, 0xED, 0x42, 0xCB, 0x1B, 0xA1, 0x87, 0xED, 0xB1, 0x15,
+    0xD2,
+};
+
+static const uint8_t kPublicKeySPKI[] = {
+    0x30, 0x82, 0x07, 0xb4, 0x30, 0x0d, 0x06, 0x0b, 0x2b, 0x06, 0x01, 0x04,
+    0x01, 0x02, 0x82, 0x0b, 0x07, 0x06, 0x05, 0x03, 0x82, 0x07, 0xa1, 0x00,
+    0xbb, 0x0a, 0x41, 0x1a, 0x53, 0x91, 0x4e, 0x67, 0x77, 0x78, 0xd0, 0xbc,
+    0xf0, 0xfd, 0x8a, 0x39, 0x65, 0x96, 0x48, 0x54, 0xf5, 0x91, 0xce, 0xdb,
+    0x3b, 0x92, 0xbf, 0x2a, 0xc4, 0x01, 0xcd, 0xbe, 0x9e, 0x60, 0x05, 0x45,
+    0x68, 0x3e, 0xc0, 0xc6, 0xdc, 0xbb, 0x76, 0x42, 0x2d, 0x91, 0x47, 0xc2,
+    0x7c, 0x96, 0xaa, 0x5b, 0x28, 0x0d, 0x3b, 0x24, 0x50, 0x12, 0x4e, 0x05,
+    0x0f, 0xbd, 0x09, 0xb5, 0x51, 0xf5, 0xd6, 0x12, 0x93, 0xf8, 0x62, 0x69,
+    0x92, 0x25, 0x3b, 0x2e, 0x1b, 0xc8, 0x47, 0xfa, 0x06, 0x2c, 0x21, 0x8a,
+    0x62, 0xa2, 0x0a, 0x3f, 0x1b, 0xd3, 0x6d, 0x2d, 0x82, 0x4d, 0x7d, 0xde,
+    0x80, 0xbb, 0x08, 0x79, 0x53, 0xd8, 0xdb, 0xcd, 0x73, 0xf8, 0x8f, 0x85,
+    0xa8, 0xb4, 0xb5, 0x63, 0xf5, 0x6a, 0x9c, 0xd5, 0x58, 0xac, 0xd7, 0x9c,
+    0x96, 0x3c, 0xea, 0x5a, 0x66, 0x69, 0xd6, 0x5e, 0xc3, 0xd5, 0x81, 0xfe,
+    0x6b, 0x42, 0xa0, 0xb6, 0x58, 0x54, 0xfa, 0x2f, 0xbe, 0x92, 0x9a, 0x41,
+    0xf8, 0x32, 0x10, 0x10, 0x86, 0x77, 0x01, 0xd6, 0xef, 0x81, 0x14, 0x1b,
+    0xa3, 0x8b, 0xf4, 0x33, 0x94, 0x4e, 0x85, 0xdc, 0x94, 0x7c, 0x01, 0x9e,
+    0x6d, 0x9e, 0x7a, 0x26, 0x0f, 0xcf, 0xa0, 0x7d, 0x92, 0xb0, 0x84, 0x95,
+    0x76, 0xdf, 0x40, 0x85, 0x87, 0xef, 0xf5, 0x33, 0x52, 0x2e, 0xf6, 0x73,
+    0x9e, 0xda, 0x27, 0x6c, 0xee, 0x08, 0xfe, 0x7a, 0x67, 0x43, 0x88, 0xc6,
+    0xf0, 0xf1, 0x0c, 0x08, 0xa5, 0x67, 0xc4, 0xb0, 0x01, 0xfb, 0x5b, 0x59,
+    0xfc, 0xae, 0xcf, 0x07, 0x14, 0x52, 0x45, 0xd0, 0xeb, 0x97, 0xab, 0x0e,
+    0x52, 0x65, 0x12, 0x41, 0xa2, 0x03, 0xb1, 0xe5, 0x1e, 0xa6, 0x33, 0xce,
+    0x9a, 0x5c, 0x8f, 0xdf, 0x1a, 0x42, 0x6c, 0xb6, 0xcb, 0x78, 0xdd, 0x02,
+    0x78, 0xd9, 0xd8, 0xae, 0x31, 0x5f, 0x13, 0xeb, 0x71, 0xd3, 0xad, 0x6b,
+    0xd0, 0x98, 0x18, 0x7a, 0x5b, 0x0d, 0xa9, 0x5d, 0x35, 0xb4, 0x26, 0x5e,
+    0xca, 0xf6, 0x7d, 0xc3, 0x9f, 0xe1, 0xbd, 0xfb, 0x73, 0xa6, 0xf1, 0xe0,
+    0x26, 0x0f, 0xca, 0x1b, 0xc3, 0xa9, 0xd0, 0x27, 0x46, 0x82, 0x49, 0x73,
+    0xed, 0x3a, 0x6b, 0x61, 0x05, 0xd8, 0xa7, 0x7f, 0x2b, 0x36, 0x1c, 0x69,
+    0x31, 0x73, 0x29, 0xde, 0x6d, 0x28, 0xb6, 0xea, 0xfe, 0x37, 0xc2, 0xc0,
+    0x94, 0x4b, 0x3e, 0xd4, 0x21, 0x3f, 0xe0, 0x02, 0xfa, 0x5f, 0x16, 0xce,
+    0x16, 0x66, 0xb5, 0xc9, 0xf6, 0x3f, 0x2a, 0x5c, 0x83, 0x00, 0x5f, 0xda,
+    0x0b, 0x6e, 0xe7, 0xb6, 0x55, 0x55, 0xbf, 0x50, 0x29, 0x8e, 0x39, 0xa2,
+    0xb7, 0x85, 0x79, 0xc3, 0xce, 0x93, 0x63, 0x57, 0xd1, 0xf2, 0x03, 0x6e,
+    0x42, 0x78, 0xb3, 0x5f, 0x72, 0x5c, 0x7d, 0xb0, 0xe0, 0x55, 0x96, 0xe1,
+    0x34, 0x0b, 0x5c, 0x75, 0xa9, 0xef, 0x17, 0x47, 0x5b, 0xdc, 0x4f, 0x01,
+    0x5d, 0x80, 0x60, 0x14, 0xa7, 0x9a, 0xd3, 0x38, 0x07, 0xda, 0x61, 0x0d,
+    0x7f, 0x37, 0xec, 0x0a, 0xd3, 0x54, 0x91, 0x53, 0x16, 0x3d, 0xad, 0xc8,
+    0x2c, 0xac, 0xbb, 0x1b, 0x03, 0xd7, 0x96, 0x8d, 0x6d, 0x2d, 0x81, 0xbb,
+    0x57, 0xdb, 0x10, 0x3e, 0xfd, 0xcf, 0xa9, 0xa3, 0xa4, 0xaf, 0xf7, 0xa1,
+    0x9f, 0x4b, 0xb0, 0x3e, 0x3d, 0x51, 0x15, 0xea, 0x63, 0x8c, 0x75, 0x59,
+    0x78, 0xbb, 0xec, 0x94, 0x47, 0xa8, 0x81, 0x7b, 0x98, 0xf1, 0x6e, 0x0a,
+    0xad, 0xe6, 0x42, 0x58, 0x37, 0x76, 0x8e, 0x06, 0xa5, 0x43, 0xbf, 0xe9,
+    0xfa, 0x53, 0x2e, 0xac, 0x2e, 0xbc, 0x6a, 0x99, 0x08, 0x51, 0x98, 0xac,
+    0x3a, 0x23, 0x52, 0x19, 0x07, 0x81, 0x14, 0x4c, 0x62, 0x3f, 0x38, 0x2c,
+    0xb6, 0x70, 0x33, 0xd8, 0xb3, 0x97, 0x5b, 0x9c, 0x54, 0x62, 0x63, 0x03,
+    0xa8, 0xad, 0xc1, 0xb3, 0xc6, 0x3a, 0x74, 0x5d, 0x6e, 0x9c, 0x3f, 0xce,
+    0xe8, 0x79, 0xf4, 0x02, 0x90, 0x3a, 0x2b, 0x51, 0x50, 0x9f, 0x88, 0xf5,
+    0x98, 0xa7, 0xc4, 0xd2, 0xe9, 0x4f, 0xca, 0x52, 0xe9, 0xe1, 0xb2, 0xb3,
+    0x78, 0xb0, 0xa2, 0x33, 0x9f, 0xa8, 0xc3, 0xd9, 0xb6, 0xdd, 0x6a, 0x05,
+    0x5b, 0xc7, 0x52, 0xc3, 0x68, 0xc2, 0x30, 0x7f, 0x74, 0x1e, 0x07, 0x66,
+    0xc3, 0xa4, 0x2d, 0x84, 0xaa, 0x17, 0xd6, 0x49, 0x89, 0x60, 0x31, 0x0e,
+    0x4e, 0xae, 0xcf, 0x56, 0x93, 0x40, 0x3c, 0x9b, 0xc9, 0x13, 0x5c, 0x5d,
+    0x38, 0x94, 0xae, 0x6f, 0xe9, 0x04, 0xb7, 0xa6, 0x1e, 0xab, 0xb9, 0xd4,
+    0x04, 0xff, 0x3c, 0x99, 0x2f, 0xe4, 0x80, 0x69, 0xdb, 0x50, 0x5b, 0xac,
+    0x34, 0x48, 0x77, 0xf6, 0xb2, 0x00, 0x02, 0x8d, 0x75, 0xa0, 0x2e, 0x93,
+    0x0a, 0x20, 0x22, 0x2f, 0x73, 0x15, 0xea, 0xea, 0xbd, 0x8b, 0xe6, 0x85,
+    0xfd, 0x30, 0x97, 0xf7, 0x24, 0xb9, 0xd5, 0x30, 0xa0, 0x7a, 0x36, 0x0e,
+    0xa4, 0xe1, 0xea, 0xfd, 0xe6, 0xdd, 0xb6, 0xff, 0xc6, 0xfc, 0x20, 0xd6,
+    0x71, 0x36, 0x1b, 0x5d, 0xf2, 0x63, 0xca, 0xc6, 0xde, 0x55, 0xf2, 0x39,
+    0x05, 0x9a, 0x88, 0x0c, 0x7c, 0xac, 0x5c, 0xc0, 0x50, 0x05, 0x1f, 0xde,
+    0xbb, 0x6e, 0xf2, 0x06, 0x77, 0x9a, 0xc7, 0x03, 0x14, 0x26, 0xd4, 0x5d,
+    0xe0, 0xa9, 0x02, 0xc6, 0xa1, 0xca, 0x4b, 0x8d, 0xac, 0x0b, 0x54, 0xc1,
+    0xf7, 0x91, 0xbf, 0xd0, 0xe6, 0xee, 0x4b, 0x21, 0x82, 0xe2, 0x33, 0xd2,
+    0xb4, 0xc0, 0x14, 0x64, 0xc8, 0x6b, 0xd0, 0x50, 0xe5, 0x4a, 0x84, 0xf2,
+    0x25, 0x23, 0x2e, 0xd2, 0x65, 0x3b, 0x4a, 0x72, 0x03, 0xaa, 0x0c, 0x82,
+    0x98, 0x14, 0x11, 0x8e, 0x4a, 0x1f, 0x77, 0xe1, 0x82, 0xbe, 0xb4, 0x5c,
+    0xe4, 0x7a, 0x74, 0xfe, 0x29, 0x42, 0xcd, 0x9d, 0xed, 0x40, 0xc8, 0x88,
+    0x85, 0xfa, 0x98, 0xba, 0xbc, 0x45, 0xc7, 0xce, 0x5b, 0xb8, 0x36, 0x1b,
+    0x2a, 0x69, 0x55, 0xf5, 0x98, 0xcf, 0xd7, 0x4e, 0x7f, 0x2f, 0x59, 0x4d,
+    0x26, 0x33, 0x54, 0xd2, 0x5f, 0x51, 0xfd, 0xd2, 0xb9, 0xbb, 0xe0, 0x99,
+    0x5a, 0xdd, 0xd0, 0x11, 0xea, 0xfc, 0x84, 0xd2, 0x21, 0x06, 0x26, 0xea,
+    0x2e, 0xba, 0x52, 0xeb, 0x39, 0xf0, 0x97, 0x5b, 0xcc, 0x76, 0xaf, 0x87,
+    0x94, 0x9f, 0xb0, 0xa0, 0xd1, 0x59, 0x9f, 0x73, 0x83, 0x69, 0x50, 0x76,
+    0x03, 0x0d, 0x44, 0x13, 0xe1, 0x2b, 0x31, 0xf9, 0xf4, 0xe2, 0x6d, 0xcd,
+    0x31, 0xbf, 0x39, 0xfc, 0x61, 0xa1, 0x40, 0x52, 0x56, 0xf5, 0xd7, 0x12,
+    0x12, 0xab, 0x5e, 0x81, 0x48, 0x8a, 0x2e, 0xe8, 0x85, 0xdc, 0xe7, 0x65,
+    0x16, 0x6b, 0xbe, 0x28, 0x93, 0x95, 0x0b, 0x0e, 0x20, 0xfe, 0x4f, 0xf7,
+    0xeb, 0x0e, 0xef, 0x2d, 0x41, 0x0c, 0x24, 0x0c, 0x3f, 0xa6, 0x62, 0x61,
+    0xb3, 0x7a, 0x5e, 0x9a, 0xef, 0xf6, 0xae, 0x93, 0x51, 0xd5, 0xd7, 0x94,
+    0xbb, 0xa0, 0x9e, 0xdf, 0x90, 0x87, 0xbd, 0xd3, 0xf8, 0x4b, 0x86, 0x9e,
+    0xff, 0xc5, 0xd7, 0xaf, 0x32, 0x72, 0xc4, 0xb8, 0x4d, 0x4c, 0x3e, 0xcd,
+    0xb1, 0xee, 0xae, 0xdd, 0x31, 0x12, 0xc6, 0xd8, 0xc8, 0xfa, 0x20, 0x90,
+    0xb1, 0x83, 0xaa, 0x33, 0x1f, 0x07, 0xa6, 0xc1, 0xa1, 0x31, 0x05, 0x3f,
+    0xe3, 0xa5, 0x4d, 0x41, 0x8b, 0x1c, 0x5b, 0x51, 0x10, 0x03, 0x0b, 0x0b,
+    0x2c, 0x3f, 0x97, 0xc5, 0xa2, 0x38, 0x0d, 0xcb, 0xef, 0x53, 0x45, 0xbe,
+    0x28, 0x35, 0x6e, 0x02, 0x10, 0xe8, 0x29, 0x23, 0xe7, 0xe4, 0xc8, 0x90,
+    0x99, 0x72, 0xdb, 0xb9, 0x32, 0xb7, 0x87, 0x52, 0x85, 0x7c, 0x92, 0x47,
+    0xaf, 0x71, 0x0b, 0x51, 0xc7, 0x8f, 0x24, 0xe4, 0x7c, 0xe2, 0xf3, 0x33,
+    0x05, 0xff, 0x92, 0x0c, 0xc0, 0x01, 0xf0, 0xf5, 0xef, 0x52, 0xa1, 0x69,
+    0xa3, 0x58, 0xfc, 0x48, 0x58, 0x28, 0xba, 0x53, 0xa2, 0x3d, 0x03, 0x89,
+    0x34, 0x12, 0x78, 0xbc, 0x31, 0x5a, 0x93, 0x62, 0x32, 0xe5, 0xe2, 0x10,
+    0x56, 0xc0, 0xca, 0xed, 0x1e, 0x2e, 0x6e, 0x23, 0x6b, 0xa1, 0x46, 0x6d,
+    0x7d, 0x58, 0x0b, 0xcc, 0xb0, 0x5b, 0x7b, 0xa1, 0x48, 0x89, 0xf6, 0x10,
+    0xbe, 0x8c, 0x30, 0x10, 0xe6, 0xe1, 0x87, 0x3c, 0xd0, 0x27, 0x47, 0x06,
+    0xaa, 0xb9, 0x73, 0x26, 0xed, 0x7f, 0x38, 0xca, 0xc5, 0xd0, 0x3f, 0x27,
+    0xee, 0xa9, 0x5f, 0xf0, 0x31, 0xa9, 0x88, 0x26, 0x7d, 0x32, 0x34, 0x13,
+    0xd1, 0xdc, 0x39, 0x7f, 0xac, 0x3b, 0xb6, 0xc6, 0x97, 0x5e, 0x44, 0xca,
+    0x68, 0xa4, 0x84, 0x90, 0xd0, 0x90, 0x6f, 0x93, 0xb4, 0xda, 0x61, 0x43,
+    0x23, 0xe8, 0x31, 0x34, 0xcd, 0x2f, 0xca, 0xb8, 0x63, 0x5f, 0x59, 0x71,
+    0xe2, 0x2a, 0x11, 0x4f, 0xd0, 0x12, 0xf6, 0x70, 0x5f, 0xee, 0xa8, 0xb2,
+    0x98, 0x89, 0x6c, 0xed, 0x76, 0xcd, 0xe3, 0x81, 0x1e, 0x5c, 0xec, 0x7d,
+    0xb6, 0x21, 0xce, 0x49, 0x25, 0x7f, 0x97, 0x8f, 0x1f, 0xba, 0x81, 0x0b,
+    0x9f, 0x58, 0xa9, 0x16, 0x19, 0xa2, 0x56, 0x2f, 0x89, 0x59, 0xa6, 0x8d,
+    0x97, 0x7c, 0xf7, 0x02, 0xb3, 0x39, 0x37, 0x4b, 0x79, 0xcf, 0x84, 0x6b,
+    0xde, 0x40, 0x6d, 0x1d, 0x17, 0x5e, 0x48, 0x62, 0x6c, 0x07, 0xe8, 0xbc,
+    0x0e, 0xd6, 0xd4, 0xec, 0xa7, 0x55, 0x16, 0x57, 0x05, 0xc2, 0x5b, 0xa8,
+    0xbb, 0xa1, 0x8b, 0x63, 0x04, 0x63, 0x99, 0xc2, 0x11, 0x29, 0xcc, 0x37,
+    0xc7, 0xb1, 0x70, 0x34, 0x27, 0x1f, 0xd7, 0xb4, 0x4d, 0xd6, 0xf3, 0x4a,
+    0x92, 0xf6, 0xa6, 0xaa, 0x8f, 0xc6, 0xc8, 0x6b, 0xe1, 0xfc, 0x97, 0xaf,
+    0xc9, 0x6f, 0x68, 0xf1, 0x41, 0xa1, 0xb2, 0x8c, 0x9e, 0xe2, 0xd7, 0x64,
+    0xa3, 0xd9, 0x47, 0xbd, 0xba, 0xfc, 0x84, 0x14, 0x6c, 0x4b, 0xcc, 0xe6,
+    0xb4, 0x93, 0x54, 0x03, 0xa6, 0x14, 0xd5, 0xb1, 0xfb, 0xbc, 0x8e, 0x96,
+    0x88, 0xb4, 0xd6, 0x86, 0xe5, 0xee, 0x5b, 0x1a, 0xa1, 0x7c, 0x43, 0x46,
+    0x6b, 0x80, 0x2c, 0xad, 0xde, 0x4b, 0xa9, 0x75, 0xa1, 0x42, 0xc7, 0x0b,
+    0x72, 0xcf, 0x10, 0xa7, 0x5a, 0xd8, 0x96, 0x0d, 0xc1, 0xb2, 0xab, 0x5d,
+    0xd2, 0xa5, 0x5e, 0xe6, 0x72, 0xe6, 0x46, 0x72, 0x85, 0xaf, 0xc3, 0xd0,
+    0x09, 0x81, 0xf8, 0x9f, 0xa2, 0xd6, 0x40, 0xb4, 0x50, 0x0d, 0x35, 0x6a,
+    0xeb, 0x9f, 0xc2, 0xf1, 0x41, 0x5a, 0x2b, 0x87, 0xe5, 0x1d, 0xa3, 0x36,
+    0x6f, 0x5a, 0x95, 0x49, 0xd5, 0x67, 0x1e, 0xd5, 0x6d, 0xcf, 0x8a, 0xf7,
+    0xf9, 0x53, 0x9c, 0xcc, 0x7e, 0xd1, 0x3a, 0xbd, 0xb9, 0x36, 0xeb, 0x82,
+    0xc5, 0xb5, 0xac, 0xe7, 0x60, 0x4b, 0x1f, 0x96, 0xf8, 0xf5, 0x6f, 0x4d,
+    0x11, 0x76, 0xaf, 0xd0, 0x79, 0x86, 0xd7, 0xcf, 0x49, 0x61, 0x93, 0x2e,
+    0xda, 0xfd, 0x64, 0x4e, 0xb3, 0x27, 0xfa, 0x38, 0x91, 0x27, 0xa0, 0x94,
+    0x35, 0xd6, 0x8e, 0x03, 0x6e, 0xb8, 0x67, 0x2b, 0x35, 0x8e, 0x56, 0x49,
+    0x52, 0xf1, 0x82, 0x9a, 0x6a, 0x9c, 0xe4, 0x4e, 0x56, 0xd1, 0x2e, 0xcb,
+    0xd4, 0x1e, 0x27, 0x69, 0xa9, 0xa4, 0xfe, 0xb4, 0x33, 0x0c, 0xcd, 0x7a,
+    0xa9, 0xc2, 0x60, 0x64, 0xb2, 0x4a, 0x34, 0xbf, 0x8f, 0x67, 0x9a, 0x82,
+    0x1e, 0x03, 0x0b, 0x85, 0x6f, 0xa6, 0xa0, 0x2a, 0x7b, 0x27, 0xc6, 0xea,
+    0x67, 0x8c, 0xd9, 0xb4, 0x57, 0xab, 0xba, 0x97, 0x6e, 0x51, 0x94, 0x20,
+    0x00, 0x8b, 0x0c, 0x2b, 0xf9, 0x9d, 0xea, 0xb6, 0xac, 0x56, 0x6f, 0xef,
+    0x29, 0x6d, 0x15, 0xc5, 0x30, 0xab, 0x10, 0xa7, 0x2f, 0x82, 0x95, 0xac,
+    0x78, 0xe1, 0x91, 0x61, 0xe4, 0xa0, 0x40, 0x98, 0x84, 0x91, 0xdf, 0xd9,
+    0x6c, 0x78, 0x2f, 0xc3, 0x37, 0x81, 0xc7, 0x4e, 0xe0, 0x74, 0x0a, 0xd9,
+    0xbb, 0xbe, 0x30, 0x2c, 0x18, 0x14, 0x88, 0xaf, 0xdb, 0xd1, 0x56, 0x3c,
+    0x3d, 0x8e, 0xa7, 0xd8, 0x4e, 0x4c, 0xfe, 0x29, 0x59, 0x44, 0x0b, 0x39,
+    0x90, 0x3c, 0x7a, 0xe2, 0xde, 0x74, 0xb3, 0xad, 0xfc, 0xbd, 0x69, 0xad,
+    0x23, 0x85, 0x61, 0x49, 0x36, 0x88, 0x26, 0xed, 0x3a, 0x5a, 0xb0, 0x68,
+    0x11, 0x34, 0x5a, 0x91, 0xd1, 0x6f, 0x88, 0xde, 0x9a, 0x11, 0x43, 0xcd,
+    0x26, 0xdb, 0x14, 0x80, 0x17, 0xf7, 0xfd, 0x78, 0x87, 0xa5, 0x14, 0x5a,
+    0x59, 0x2c, 0x45, 0x54, 0xe7, 0x6d, 0x30, 0x77, 0x06, 0x2f, 0xf9, 0xd4,
+    0xdb, 0xcc, 0xde, 0x60, 0x82, 0x45, 0x14, 0x19, 0xb7, 0x38, 0x22, 0xda,
+    0xc1, 0x6e, 0x51, 0xa4, 0xd6, 0xd1, 0xbf, 0x6f, 0xa0, 0x47, 0x95, 0x0c,
+    0x76, 0x50, 0xba, 0x07, 0xf4, 0xc4, 0x4a, 0xd0, 0x43, 0x86, 0x3e, 0x40,
+    0x1b, 0xfb, 0xcb, 0xb4, 0x56, 0x83, 0xd5, 0xd1, 0xee, 0x24, 0xb7, 0xb5,
+    0x40, 0x78, 0x0b, 0xa0, 0x9e, 0x4b, 0x83, 0xbe, 0x0c, 0x26, 0x76, 0xbf,
+    0x5e, 0xf2, 0xe9, 0x1b, 0x1d, 0x29, 0x70, 0x62, 0x38, 0x97, 0xd2, 0xc5,
+    0x37, 0xfa, 0xe8, 0xf1, 0xe6, 0x79, 0xc2, 0x20, 0x1c, 0xc7, 0x27, 0x65,
+    0xa6, 0xd1, 0x7f, 0xe7, 0x7b, 0x28, 0x84, 0x0a, 0x29, 0x28, 0x6b, 0xd2,
+    0xdd, 0x1b, 0xf9, 0x12, 0xde, 0xfc, 0xa9, 0x09, 0x61, 0xd9, 0xf6, 0x63,
+    0x7c, 0x8a, 0x00, 0xd8, 0x73, 0xa7, 0x98, 0xd8, 0xb2, 0xb4, 0x80, 0x98,
+    0xca, 0x7d, 0x40, 0xc6, 0x4e, 0x51, 0x41, 0x84, 0x25, 0x57, 0xd6, 0xed,
+    0x67, 0x4a, 0x76, 0xc3, 0xfa, 0x4d, 0x37, 0xa5, 0x4e, 0xcf, 0x19, 0x38,
+    0xda, 0x34, 0x02, 0x5d, 0xd9, 0x66, 0xa9, 0xdf, 0x78, 0xe1, 0x4f, 0xd7,
+    0xb1, 0x37, 0xc6, 0x60, 0x94, 0x09, 0xd3, 0xe6, 0xc4, 0xda, 0x03, 0x84,
+    0xe6, 0x6f, 0xab, 0x26, 0xba, 0xdf, 0xf4, 0x23, 0xd2, 0x00, 0xce, 0x85,
+    0x6e, 0x8c, 0xe9, 0x17, 0xb2, 0x8d, 0x81, 0x32, 0x01, 0xcc, 0x21, 0xe9,
+    0x47, 0x43, 0x6f, 0x47, 0xf4, 0x5b, 0x6f, 0x2b, 0x31, 0xe5, 0x4a, 0x0b,
+    0xf2, 0x77, 0x28, 0x0a, 0xac, 0xaf, 0x7a, 0xf0, 0xf0, 0x33, 0x59, 0xbb,
+    0xcc, 0xb9, 0xf8, 0x08, 0x94, 0x3d, 0x25, 0x4e, 0x0c, 0x92, 0x68, 0xde,
+    0x7f, 0x82, 0x15, 0xbb, 0x42, 0xf2, 0x94, 0x8c, 0xe0, 0x72, 0x90, 0x9e,
+    0x58, 0xf0, 0x6e, 0x29, 0x1e, 0xad, 0xfc, 0x35, 0x87, 0xd9, 0x88, 0xdd,
+    0xa6, 0xfe, 0xaf, 0x3b, 0x2e, 0xd9, 0x0c, 0x9b, 0x0a, 0x91, 0xe6, 0x0e,
+    0xd4, 0xd0, 0xff, 0xd9, 0x64, 0x7e, 0xcf, 0xf9, 0x7d, 0x10, 0x10, 0x16,
+    0x5d, 0xe2, 0x9f, 0xd4, 0x54, 0x47, 0xc1, 0xcf, 0xf1, 0x6d, 0xed, 0x42,
+    0xcb, 0x1b, 0xa1, 0x87, 0xed, 0xb1, 0x15, 0xd2,
+};
+
+TEST(Dilithium3Test, KeyGeneration) {
+  // Basic key generation tests for Dilithium3
+  // Generate a Dilithium3 key
+  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx, nullptr);
+
+  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
+  ASSERT_NE(dilithium_pkey->pkey.ptr, nullptr);
+
+  const DILITHIUM3_KEY *dilithium3Key = (DILITHIUM3_KEY *)(dilithium_pkey->pkey.ptr);
+  EXPECT_TRUE(dilithium3Key->has_private);
+
+  // Extract public key and check it is of the correct size
+  uint8_t *buf = nullptr;
+  size_t buf_size;
+  EXPECT_TRUE(EVP_PKEY_get_raw_public_key(dilithium_pkey, buf, &buf_size));
+  EXPECT_EQ((size_t)DILITHIUM3_PUBLIC_KEY_BYTES, buf_size);
+
+  buf = (uint8_t *)OPENSSL_malloc(buf_size);
+  ASSERT_NE(buf, nullptr);
+  EXPECT_TRUE(EVP_PKEY_get_raw_public_key(dilithium_pkey, buf, &buf_size));
+
+  buf_size = 0;
+  EXPECT_FALSE(EVP_PKEY_get_raw_public_key(dilithium_pkey, buf, &buf_size));
+
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_BUFFER_TOO_SMALL, ERR_GET_REASON(err));
+  OPENSSL_free(buf);
+  buf = nullptr;
+
+  // Extract private key and check it is of the correct size
+  EXPECT_TRUE(EVP_PKEY_get_raw_private_key(dilithium_pkey, buf, &buf_size));
+  EXPECT_EQ((size_t)DILITHIUM3_PRIVATE_KEY_BYTES, buf_size);
+
+  buf = (uint8_t *)OPENSSL_malloc(buf_size);
+  ASSERT_NE(buf, nullptr);
+  EXPECT_TRUE(EVP_PKEY_get_raw_private_key(dilithium_pkey, buf, &buf_size));
+
+  buf_size = 0;
+  EXPECT_FALSE(EVP_PKEY_get_raw_private_key(dilithium_pkey, buf, &buf_size));
+  err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_BUFFER_TOO_SMALL, ERR_GET_REASON(err));
+  OPENSSL_free(buf);
+
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
+  EVP_PKEY_free(dilithium_pkey);
+}
+
+TEST(Dilithium3Test, KeyComparison) {
+  // Generate two Dilithium3 keys are check that they are not equal.
+  EVP_PKEY_CTX *dilithium_pkey_ctx1 = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx1, nullptr);
+
+  EVP_PKEY *dilithium_pkey1 = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey1, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx1));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx1, &dilithium_pkey1));
+  ASSERT_NE(dilithium_pkey1->pkey.ptr, nullptr);
+
+  EVP_PKEY_CTX *dilithium_pkey_ctx2 = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx2, nullptr);
+
+  EVP_PKEY *dilithium_pkey2 = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey2, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx2));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx2, &dilithium_pkey2));
+  ASSERT_NE(dilithium_pkey2->pkey.ptr, nullptr);
+
+  EXPECT_EQ(0, EVP_PKEY_cmp(dilithium_pkey1, dilithium_pkey2));
+
+  EVP_PKEY_free(dilithium_pkey1);
+  EVP_PKEY_free(dilithium_pkey2);
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx1);
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx2);
+}
+
+TEST(Dilithium3Test, NewKeyFromBytes) {
+  // Test the generation of a Dilithium3 key from bytes
+  // Source key
+  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx, nullptr);
+
+  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
+  ASSERT_NE(dilithium_pkey->pkey.ptr, nullptr);
+  const DILITHIUM3_KEY *dilithium3Key = (DILITHIUM3_KEY *)(dilithium_pkey->pkey.ptr);
+
+  // New raw public key
+  EVP_PKEY *new_public = EVP_PKEY_new_raw_public_key(EVP_PKEY_DILITHIUM3,
+                                                     NULL,
+                                                     dilithium3Key->pub,
+                                                     DILITHIUM3_PUBLIC_KEY_BYTES);
+  ASSERT_NE(new_public, nullptr);
+
+  uint8_t *buf = nullptr;
+  size_t buf_size;
+  EXPECT_FALSE(EVP_PKEY_get_raw_private_key(new_public, buf, &buf_size));
+  uint32_t err = ERR_get_error();
+  EXPECT_EQ(ERR_LIB_EVP, ERR_GET_LIB(err));
+  EXPECT_EQ(EVP_R_NOT_A_PRIVATE_KEY, ERR_GET_REASON(err));
+
+  // EVP_PKEY_cmp just compares the public keys so this should return 1
+  EXPECT_EQ(1, EVP_PKEY_cmp(dilithium_pkey, new_public));
+
+  // New raw private key
+  EVP_PKEY *new_private = EVP_PKEY_new_raw_private_key(EVP_PKEY_DILITHIUM3,
+                                                       NULL,
+                                                       dilithium3Key->priv,
+                                                       DILITHIUM3_PRIVATE_KEY_BYTES);
+  ASSERT_NE(new_private, nullptr);
+  const DILITHIUM3_KEY *newDilithium3Key = (DILITHIUM3_KEY *)(new_private->pkey.ptr);
+  EXPECT_EQ(0, OPENSSL_memcmp(dilithium3Key->priv, newDilithium3Key->priv,
+                              DILITHIUM3_PRIVATE_KEY_BYTES));
+
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
+  EVP_PKEY_free(new_public);
+  EVP_PKEY_free(new_private);
+  EVP_PKEY_free(dilithium_pkey);
+}
+
+TEST(Dilithium3Test, KeySize) {
+  // Test the key size of Dilithium3 key is as expected
+  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx, nullptr);
+
+  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
+
+  EXPECT_EQ(DILITHIUM3_SIGNATURE_BYTES, EVP_PKEY_size(dilithium_pkey));
+  EXPECT_EQ(8*(DILITHIUM3_PUBLIC_KEY_BYTES), EVP_PKEY_bits(dilithium_pkey));
+
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
+  EVP_PKEY_free(dilithium_pkey);
+}
+
+TEST(Dilithium3Test, Encoding) {
+  // Test Dilithium keypairs are extractable, and encode/parse correctly.
+  //generate dilithium key
+  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
+  EVP_PKEY_keygen_init(dilithium_pkey_ctx);
+  EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey);
+  const DILITHIUM3_KEY *dilithium3Key = (DILITHIUM3_KEY *)(dilithium_pkey->pkey.ptr);
+
+  //Create a public key.
+  bssl::UniquePtr<EVP_PKEY> pubkey(EVP_PKEY_new_raw_public_key(EVP_PKEY_DILITHIUM3,
+                                                               NULL,
+                                                               dilithium3Key->pub,
+                                                               DILITHIUM3_PUBLIC_KEY_BYTES));
+  ASSERT_TRUE(pubkey);
+  EXPECT_EQ(EVP_PKEY_DILITHIUM3, EVP_PKEY_id(pubkey.get()));
+
+  // The public key must be extractable.
+  uint8_t pub_buf[1952];
+  size_t pub_len;
+  ASSERT_TRUE(EVP_PKEY_get_raw_public_key(pubkey.get(), nullptr, &pub_len));
+  EXPECT_EQ(pub_len, 1952u);
+  ASSERT_TRUE(EVP_PKEY_get_raw_public_key(pubkey.get(), pub_buf, &pub_len));
+
+  // The public key must encode properly.
+  bssl::ScopedCBB cbb;
+  uint8_t *der;
+  size_t der_len;
+  ASSERT_TRUE(CBB_init(cbb.get(), 0));
+  ASSERT_TRUE(EVP_marshal_public_key(cbb.get(), pubkey.get()));
+  ASSERT_TRUE(CBB_finish(cbb.get(), &der, &der_len));
+  bssl::UniquePtr<uint8_t> free_der(der);
+
+  // The public key must parse properly.
+  CBS cbs;
+  CBS_init(&cbs, der, der_len);
+  EVP_PKEY *dilithium_pkey_from_der = EVP_parse_public_key(&cbs);
+  ASSERT_TRUE(dilithium_pkey_from_der);
+  EXPECT_EQ(1, EVP_PKEY_cmp(dilithium_pkey, dilithium_pkey_from_der));
+
+  // Create a private key.
+  bssl::UniquePtr<EVP_PKEY> privkey(EVP_PKEY_new_raw_private_key(EVP_PKEY_DILITHIUM3,
+                                                                 NULL,
+                                                                 dilithium3Key->priv,
+                                                                 DILITHIUM3_PRIVATE_KEY_BYTES));
+  ASSERT_TRUE(privkey);
+  EXPECT_EQ(EVP_PKEY_DILITHIUM3, EVP_PKEY_id(privkey.get()));
+
+  // The private key must be extractable.
+  uint8_t priv_buf[4000];
+  size_t priv_len;
+  ASSERT_TRUE(EVP_PKEY_get_raw_private_key(privkey.get(), nullptr, &priv_len));
+  EXPECT_EQ(priv_len, 4000u);
+  ASSERT_TRUE(EVP_PKEY_get_raw_private_key(privkey.get(), priv_buf, &priv_len));
+
+  // The private key must encode properly.
+  ASSERT_TRUE(CBB_init(cbb.get(), 0));
+  ASSERT_TRUE(EVP_marshal_private_key(cbb.get(), privkey.get()));
+  ASSERT_TRUE(CBB_finish(cbb.get(), &der, &der_len));
+  free_der.reset(der);
+
+  // The private key must parse properly.
+  CBS_init(&cbs, der, der_len);
+  EVP_PKEY *dilithium_priv_from_der = EVP_parse_private_key(&cbs);
+  ASSERT_TRUE(dilithium_priv_from_der);
+  const DILITHIUM3_KEY *dilithium3Key_from_der = (DILITHIUM3_KEY *)(dilithium_priv_from_der->pkey.ptr);
+  // The private key dilithium3Key_from_der must be equal to the original key
+  EXPECT_EQ(Bytes(dilithium3Key->priv, DILITHIUM3_PRIVATE_KEY_BYTES),
+            Bytes(dilithium3Key_from_der->priv, DILITHIUM3_PRIVATE_KEY_BYTES));
+
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
+  EVP_PKEY_free(dilithium_pkey);
+  EVP_PKEY_free(dilithium_pkey_from_der);
+  EVP_PKEY_free(dilithium_priv_from_der);
+}
+
+TEST(Dilithium3Test, Decoding) {
+  // generate a Dilithium3 public key based on the public key bytes
+  bssl::UniquePtr<EVP_PKEY> pubkey(EVP_PKEY_new_raw_public_key(
+      EVP_PKEY_DILITHIUM3, nullptr, kPublicKey, sizeof(kPublicKey)));
+  ASSERT_TRUE(pubkey);
+  EXPECT_EQ(EVP_PKEY_DILITHIUM3, EVP_PKEY_id(pubkey.get()));
+
+  // encode the public key as DER
+  bssl::ScopedCBB cbb;
+  uint8_t *der;
+  size_t der_len;
+  ASSERT_TRUE(CBB_init(cbb.get(), 0));
+  ASSERT_TRUE(EVP_marshal_public_key(cbb.get(), pubkey.get()));
+  ASSERT_TRUE(CBB_finish(cbb.get(), &der, &der_len));
+  bssl::UniquePtr<uint8_t> free_der(der);
+
+  // test that the encoded public key encodes as expected
+  EXPECT_EQ(Bytes(kPublicKeySPKI), Bytes(der, der_len));
+
+  // we now decode the DER structure, then parse as a PKEY.
+  CBS cbs;
+  CBS_init(&cbs, der, der_len);
+  EVP_PKEY *dilithium_pkey_from_der = EVP_parse_public_key(&cbs);
+  ASSERT_TRUE(dilithium_pkey_from_der);
+
+  // extract the public key and check it is equivalent to original key
+  uint8_t pub_buf[1952];
+  size_t pub_len;
+  ASSERT_TRUE(EVP_PKEY_get_raw_public_key(dilithium_pkey_from_der, nullptr, &pub_len));
+  EXPECT_EQ(pub_len, 1952u);
+  ASSERT_TRUE(EVP_PKEY_get_raw_public_key(dilithium_pkey_from_der, pub_buf, &pub_len));
+  EXPECT_EQ(Bytes(kPublicKey), Bytes(pub_buf, pub_len));
+
+  EVP_PKEY_free(dilithium_pkey_from_der);
+}
+
+TEST(Dilithium3Test, SIGOperations) {
+  // Test basic functionality for Dilithium3
+  // Generate a Dilithium3 key
+  EVP_PKEY_CTX *dilithium_pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(dilithium_pkey_ctx, nullptr);
+
+  EVP_PKEY *dilithium_pkey = EVP_PKEY_new();
+  ASSERT_NE(dilithium_pkey, nullptr);
+
+  EXPECT_TRUE(EVP_PKEY_keygen_init(dilithium_pkey_ctx));
+  EXPECT_TRUE(EVP_PKEY_keygen(dilithium_pkey_ctx, &dilithium_pkey));
+
+  // sign a message
+  bssl::ScopedEVP_MD_CTX md_ctx;
+  uint8_t signature[DILITHIUM3_SIGNATURE_BYTES];
+  size_t signature_len = DILITHIUM3_SIGNATURE_BYTES;
+  std::vector<uint8_t> msg = {
+      0x4a, 0x41, 0x4b, 0x45, 0x20, 0x4d, 0x41, 0x53, 0x53, 0x49,
+      0x4d, 0x4f, 0x20, 0x41, 0x57, 0x53, 0x32, 0x30, 0x32, 0x32, 0x2e};
+  std::vector<uint8_t> badmsg = {
+      0x4a, 0x41, 0x4b, 0x45, 0x20, 0x4d, 0x41, 0x53, 0x53, 0x49,
+      0x4d, 0x4f, 0x20, 0x41, 0x57, 0x53, 0x32, 0x30, 0x32, 0x31, 0x2e};
+
+  ASSERT_TRUE(EVP_DigestSignInit(md_ctx.get(), NULL, NULL, NULL, dilithium_pkey));
+  ASSERT_TRUE(EVP_DigestSign(md_ctx.get(), signature, &signature_len,
+                             msg.data(), msg.size()));
+
+  // verify the correct signed message
+  ASSERT_TRUE(EVP_DigestVerify(md_ctx.get(), signature, signature_len,
+                               msg.data(), msg.size()));
+
+  // verify the signed message fails upon a bad message
+  ASSERT_FALSE(EVP_DigestVerify(md_ctx.get(), signature, signature_len,
+                                badmsg.data(), badmsg.size()));
+
+  // sign the bad message
+  uint8_t signature1[DILITHIUM3_SIGNATURE_BYTES];
+  ASSERT_TRUE(EVP_DigestSign(md_ctx.get(), signature1, &signature_len,
+                             badmsg.data(), badmsg.size()));
+
+  // check that the two signatures are not equal
+  EXPECT_NE(0, OPENSSL_memcmp(signature, signature1, signature_len));
+
+  // verify the signed message fails upon a bad signature
+  ASSERT_FALSE(EVP_DigestVerify(md_ctx.get(), signature1, signature_len,
+                                msg.data(), msg.size()));
+
+  EVP_PKEY_free(dilithium_pkey);
+  EVP_PKEY_CTX_free(dilithium_pkey_ctx);
+  md_ctx.Reset();
+}
+
+#else
+
+TEST(Dilithium3Test, EvpDisabled) {
+  ASSERT_EQ(nullptr, EVP_PKEY_CTX_new_id(NID_DILITHIUM3_R3, nullptr));
+
+  EVP_PKEY *pkey = EVP_PKEY_new();
+  ASSERT_FALSE(EVP_PKEY_set_type(pkey, NID_DILITHIUM3_R3));
+  EVP_PKEY_free(pkey);
+}
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/api.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/api.h
new file mode 100644
index 000000000..47db2f312
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/api.h
@@ -0,0 +1,203 @@
+#ifndef API_DILITHIUM_H
+#define API_DILITHIUM_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include "openssl/base.h"
+
+#define pqcrystals_dilithium2_PUBLICKEYBYTES 1312
+#define pqcrystals_dilithium2_SECRETKEYBYTES 2528
+#define pqcrystals_dilithium2_BYTES 2420
+
+#define pqcrystals_dilithium2_ref_PUBLICKEYBYTES pqcrystals_dilithium2_PUBLICKEYBYTES
+#define pqcrystals_dilithium2_ref_SECRETKEYBYTES pqcrystals_dilithium2_SECRETKEYBYTES
+#define pqcrystals_dilithium2_ref_BYTES pqcrystals_dilithium2_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium2_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2_ref_keypair)
+#define pqcrystals_dilithium2_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2_ref_signature)
+#define pqcrystals_dilithium2_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2_ref)
+#define pqcrystals_dilithium2_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2_ref_verify)
+#define pqcrystals_dilithium2_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2_ref_open)
+#endif
+
+int pqcrystals_dilithium2_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium2_ref_signature(uint8_t *sig, size_t *siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *sk);
+
+int pqcrystals_dilithium2_ref(uint8_t *sm, size_t *smlen,
+                              const uint8_t *m, size_t mlen,
+                              const uint8_t *sk);
+
+int pqcrystals_dilithium2_ref_verify(const uint8_t *sig, size_t siglen,
+                                     const uint8_t *m, size_t mlen,
+                                     const uint8_t *pk);
+
+int pqcrystals_dilithium2_ref_open(uint8_t *m, size_t *mlen,
+                                   const uint8_t *sm, size_t smlen,
+                                   const uint8_t *pk);
+
+#define pqcrystals_dilithium2aes_ref_PUBLICKEYBYTES pqcrystals_dilithium2_ref_PUBLICKEYBYTES
+#define pqcrystals_dilithium2aes_ref_SECRETKEYBYTES pqcrystals_dilithium2_ref_SECRETKEYBYTES
+#define pqcrystals_dilithium2aes_ref_BYTES pqcrystals_dilithium2_ref_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium2aes_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2aes_ref_keypair)
+#define pqcrystals_dilithium2aes_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2aes_ref_signature)
+#define pqcrystals_dilithium2aes_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2aes_ref)
+#define pqcrystals_dilithium2aes_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2aes_ref_verify)
+#define pqcrystals_dilithium2aes_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium2aes_ref_open)
+#endif
+
+int pqcrystals_dilithium2aes_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium2aes_ref_signature(uint8_t *sig, size_t *siglen,
+                                           const uint8_t *m, size_t mlen,
+                                           const uint8_t *sk);
+
+int pqcrystals_dilithium2aes_ref(uint8_t *sm, size_t *smlen,
+                                 const uint8_t *m, size_t mlen,
+                                 const uint8_t *sk);
+
+int pqcrystals_dilithium2aes_ref_verify(const uint8_t *sig, size_t siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *pk);
+
+int pqcrystals_dilithium2aes_ref_open(uint8_t *m, size_t *mlen,
+                                      const uint8_t *sm, size_t smlen,
+                                      const uint8_t *pk);
+
+#define pqcrystals_dilithium3_PUBLICKEYBYTES 1952
+#define pqcrystals_dilithium3_SECRETKEYBYTES 4000
+#define pqcrystals_dilithium3_BYTES 3293
+
+#define pqcrystals_dilithium3_ref_PUBLICKEYBYTES pqcrystals_dilithium3_PUBLICKEYBYTES
+#define pqcrystals_dilithium3_ref_SECRETKEYBYTES pqcrystals_dilithium3_SECRETKEYBYTES
+#define pqcrystals_dilithium3_ref_BYTES pqcrystals_dilithium3_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium3_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3_ref_keypair)
+#define pqcrystals_dilithium3_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3_ref_signature)
+#define pqcrystals_dilithium3_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3_ref)
+#define pqcrystals_dilithium3_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3_ref_verify)
+#define pqcrystals_dilithium3_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3_ref_open)
+#endif
+
+int pqcrystals_dilithium3_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium3_ref_signature(uint8_t *sig, size_t *siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *sk);
+
+int pqcrystals_dilithium3_ref(uint8_t *sm, size_t *smlen,
+                              const uint8_t *m, size_t mlen,
+                              const uint8_t *sk);
+
+int pqcrystals_dilithium3_ref_verify(const uint8_t *sig, size_t siglen,
+                                     const uint8_t *m, size_t mlen,
+                                     const uint8_t *pk);
+
+int pqcrystals_dilithium3_ref_open(uint8_t *m, size_t *mlen,
+                                   const uint8_t *sm, size_t smlen,
+                                   const uint8_t *pk);
+
+#define pqcrystals_dilithium3aes_ref_PUBLICKEYBYTES pqcrystals_dilithium3_ref_PUBLICKEYBYTES
+#define pqcrystals_dilithium3aes_ref_SECRETKEYBYTES pqcrystals_dilithium3_ref_SECRETKEYBYTES
+#define pqcrystals_dilithium3aes_ref_BYTES pqcrystals_dilithium3_ref_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium3aes_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3aes_ref_keypair)
+#define pqcrystals_dilithium3aes_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3aes_ref_signature)
+#define pqcrystals_dilithium3aes_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3aes_ref)
+#define pqcrystals_dilithium3aes_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3aes_ref_verify)
+#define pqcrystals_dilithium3aes_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium3aes_ref_open)
+#endif
+
+
+int pqcrystals_dilithium3aes_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium3aes_ref_signature(uint8_t *sig, size_t *siglen,
+                                           const uint8_t *m, size_t mlen,
+                                           const uint8_t *sk);
+
+int pqcrystals_dilithium3aes_ref(uint8_t *sm, size_t *smlen,
+                                 const uint8_t *m, size_t mlen,
+                                 const uint8_t *sk);
+
+int pqcrystals_dilithium3aes_ref_verify(const uint8_t *sig, size_t siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *pk);
+
+int pqcrystals_dilithium3aes_ref_open(uint8_t *m, size_t *mlen,
+                                      const uint8_t *sm, size_t smlen,
+                                      const uint8_t *pk);
+
+#define pqcrystals_dilithium5_PUBLICKEYBYTES 2592
+#define pqcrystals_dilithium5_SECRETKEYBYTES 4864
+#define pqcrystals_dilithium5_BYTES 4595
+
+#define pqcrystals_dilithium5_ref_PUBLICKEYBYTES pqcrystals_dilithium5_PUBLICKEYBYTES
+#define pqcrystals_dilithium5_ref_SECRETKEYBYTES pqcrystals_dilithium5_SECRETKEYBYTES
+#define pqcrystals_dilithium5_ref_BYTES pqcrystals_dilithium5_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium5_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5_ref_keypair)
+#define pqcrystals_dilithium5_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5_ref_signature)
+#define pqcrystals_dilithium5_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5_ref)
+#define pqcrystals_dilithium5_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5_ref_verify)
+#define pqcrystals_dilithium5_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5_ref_open)
+#endif
+
+int pqcrystals_dilithium5_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium5_ref_signature(uint8_t *sig, size_t *siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *sk);
+
+int pqcrystals_dilithium5_ref(uint8_t *sm, size_t *smlen,
+                              const uint8_t *m, size_t mlen,
+                              const uint8_t *sk);
+
+int pqcrystals_dilithium5_ref_verify(const uint8_t *sig, size_t siglen,
+                                     const uint8_t *m, size_t mlen,
+                                     const uint8_t *pk);
+
+int pqcrystals_dilithium5_ref_open(uint8_t *m, size_t *mlen,
+                                   const uint8_t *sm, size_t smlen,
+                                   const uint8_t *pk);
+
+#define pqcrystals_dilithium5aes_ref_PUBLICKEYBYTES pqcrystals_dilithium5_ref_PUBLICKEYBYTES
+#define pqcrystals_dilithium5aes_ref_SECRETKEYBYTES pqcrystals_dilithium5_ref_SECRETKEYBYTES
+#define pqcrystals_dilithium5aes_ref_BYTES pqcrystals_dilithium5_ref_BYTES
+
+#ifdef BORINGSSL_PREFIX
+#define pqcrystals_dilithium5aes_ref_keypair BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5aes_ref_keypair)
+#define pqcrystals_dilithium5aes_ref_signature BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5aes_ref_signature)
+#define pqcrystals_dilithium5aes_ref BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5aes_ref)
+#define pqcrystals_dilithium5aes_ref_verify BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5aes_ref_verify)
+#define pqcrystals_dilithium5aes_ref_open BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, pqcrystals_dilithium5aes_ref_open)
+#endif
+
+
+int pqcrystals_dilithium5aes_ref_keypair(uint8_t *pk, uint8_t *sk);
+
+int pqcrystals_dilithium5aes_ref_signature(uint8_t *sig, size_t *siglen,
+                                           const uint8_t *m, size_t mlen,
+                                           const uint8_t *sk);
+
+int pqcrystals_dilithium5aes_ref(uint8_t *sm, size_t *smlen,
+                                 const uint8_t *m, size_t mlen,
+                                 const uint8_t *sk);
+
+int pqcrystals_dilithium5aes_ref_verify(const uint8_t *sig, size_t siglen,
+                                        const uint8_t *m, size_t mlen,
+                                        const uint8_t *pk);
+
+int pqcrystals_dilithium5aes_ref_open(uint8_t *m, size_t *mlen,
+                                      const uint8_t *sm, size_t smlen,
+                                      const uint8_t *pk);
+
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/config.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/config.h
new file mode 100644
index 000000000..23233e5f4
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/config.h
@@ -0,0 +1,32 @@
+#ifndef CONFIG_H
+#define CONFIG_H
+
+#include <openssl/base.h>
+
+#ifndef DILITHIUM_MODE
+#define DILITHIUM_MODE 3
+#endif
+
+#if DILITHIUM_MODE == 2
+#define CRYPTO_ALGNAME "Dilithium2"
+#define DILITHIUM_VARIANTTOP pqcrystals_dilithium2_ref
+#define DILITHIUM_VARIANT(s) pqcrystals_dilithium2_ref_##s
+#elif DILITHIUM_MODE == 3
+#define CRYPTO_ALGNAME "Dilithium3"
+#define DILITHIUM_VARIANTTOP pqcrystals_dilithium3_ref
+#define DILITHIUM_VARIANT(s) pqcrystals_dilithium3_ref_##s
+#elif DILITHIUM_MODE == 5
+#define CRYPTO_ALGNAME "Dilithium5"
+#define DILITHIUM_VARIANTTOP pqcrystals_dilithium5_ref
+#define DILITHIUM_VARIANT(s) pqcrystals_dilithium5_ref_##s
+#endif
+
+#ifdef BORINGSSL_PREFIX
+#define DILITHIUM_NAMESPACE(s) BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, DILITHIUM_VARIANT(s))
+#define DILITHIUM_NAMESPACETOP BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, DILITHIUM_VARIANTTOP)
+#else
+#define DILITHIUM_NAMESPACE(s) DILITHIUM_VARIANT(s)
+#define DILITHIUM_NAMESPACETOP DILITHIUM_VARIANTTOP
+#endif
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.c
new file mode 100644
index 000000000..2afe799ea
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.c
@@ -0,0 +1,774 @@
+/* Based on the public domain implementation in crypto_hash/keccakc512/simple/ from
+ * http://bench.cr.yp.to/supercop.html by Ronny Van Keer and the public domain "TweetFips202"
+ * implementation from https://twitter.com/tweetfips202 by Gilles Van Assche, Daniel J. Bernstein,
+ * and Peter Schwabe */
+
+#include <stddef.h>
+#include <stdint.h>
+#include "fips202.h"
+
+#define NROUNDS 24
+#define ROL(a, offset) ((a << offset) ^ (a >> (64-offset)))
+
+/*************************************************
+* Name:        load64
+*
+* Description: Load 8 bytes into uint64_t in little-endian order
+*
+* Arguments:   - const uint8_t *x: pointer to input byte array
+*
+* Returns the loaded 64-bit unsigned integer
+**************************************************/
+static uint64_t load64(const uint8_t x[8]) {
+  unsigned int i;
+  uint64_t r = 0;
+
+  for(i=0;i<8;i++)
+    r |= (uint64_t)x[i] << 8*i;
+
+  return r;
+}
+
+/*************************************************
+* Name:        store64
+*
+* Description: Store a 64-bit integer to array of 8 bytes in little-endian order
+*
+* Arguments:   - uint8_t *x: pointer to the output byte array (allocated)
+*              - uint64_t u: input 64-bit unsigned integer
+**************************************************/
+static void store64(uint8_t x[8], uint64_t u) {
+  unsigned int i;
+
+  for(i=0;i<8;i++)
+    x[i] = u >> 8*i;
+}
+
+/* Keccak round constants */
+const uint64_t KeccakF_RoundConstants[NROUNDS] = {
+  (uint64_t)0x0000000000000001ULL,
+  (uint64_t)0x0000000000008082ULL,
+  (uint64_t)0x800000000000808aULL,
+  (uint64_t)0x8000000080008000ULL,
+  (uint64_t)0x000000000000808bULL,
+  (uint64_t)0x0000000080000001ULL,
+  (uint64_t)0x8000000080008081ULL,
+  (uint64_t)0x8000000000008009ULL,
+  (uint64_t)0x000000000000008aULL,
+  (uint64_t)0x0000000000000088ULL,
+  (uint64_t)0x0000000080008009ULL,
+  (uint64_t)0x000000008000000aULL,
+  (uint64_t)0x000000008000808bULL,
+  (uint64_t)0x800000000000008bULL,
+  (uint64_t)0x8000000000008089ULL,
+  (uint64_t)0x8000000000008003ULL,
+  (uint64_t)0x8000000000008002ULL,
+  (uint64_t)0x8000000000000080ULL,
+  (uint64_t)0x000000000000800aULL,
+  (uint64_t)0x800000008000000aULL,
+  (uint64_t)0x8000000080008081ULL,
+  (uint64_t)0x8000000000008080ULL,
+  (uint64_t)0x0000000080000001ULL,
+  (uint64_t)0x8000000080008008ULL
+};
+
+/*************************************************
+* Name:        KeccakF1600_StatePermute
+*
+* Description: The Keccak F1600 Permutation
+*
+* Arguments:   - uint64_t *state: pointer to input/output Keccak state
+**************************************************/
+static void KeccakF1600_StatePermute(uint64_t state[25])
+{
+        int round;
+
+        uint64_t Aba, Abe, Abi, Abo, Abu;
+        uint64_t Aga, Age, Agi, Ago, Agu;
+        uint64_t Aka, Ake, Aki, Ako, Aku;
+        uint64_t Ama, Ame, Ami, Amo, Amu;
+        uint64_t Asa, Ase, Asi, Aso, Asu;
+        uint64_t BCa, BCe, BCi, BCo, BCu;
+        uint64_t Da, De, Di, Do, Du;
+        uint64_t Eba, Ebe, Ebi, Ebo, Ebu;
+        uint64_t Ega, Ege, Egi, Ego, Egu;
+        uint64_t Eka, Eke, Eki, Eko, Eku;
+        uint64_t Ema, Eme, Emi, Emo, Emu;
+        uint64_t Esa, Ese, Esi, Eso, Esu;
+
+        //copyFromState(A, state)
+        Aba = state[ 0];
+        Abe = state[ 1];
+        Abi = state[ 2];
+        Abo = state[ 3];
+        Abu = state[ 4];
+        Aga = state[ 5];
+        Age = state[ 6];
+        Agi = state[ 7];
+        Ago = state[ 8];
+        Agu = state[ 9];
+        Aka = state[10];
+        Ake = state[11];
+        Aki = state[12];
+        Ako = state[13];
+        Aku = state[14];
+        Ama = state[15];
+        Ame = state[16];
+        Ami = state[17];
+        Amo = state[18];
+        Amu = state[19];
+        Asa = state[20];
+        Ase = state[21];
+        Asi = state[22];
+        Aso = state[23];
+        Asu = state[24];
+
+        for(round = 0; round < NROUNDS; round += 2) {
+            //    prepareTheta
+            BCa = Aba^Aga^Aka^Ama^Asa;
+            BCe = Abe^Age^Ake^Ame^Ase;
+            BCi = Abi^Agi^Aki^Ami^Asi;
+            BCo = Abo^Ago^Ako^Amo^Aso;
+            BCu = Abu^Agu^Aku^Amu^Asu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round, A, E)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Aba ^= Da;
+            BCa = Aba;
+            Age ^= De;
+            BCe = ROL(Age, 44);
+            Aki ^= Di;
+            BCi = ROL(Aki, 43);
+            Amo ^= Do;
+            BCo = ROL(Amo, 21);
+            Asu ^= Du;
+            BCu = ROL(Asu, 14);
+            Eba =   BCa ^((~BCe)&  BCi );
+            Eba ^= (uint64_t)KeccakF_RoundConstants[round];
+            Ebe =   BCe ^((~BCi)&  BCo );
+            Ebi =   BCi ^((~BCo)&  BCu );
+            Ebo =   BCo ^((~BCu)&  BCa );
+            Ebu =   BCu ^((~BCa)&  BCe );
+
+            Abo ^= Do;
+            BCa = ROL(Abo, 28);
+            Agu ^= Du;
+            BCe = ROL(Agu, 20);
+            Aka ^= Da;
+            BCi = ROL(Aka,  3);
+            Ame ^= De;
+            BCo = ROL(Ame, 45);
+            Asi ^= Di;
+            BCu = ROL(Asi, 61);
+            Ega =   BCa ^((~BCe)&  BCi );
+            Ege =   BCe ^((~BCi)&  BCo );
+            Egi =   BCi ^((~BCo)&  BCu );
+            Ego =   BCo ^((~BCu)&  BCa );
+            Egu =   BCu ^((~BCa)&  BCe );
+
+            Abe ^= De;
+            BCa = ROL(Abe,  1);
+            Agi ^= Di;
+            BCe = ROL(Agi,  6);
+            Ako ^= Do;
+            BCi = ROL(Ako, 25);
+            Amu ^= Du;
+            BCo = ROL(Amu,  8);
+            Asa ^= Da;
+            BCu = ROL(Asa, 18);
+            Eka =   BCa ^((~BCe)&  BCi );
+            Eke =   BCe ^((~BCi)&  BCo );
+            Eki =   BCi ^((~BCo)&  BCu );
+            Eko =   BCo ^((~BCu)&  BCa );
+            Eku =   BCu ^((~BCa)&  BCe );
+
+            Abu ^= Du;
+            BCa = ROL(Abu, 27);
+            Aga ^= Da;
+            BCe = ROL(Aga, 36);
+            Ake ^= De;
+            BCi = ROL(Ake, 10);
+            Ami ^= Di;
+            BCo = ROL(Ami, 15);
+            Aso ^= Do;
+            BCu = ROL(Aso, 56);
+            Ema =   BCa ^((~BCe)&  BCi );
+            Eme =   BCe ^((~BCi)&  BCo );
+            Emi =   BCi ^((~BCo)&  BCu );
+            Emo =   BCo ^((~BCu)&  BCa );
+            Emu =   BCu ^((~BCa)&  BCe );
+
+            Abi ^= Di;
+            BCa = ROL(Abi, 62);
+            Ago ^= Do;
+            BCe = ROL(Ago, 55);
+            Aku ^= Du;
+            BCi = ROL(Aku, 39);
+            Ama ^= Da;
+            BCo = ROL(Ama, 41);
+            Ase ^= De;
+            BCu = ROL(Ase,  2);
+            Esa =   BCa ^((~BCe)&  BCi );
+            Ese =   BCe ^((~BCi)&  BCo );
+            Esi =   BCi ^((~BCo)&  BCu );
+            Eso =   BCo ^((~BCu)&  BCa );
+            Esu =   BCu ^((~BCa)&  BCe );
+
+            //    prepareTheta
+            BCa = Eba^Ega^Eka^Ema^Esa;
+            BCe = Ebe^Ege^Eke^Eme^Ese;
+            BCi = Ebi^Egi^Eki^Emi^Esi;
+            BCo = Ebo^Ego^Eko^Emo^Eso;
+            BCu = Ebu^Egu^Eku^Emu^Esu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round+1, E, A)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Eba ^= Da;
+            BCa = Eba;
+            Ege ^= De;
+            BCe = ROL(Ege, 44);
+            Eki ^= Di;
+            BCi = ROL(Eki, 43);
+            Emo ^= Do;
+            BCo = ROL(Emo, 21);
+            Esu ^= Du;
+            BCu = ROL(Esu, 14);
+            Aba =   BCa ^((~BCe)&  BCi );
+            Aba ^= (uint64_t)KeccakF_RoundConstants[round+1];
+            Abe =   BCe ^((~BCi)&  BCo );
+            Abi =   BCi ^((~BCo)&  BCu );
+            Abo =   BCo ^((~BCu)&  BCa );
+            Abu =   BCu ^((~BCa)&  BCe );
+
+            Ebo ^= Do;
+            BCa = ROL(Ebo, 28);
+            Egu ^= Du;
+            BCe = ROL(Egu, 20);
+            Eka ^= Da;
+            BCi = ROL(Eka, 3);
+            Eme ^= De;
+            BCo = ROL(Eme, 45);
+            Esi ^= Di;
+            BCu = ROL(Esi, 61);
+            Aga =   BCa ^((~BCe)&  BCi );
+            Age =   BCe ^((~BCi)&  BCo );
+            Agi =   BCi ^((~BCo)&  BCu );
+            Ago =   BCo ^((~BCu)&  BCa );
+            Agu =   BCu ^((~BCa)&  BCe );
+
+            Ebe ^= De;
+            BCa = ROL(Ebe, 1);
+            Egi ^= Di;
+            BCe = ROL(Egi, 6);
+            Eko ^= Do;
+            BCi = ROL(Eko, 25);
+            Emu ^= Du;
+            BCo = ROL(Emu, 8);
+            Esa ^= Da;
+            BCu = ROL(Esa, 18);
+            Aka =   BCa ^((~BCe)&  BCi );
+            Ake =   BCe ^((~BCi)&  BCo );
+            Aki =   BCi ^((~BCo)&  BCu );
+            Ako =   BCo ^((~BCu)&  BCa );
+            Aku =   BCu ^((~BCa)&  BCe );
+
+            Ebu ^= Du;
+            BCa = ROL(Ebu, 27);
+            Ega ^= Da;
+            BCe = ROL(Ega, 36);
+            Eke ^= De;
+            BCi = ROL(Eke, 10);
+            Emi ^= Di;
+            BCo = ROL(Emi, 15);
+            Eso ^= Do;
+            BCu = ROL(Eso, 56);
+            Ama =   BCa ^((~BCe)&  BCi );
+            Ame =   BCe ^((~BCi)&  BCo );
+            Ami =   BCi ^((~BCo)&  BCu );
+            Amo =   BCo ^((~BCu)&  BCa );
+            Amu =   BCu ^((~BCa)&  BCe );
+
+            Ebi ^= Di;
+            BCa = ROL(Ebi, 62);
+            Ego ^= Do;
+            BCe = ROL(Ego, 55);
+            Eku ^= Du;
+            BCi = ROL(Eku, 39);
+            Ema ^= Da;
+            BCo = ROL(Ema, 41);
+            Ese ^= De;
+            BCu = ROL(Ese, 2);
+            Asa =   BCa ^((~BCe)&  BCi );
+            Ase =   BCe ^((~BCi)&  BCo );
+            Asi =   BCi ^((~BCo)&  BCu );
+            Aso =   BCo ^((~BCu)&  BCa );
+            Asu =   BCu ^((~BCa)&  BCe );
+        }
+
+        //copyToState(state, A)
+        state[ 0] = Aba;
+        state[ 1] = Abe;
+        state[ 2] = Abi;
+        state[ 3] = Abo;
+        state[ 4] = Abu;
+        state[ 5] = Aga;
+        state[ 6] = Age;
+        state[ 7] = Agi;
+        state[ 8] = Ago;
+        state[ 9] = Agu;
+        state[10] = Aka;
+        state[11] = Ake;
+        state[12] = Aki;
+        state[13] = Ako;
+        state[14] = Aku;
+        state[15] = Ama;
+        state[16] = Ame;
+        state[17] = Ami;
+        state[18] = Amo;
+        state[19] = Amu;
+        state[20] = Asa;
+        state[21] = Ase;
+        state[22] = Asi;
+        state[23] = Aso;
+        state[24] = Asu;
+}
+
+/*************************************************
+* Name:        keccak_init
+*
+* Description: Initializes the Keccak state.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+**************************************************/
+static void keccak_init(uint64_t s[25])
+{
+  unsigned int i;
+  for(i=0;i<25;i++)
+    s[i] = 0;
+}
+
+/*************************************************
+* Name:        keccak_absorb
+*
+* Description: Absorb step of Keccak; incremental.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+*              - unsigned int pos: position in current block to be absorbed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+*
+* Returns new position pos in current block
+**************************************************/
+static unsigned int keccak_absorb(uint64_t s[25],
+                                  unsigned int pos,
+                                  unsigned int r,
+                                  const uint8_t *in,
+                                  size_t inlen)
+{
+  unsigned int i;
+
+  while(pos+inlen >= r) {
+    for(i=pos;i<r;i++)
+      s[i/8] ^= (uint64_t)*in++ << 8*(i%8);
+    inlen -= r-pos;
+    KeccakF1600_StatePermute(s);
+    pos = 0;
+  }
+
+  for(i=pos;i<pos+inlen;i++)
+    s[i/8] ^= (uint64_t)*in++ << 8*(i%8);
+
+  return i;
+}
+
+/*************************************************
+* Name:        keccak_finalize
+*
+* Description: Finalize absorb step.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+*              - unsigned int pos: position in current block to be absorbed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - uint8_t p: domain separation byte
+**************************************************/
+static void keccak_finalize(uint64_t s[25], unsigned int pos, unsigned int r, uint8_t p)
+{
+  s[pos/8] ^= (uint64_t)p << 8*(pos%8);
+  s[r/8-1] ^= 1ULL << 63;
+}
+
+/*************************************************
+* Name:        keccak_squeeze
+*
+* Description: Squeeze step of Keccak. Squeezes arbitratrily many bytes.
+*              Modifies the state. Can be called multiple times to keep
+*              squeezing, i.e., is incremental.
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: number of bytes to be squeezed (written to out)
+*              - uint64_t *s: pointer to input/output Keccak state
+*              - unsigned int pos: number of bytes in current block already squeezed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*
+* Returns new position pos in current block
+**************************************************/
+static unsigned int keccak_squeeze(uint8_t *out,
+                                   size_t outlen,
+                                   uint64_t s[25],
+                                   unsigned int pos,
+                                   unsigned int r)
+{
+  unsigned int i;
+
+  while(outlen) {
+    if(pos == r) {
+      KeccakF1600_StatePermute(s);
+      pos = 0;
+    }
+    for(i=pos;i < r && i < pos+outlen; i++)
+      *out++ = s[i/8] >> 8*(i%8);
+    outlen -= i-pos;
+    pos = i;
+  }
+
+  return pos;
+}
+
+
+/*************************************************
+* Name:        keccak_absorb_once
+*
+* Description: Absorb step of Keccak;
+*              non-incremental, starts by zeroeing the state.
+*
+* Arguments:   - uint64_t *s: pointer to (uninitialized) output Keccak state
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+*              - uint8_t p: domain-separation byte for different Keccak-derived functions
+**************************************************/
+static void keccak_absorb_once(uint64_t s[25],
+                               unsigned int r,
+                               const uint8_t *in,
+                               size_t inlen,
+                               uint8_t p)
+{
+  unsigned int i;
+
+  for(i=0;i<25;i++)
+    s[i] = 0;
+
+  while(inlen >= r) {
+    for(i=0;i<r/8;i++)
+      s[i] ^= load64(in+8*i);
+    in += r;
+    inlen -= r;
+    KeccakF1600_StatePermute(s);
+  }
+
+  for(i=0;i<inlen;i++)
+    s[i/8] ^= (uint64_t)in[i] << 8*(i%8);
+
+  s[i/8] ^= (uint64_t)p << 8*(i%8);
+  s[(r-1)/8] ^= 1ULL << 63;
+}
+
+/*************************************************
+* Name:        keccak_squeezeblocks
+*
+* Description: Squeeze step of Keccak. Squeezes full blocks of r bytes each.
+*              Modifies the state. Can be called multiple times to keep
+*              squeezing, i.e., is incremental. Assumes zero bytes of current
+*              block have already been squeezed.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to out)
+*              - uint64_t *s: pointer to input/output Keccak state
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+**************************************************/
+static void keccak_squeezeblocks(uint8_t *out,
+                                 size_t nblocks,
+                                 uint64_t s[25],
+                                 unsigned int r)
+{
+  unsigned int i;
+
+  while(nblocks) {
+    KeccakF1600_StatePermute(s);
+    for(i=0;i<r/8;i++)
+      store64(out+8*i, s[i]);
+    out += r;
+    nblocks -= 1;
+  }
+}
+
+/*************************************************
+* Name:        shake128_init
+*
+* Description: Initilizes Keccak state for use as SHAKE128 XOF
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) Keccak state
+**************************************************/
+void shake128_init(keccak_state *state)
+{
+  keccak_init(state->s);
+  state->pos = 0;
+}
+
+/*************************************************
+* Name:        shake128_absorb
+*
+* Description: Absorb step of the SHAKE128 XOF; incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (initialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  state->pos = keccak_absorb(state->s, state->pos, SHAKE128_RATE, in, inlen);
+}
+
+/*************************************************
+* Name:        shake128_finalize
+*
+* Description: Finalize absorb step of the SHAKE128 XOF.
+*
+* Arguments:   - keccak_state *state: pointer to Keccak state
+**************************************************/
+void shake128_finalize(keccak_state *state)
+{
+  keccak_finalize(state->s, state->pos, SHAKE128_RATE, 0x1F);
+  state->pos = SHAKE128_RATE;
+}
+
+/*************************************************
+* Name:        shake128_squeeze
+*
+* Description: Squeeze step of SHAKE128 XOF. Squeezes arbitraily many
+*              bytes. Can be called multiple times to keep squeezing.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t outlen : number of bytes to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake128_squeeze(uint8_t *out, size_t outlen, keccak_state *state)
+{
+  state->pos = keccak_squeeze(out, outlen, state->s, state->pos, SHAKE128_RATE);
+}
+
+/*************************************************
+* Name:        shake128_absorb_once
+*
+* Description: Initialize, absorb into and finalize SHAKE128 XOF; non-incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  keccak_absorb_once(state->s, SHAKE128_RATE, in, inlen, 0x1F);
+  state->pos = SHAKE128_RATE;
+}
+
+/*************************************************
+* Name:        shake128_squeezeblocks
+*
+* Description: Squeeze step of SHAKE128 XOF. Squeezes full blocks of
+*              SHAKE128_RATE bytes each. Can be called multiple times
+*              to keep squeezing. Assumes new block has not yet been
+*              started (state->pos = SHAKE128_RATE).
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)
+{
+  keccak_squeezeblocks(out, nblocks, state->s, SHAKE128_RATE);
+}
+
+/*************************************************
+* Name:        shake256_init
+*
+* Description: Initilizes Keccak state for use as SHAKE256 XOF
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) Keccak state
+**************************************************/
+void shake256_init(keccak_state *state)
+{
+  keccak_init(state->s);
+  state->pos = 0;
+}
+
+/*************************************************
+* Name:        shake256_absorb
+*
+* Description: Absorb step of the SHAKE256 XOF; incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (initialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  state->pos = keccak_absorb(state->s, state->pos, SHAKE256_RATE, in, inlen);
+}
+
+/*************************************************
+* Name:        shake256_finalize
+*
+* Description: Finalize absorb step of the SHAKE256 XOF.
+*
+* Arguments:   - keccak_state *state: pointer to Keccak state
+**************************************************/
+void shake256_finalize(keccak_state *state)
+{
+  keccak_finalize(state->s, state->pos, SHAKE256_RATE, 0x1F);
+  state->pos = SHAKE256_RATE;
+}
+
+/*************************************************
+* Name:        shake256_squeeze
+*
+* Description: Squeeze step of SHAKE256 XOF. Squeezes arbitraily many
+*              bytes. Can be called multiple times to keep squeezing.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t outlen : number of bytes to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake256_squeeze(uint8_t *out, size_t outlen, keccak_state *state)
+{
+  state->pos = keccak_squeeze(out, outlen, state->s, state->pos, SHAKE256_RATE);
+}
+
+/*************************************************
+* Name:        shake256_absorb_once
+*
+* Description: Initialize, absorb into and finalize SHAKE256 XOF; non-incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  keccak_absorb_once(state->s, SHAKE256_RATE, in, inlen, 0x1F);
+  state->pos = SHAKE256_RATE;
+}
+
+/*************************************************
+* Name:        shake256_squeezeblocks
+*
+* Description: Squeeze step of SHAKE256 XOF. Squeezes full blocks of
+*              SHAKE256_RATE bytes each. Can be called multiple times
+*              to keep squeezing. Assumes next block has not yet been
+*              started (state->pos = SHAKE256_RATE).
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake256_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)
+{
+  keccak_squeezeblocks(out, nblocks, state->s, SHAKE256_RATE);
+}
+
+/*************************************************
+* Name:        shake128
+*
+* Description: SHAKE128 XOF with non-incremental API
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: requested output length in bytes
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
+{
+  size_t nblocks;
+  keccak_state state;
+
+  shake128_absorb_once(&state, in, inlen);
+  nblocks = outlen/SHAKE128_RATE;
+  shake128_squeezeblocks(out, nblocks, &state);
+  outlen -= nblocks*SHAKE128_RATE;
+  out += nblocks*SHAKE128_RATE;
+  shake128_squeeze(out, outlen, &state);
+}
+
+/*************************************************
+* Name:        shake256
+*
+* Description: SHAKE256 XOF with non-incremental API
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: requested output length in bytes
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
+{
+  size_t nblocks;
+  keccak_state state;
+
+  shake256_absorb_once(&state, in, inlen);
+  nblocks = outlen/SHAKE256_RATE;
+  shake256_squeezeblocks(out, nblocks, &state);
+  outlen -= nblocks*SHAKE256_RATE;
+  out += nblocks*SHAKE256_RATE;
+  shake256_squeeze(out, outlen, &state);
+}
+
+/*************************************************
+* Name:        sha3_256
+*
+* Description: SHA3-256 with non-incremental API
+*
+* Arguments:   - uint8_t *h: pointer to output (32 bytes)
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen)
+{
+  unsigned int i;
+  uint64_t s[25];
+
+  keccak_absorb_once(s, SHA3_256_RATE, in, inlen, 0x06);
+  KeccakF1600_StatePermute(s);
+  for(i=0;i<4;i++)
+    store64(h+8*i,s[i]);
+}
+
+/*************************************************
+* Name:        sha3_512
+*
+* Description: SHA3-512 with non-incremental API
+*
+* Arguments:   - uint8_t *h: pointer to output (64 bytes)
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void sha3_512(uint8_t h[64], const uint8_t *in, size_t inlen)
+{
+  unsigned int i;
+  uint64_t s[25];
+
+  keccak_absorb_once(s, SHA3_512_RATE, in, inlen, 0x06);
+  KeccakF1600_StatePermute(s);
+  for(i=0;i<8;i++)
+    store64(h+8*i,s[i]);
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.h
new file mode 100644
index 000000000..c033ff095
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/fips202.h
@@ -0,0 +1,64 @@
+#ifndef FIPS202_H
+#define FIPS202_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <openssl/base.h>
+
+#define SHAKE128_RATE 168
+#define SHAKE256_RATE 136
+#define SHA3_256_RATE 136
+#define SHA3_512_RATE 72
+
+#define FIPS202_PREFIX(s) pqcrystals_dilithium_fips202_ref_##s
+
+#ifdef BORINGSSL_PREFIX
+#define FIPS202_NAMESPACE(s) BORINGSSL_ADD_PREFIX(BORINGSSL_PREFIX, FIPS202_PREFIX(s))
+#else
+#define FIPS202_NAMESPACE(s) FIPS202_PREFIX(s)
+#endif
+
+typedef struct {
+  uint64_t s[25];
+  unsigned int pos;
+} keccak_state;
+
+#define KeccakF_RoundConstants FIPS202_NAMESPACE(KeccakF_RoundConstants)
+extern const uint64_t KeccakF_RoundConstants[];
+
+#define shake128_init FIPS202_NAMESPACE(shake128_init)
+void shake128_init(keccak_state *state);
+#define shake128_absorb FIPS202_NAMESPACE(shake128_absorb)
+void shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake128_finalize FIPS202_NAMESPACE(shake128_finalize)
+void shake128_finalize(keccak_state *state);
+#define shake128_squeeze FIPS202_NAMESPACE(shake128_squeeze)
+void shake128_squeeze(uint8_t *out, size_t outlen, keccak_state *state);
+#define shake128_absorb_once FIPS202_NAMESPACE(shake128_absorb_once)
+void shake128_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake128_squeezeblocks FIPS202_NAMESPACE(shake128_squeezeblocks)
+void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state);
+
+#define shake256_init FIPS202_NAMESPACE(shake256_init)
+void shake256_init(keccak_state *state);
+#define shake256_absorb FIPS202_NAMESPACE(shake256_absorb)
+void shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake256_finalize FIPS202_NAMESPACE(shake256_finalize)
+void shake256_finalize(keccak_state *state);
+#define shake256_squeeze FIPS202_NAMESPACE(shake256_squeeze)
+void shake256_squeeze(uint8_t *out, size_t outlen, keccak_state *state);
+#define shake256_absorb_once FIPS202_NAMESPACE(shake256_absorb_once)
+void shake256_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake256_squeezeblocks FIPS202_NAMESPACE(shake256_squeezeblocks)
+void shake256_squeezeblocks(uint8_t *out, size_t nblocks,  keccak_state *state);
+
+#define shake128 FIPS202_NAMESPACE(shake128)
+void shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen);
+#define shake256 FIPS202_NAMESPACE(shake256)
+void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen);
+#define sha3_256 FIPS202_NAMESPACE(sha3_256)
+void sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen);
+#define sha3_512 FIPS202_NAMESPACE(sha3_512)
+void sha3_512(uint8_t h[64], const uint8_t *in, size_t inlen);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.c
new file mode 100644
index 000000000..5ea8b530e
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.c
@@ -0,0 +1,98 @@
+#include <stdint.h>
+#include "params.h"
+#include "ntt.h"
+#include "reduce.h"
+
+static const int32_t zetas[N] = {
+         0,    25847, -2608894,  -518909,   237124,  -777960,  -876248,   466468,
+   1826347,  2353451,  -359251, -2091905,  3119733, -2884855,  3111497,  2680103,
+   2725464,  1024112, -1079900,  3585928,  -549488, -1119584,  2619752, -2108549,
+  -2118186, -3859737, -1399561, -3277672,  1757237,   -19422,  4010497,   280005,
+   2706023,    95776,  3077325,  3530437, -1661693, -3592148, -2537516,  3915439,
+  -3861115, -3043716,  3574422, -2867647,  3539968,  -300467,  2348700,  -539299,
+  -1699267, -1643818,  3505694, -3821735,  3507263, -2140649, -1600420,  3699596,
+    811944,   531354,   954230,  3881043,  3900724, -2556880,  2071892, -2797779,
+  -3930395, -1528703, -3677745, -3041255, -1452451,  3475950,  2176455, -1585221,
+  -1257611,  1939314, -4083598, -1000202, -3190144, -3157330, -3632928,   126922,
+   3412210,  -983419,  2147896,  2715295, -2967645, -3693493,  -411027, -2477047,
+   -671102, -1228525,   -22981, -1308169,  -381987,  1349076,  1852771, -1430430,
+  -3343383,   264944,   508951,  3097992,    44288, -1100098,   904516,  3958618,
+  -3724342,    -8578,  1653064, -3249728,  2389356,  -210977,   759969, -1316856,
+    189548, -3553272,  3159746, -1851402, -2409325,  -177440,  1315589,  1341330,
+   1285669, -1584928,  -812732, -1439742, -3019102, -3881060, -3628969,  3839961,
+   2091667,  3407706,  2316500,  3817976, -3342478,  2244091, -2446433, -3562462,
+    266997,  2434439, -1235728,  3513181, -3520352, -3759364, -1197226, -3193378,
+    900702,  1859098,   909542,   819034,   495491, -1613174,   -43260,  -522500,
+   -655327, -3122442,  2031748,  3207046, -3556995,  -525098,  -768622, -3595838,
+    342297,   286988, -2437823,  4108315,  3437287, -3342277,  1735879,   203044,
+   2842341,  2691481, -2590150,  1265009,  4055324,  1247620,  2486353,  1595974,
+  -3767016,  1250494,  2635921, -3548272, -2994039,  1869119,  1903435, -1050970,
+  -1333058,  1237275, -3318210, -1430225,  -451100,  1312455,  3306115, -1962642,
+  -1279661,  1917081, -2546312, -1374803,  1500165,   777191,  2235880,  3406031,
+   -542412, -2831860, -1671176, -1846953, -2584293, -3724270,   594136, -3776993,
+  -2013608,  2432395,  2454455,  -164721,  1957272,  3369112,   185531, -1207385,
+  -3183426,   162844,  1616392,  3014001,   810149,  1652634, -3694233, -1799107,
+  -3038916,  3523897,  3866901,   269760,  2213111,  -975884,  1717735,   472078,
+   -426683,  1723600, -1803090,  1910376, -1667432, -1104333,  -260646, -3833893,
+  -2939036, -2235985,  -420899, -2286327,   183443,  -976891,  1612842, -3545687,
+   -554416,  3919660,   -48306, -1362209,  3937738,  1400424,  -846154,  1976782
+};
+
+/*************************************************
+* Name:        ntt
+*
+* Description: Forward NTT, in-place. No modular reduction is performed after
+*              additions or subtractions. Output vector is in bitreversed order.
+*
+* Arguments:   - uint32_t p[N]: input/output coefficient array
+**************************************************/
+void ntt(int32_t a[N]) {
+  unsigned int len, start, j, k;
+  int32_t zeta, t;
+
+  k = 0;
+  for(len = 128; len > 0; len >>= 1) {
+    for(start = 0; start < N; start = j + len) {
+      zeta = zetas[++k];
+      for(j = start; j < start + len; ++j) {
+        t = montgomery_reduce((int64_t)zeta * a[j + len]);
+        a[j + len] = a[j] - t;
+        a[j] = a[j] + t;
+      }
+    }
+  }
+}
+
+/*************************************************
+* Name:        invntt_tomont
+*
+* Description: Inverse NTT and multiplication by Montgomery factor 2^32.
+*              In-place. No modular reductions after additions or
+*              subtractions; input coefficients need to be smaller than
+*              Q in absolute value. Output coefficient are smaller than Q in
+*              absolute value.
+*
+* Arguments:   - uint32_t p[N]: input/output coefficient array
+**************************************************/
+void invntt_tomont(int32_t a[N]) {
+  unsigned int start, len, j, k;
+  int32_t t, zeta;
+  const int32_t f = 41978; // mont^2/256
+
+  k = 256;
+  for(len = 1; len < N; len <<= 1) {
+    for(start = 0; start < N; start = j + len) {
+      zeta = -zetas[--k];
+      for(j = start; j < start + len; ++j) {
+        t = a[j];
+        a[j] = t + a[j + len];
+        a[j + len] = t - a[j + len];
+        a[j + len] = montgomery_reduce((int64_t)zeta * a[j + len]);
+      }
+    }
+  }
+
+  for(j = 0; j < N; ++j) {
+    a[j] = montgomery_reduce((int64_t)f * a[j]);
+  }
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.h
new file mode 100644
index 000000000..731132d5c
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/ntt.h
@@ -0,0 +1,13 @@
+#ifndef NTT_H
+#define NTT_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define ntt DILITHIUM_NAMESPACE(ntt)
+void ntt(int32_t a[N]);
+
+#define invntt_tomont DILITHIUM_NAMESPACE(invntt_tomont)
+void invntt_tomont(int32_t a[N]);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.c
new file mode 100644
index 000000000..9de5826cd
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.c
@@ -0,0 +1,237 @@
+#include "params.h"
+#include "packing.h"
+#include "polyvec.h"
+#include "poly.h"
+
+/*************************************************
+* Name:        pack_pk
+*
+* Description: Bit-pack public key pk = (rho, t1).
+*
+* Arguments:   - uint8_t pk[]: output byte array
+*              - const uint8_t rho[]: byte array containing rho
+*              - const polyveck *t1: pointer to vector t1
+**************************************************/
+void pack_pk(uint8_t pk[CRYPTO_PUBLICKEYBYTES],
+             const uint8_t rho[SEEDBYTES],
+             const polyveck *t1)
+{
+  unsigned int i;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    pk[i] = rho[i];
+  pk += SEEDBYTES;
+
+  for(i = 0; i < K; ++i)
+    polyt1_pack(pk + i*POLYT1_PACKEDBYTES, &t1->vec[i]);
+}
+
+/*************************************************
+* Name:        unpack_pk
+*
+* Description: Unpack public key pk = (rho, t1).
+*
+* Arguments:   - const uint8_t rho[]: output byte array for rho
+*              - const polyveck *t1: pointer to output vector t1
+*              - uint8_t pk[]: byte array containing bit-packed pk
+**************************************************/
+void unpack_pk(uint8_t rho[SEEDBYTES],
+               polyveck *t1,
+               const uint8_t pk[CRYPTO_PUBLICKEYBYTES])
+{
+  unsigned int i;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    rho[i] = pk[i];
+  pk += SEEDBYTES;
+
+  for(i = 0; i < K; ++i)
+    polyt1_unpack(&t1->vec[i], pk + i*POLYT1_PACKEDBYTES);
+}
+
+/*************************************************
+* Name:        pack_sk
+*
+* Description: Bit-pack secret key sk = (rho, tr, key, t0, s1, s2).
+*
+* Arguments:   - uint8_t sk[]: output byte array
+*              - const uint8_t rho[]: byte array containing rho
+*              - const uint8_t tr[]: byte array containing tr
+*              - const uint8_t key[]: byte array containing key
+*              - const polyveck *t0: pointer to vector t0
+*              - const polyvecl *s1: pointer to vector s1
+*              - const polyveck *s2: pointer to vector s2
+**************************************************/
+void pack_sk(uint8_t sk[CRYPTO_SECRETKEYBYTES],
+             const uint8_t rho[SEEDBYTES],
+             const uint8_t tr[SEEDBYTES],
+             const uint8_t key[SEEDBYTES],
+             const polyveck *t0,
+             const polyvecl *s1,
+             const polyveck *s2)
+{
+  unsigned int i;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    sk[i] = rho[i];
+  sk += SEEDBYTES;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    sk[i] = key[i];
+  sk += SEEDBYTES;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    sk[i] = tr[i];
+  sk += SEEDBYTES;
+
+  for(i = 0; i < L; ++i)
+    polyeta_pack(sk + i*POLYETA_PACKEDBYTES, &s1->vec[i]);
+  sk += L*POLYETA_PACKEDBYTES;
+
+  for(i = 0; i < K; ++i)
+    polyeta_pack(sk + i*POLYETA_PACKEDBYTES, &s2->vec[i]);
+  sk += K*POLYETA_PACKEDBYTES;
+
+  for(i = 0; i < K; ++i)
+    polyt0_pack(sk + i*POLYT0_PACKEDBYTES, &t0->vec[i]);
+}
+
+/*************************************************
+* Name:        unpack_sk
+*
+* Description: Unpack secret key sk = (rho, tr, key, t0, s1, s2).
+*
+* Arguments:   - const uint8_t rho[]: output byte array for rho
+*              - const uint8_t tr[]: output byte array for tr
+*              - const uint8_t key[]: output byte array for key
+*              - const polyveck *t0: pointer to output vector t0
+*              - const polyvecl *s1: pointer to output vector s1
+*              - const polyveck *s2: pointer to output vector s2
+*              - uint8_t sk[]: byte array containing bit-packed sk
+**************************************************/
+void unpack_sk(uint8_t rho[SEEDBYTES],
+               uint8_t tr[SEEDBYTES],
+               uint8_t key[SEEDBYTES],
+               polyveck *t0,
+               polyvecl *s1,
+               polyveck *s2,
+               const uint8_t sk[CRYPTO_SECRETKEYBYTES])
+{
+  unsigned int i;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    rho[i] = sk[i];
+  sk += SEEDBYTES;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    key[i] = sk[i];
+  sk += SEEDBYTES;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    tr[i] = sk[i];
+  sk += SEEDBYTES;
+
+  for(i=0; i < L; ++i)
+    polyeta_unpack(&s1->vec[i], sk + i*POLYETA_PACKEDBYTES);
+  sk += L*POLYETA_PACKEDBYTES;
+
+  for(i=0; i < K; ++i)
+    polyeta_unpack(&s2->vec[i], sk + i*POLYETA_PACKEDBYTES);
+  sk += K*POLYETA_PACKEDBYTES;
+
+  for(i=0; i < K; ++i)
+    polyt0_unpack(&t0->vec[i], sk + i*POLYT0_PACKEDBYTES);
+}
+
+/*************************************************
+* Name:        pack_sig
+*
+* Description: Bit-pack signature sig = (c, z, h).
+*
+* Arguments:   - uint8_t sig[]: output byte array
+*              - const uint8_t *c: pointer to challenge hash length SEEDBYTES
+*              - const polyvecl *z: pointer to vector z
+*              - const polyveck *h: pointer to hint vector h
+**************************************************/
+void pack_sig(uint8_t sig[CRYPTO_BYTES],
+              const uint8_t c[SEEDBYTES],
+              const polyvecl *z,
+              const polyveck *h)
+{
+  unsigned int i, j, k;
+
+  for(i=0; i < SEEDBYTES; ++i)
+    sig[i] = c[i];
+  sig += SEEDBYTES;
+
+  for(i = 0; i < L; ++i)
+    polyz_pack(sig + i*POLYZ_PACKEDBYTES, &z->vec[i]);
+  sig += L*POLYZ_PACKEDBYTES;
+
+  /* Encode h */
+  for(i = 0; i < OMEGA + K; ++i)
+    sig[i] = 0;
+
+  k = 0;
+  for(i = 0; i < K; ++i) {
+    for(j = 0; j < N; ++j)
+      if(h->vec[i].coeffs[j] != 0)
+        sig[k++] = j;
+
+    sig[OMEGA + i] = k;
+  }
+}
+
+/*************************************************
+* Name:        unpack_sig
+*
+* Description: Unpack signature sig = (c, z, h).
+*
+* Arguments:   - uint8_t *c: pointer to output challenge hash
+*              - polyvecl *z: pointer to output vector z
+*              - polyveck *h: pointer to output hint vector h
+*              - const uint8_t sig[]: byte array containing
+*                bit-packed signature
+*
+* Returns 1 in case of malformed signature; otherwise 0.
+**************************************************/
+int unpack_sig(uint8_t c[SEEDBYTES],
+               polyvecl *z,
+               polyveck *h,
+               const uint8_t sig[CRYPTO_BYTES])
+{
+  unsigned int i, j, k;
+
+  for(i = 0; i < SEEDBYTES; ++i)
+    c[i] = sig[i];
+  sig += SEEDBYTES;
+
+  for(i = 0; i < L; ++i)
+    polyz_unpack(&z->vec[i], sig + i*POLYZ_PACKEDBYTES);
+  sig += L*POLYZ_PACKEDBYTES;
+
+  /* Decode h */
+  k = 0;
+  for(i = 0; i < K; ++i) {
+    for(j = 0; j < N; ++j)
+      h->vec[i].coeffs[j] = 0;
+
+    if(sig[OMEGA + i] < k || sig[OMEGA + i] > OMEGA)
+      return 1;
+
+    for(j = k; j < sig[OMEGA + i]; ++j) {
+      /* Coefficients are ordered for strong unforgeability */
+      if(j > k && sig[j] <= sig[j-1]) return 1;
+      h->vec[i].coeffs[sig[j]] = 1;
+    }
+
+    k = sig[OMEGA + i];
+  }
+
+  /* Extra indices are zero for strong unforgeability */
+  for(j = k; j < OMEGA; ++j)
+    if(sig[j])
+      return 1;
+
+  return 0;
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.h
new file mode 100644
index 000000000..7c7cb6f4c
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/packing.h
@@ -0,0 +1,38 @@
+#ifndef PACKING_H
+#define PACKING_H
+
+#include <stdint.h>
+#include "params.h"
+#include "polyvec.h"
+
+#define pack_pk DILITHIUM_NAMESPACE(pack_pk)
+void pack_pk(uint8_t pk[CRYPTO_PUBLICKEYBYTES], const uint8_t rho[SEEDBYTES], const polyveck *t1);
+
+#define pack_sk DILITHIUM_NAMESPACE(pack_sk)
+void pack_sk(uint8_t sk[CRYPTO_SECRETKEYBYTES],
+             const uint8_t rho[SEEDBYTES],
+             const uint8_t tr[SEEDBYTES],
+             const uint8_t key[SEEDBYTES],
+             const polyveck *t0,
+             const polyvecl *s1,
+             const polyveck *s2);
+
+#define pack_sig DILITHIUM_NAMESPACE(pack_sig)
+void pack_sig(uint8_t sig[CRYPTO_BYTES], const uint8_t c[SEEDBYTES], const polyvecl *z, const polyveck *h);
+
+#define unpack_pk DILITHIUM_NAMESPACE(unpack_pk)
+void unpack_pk(uint8_t rho[SEEDBYTES], polyveck *t1, const uint8_t pk[CRYPTO_PUBLICKEYBYTES]);
+
+#define unpack_sk DILITHIUM_NAMESPACE(unpack_sk)
+void unpack_sk(uint8_t rho[SEEDBYTES],
+               uint8_t tr[SEEDBYTES],
+               uint8_t key[SEEDBYTES],
+               polyveck *t0,
+               polyvecl *s1,
+               polyveck *s2,
+               const uint8_t sk[CRYPTO_SECRETKEYBYTES]);
+
+#define unpack_sig DILITHIUM_NAMESPACE(unpack_sig)
+int unpack_sig(uint8_t c[SEEDBYTES], polyvecl *z, polyveck *h, const uint8_t sig[CRYPTO_BYTES]);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/params.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/params.h
new file mode 100644
index 000000000..63b02e2db
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/params.h
@@ -0,0 +1,74 @@
+#ifndef PARAMS_H
+#define PARAMS_H
+
+#include "config.h"
+
+#define SEEDBYTES 32
+#define CRHBYTES 64
+#define N 256
+#define Q 8380417
+#define D 13
+#define ROOT_OF_UNITY 1753
+
+#if DILITHIUM_MODE == 2
+#define K 4
+#define L 4
+#define ETA 2
+#define TAU 39
+#define BETA 78
+#define GAMMA1 (1 << 17)
+#define GAMMA2 ((Q-1)/88)
+#define OMEGA 80
+
+#elif DILITHIUM_MODE == 3
+#define K 6
+#define L 5
+#define ETA 4
+#define TAU 49
+#define BETA 196
+#define GAMMA1 (1 << 19)
+#define GAMMA2 ((Q-1)/32)
+#define OMEGA 55
+
+#elif DILITHIUM_MODE == 5
+#define K 8
+#define L 7
+#define ETA 2
+#define TAU 60
+#define BETA 120
+#define GAMMA1 (1 << 19)
+#define GAMMA2 ((Q-1)/32)
+#define OMEGA 75
+
+#endif
+
+#define POLYT1_PACKEDBYTES  320
+#define POLYT0_PACKEDBYTES  416
+#define POLYVECH_PACKEDBYTES (OMEGA + K)
+
+#if GAMMA1 == (1 << 17)
+#define POLYZ_PACKEDBYTES   576
+#elif GAMMA1 == (1 << 19)
+#define POLYZ_PACKEDBYTES   640
+#endif
+
+#if GAMMA2 == (Q-1)/88
+#define POLYW1_PACKEDBYTES  192
+#elif GAMMA2 == (Q-1)/32
+#define POLYW1_PACKEDBYTES  128
+#endif
+
+#if ETA == 2
+#define POLYETA_PACKEDBYTES  96
+#elif ETA == 4
+#define POLYETA_PACKEDBYTES 128
+#endif
+
+#define CRYPTO_PUBLICKEYBYTES (SEEDBYTES + K*POLYT1_PACKEDBYTES)
+#define CRYPTO_SECRETKEYBYTES (3*SEEDBYTES \
+                               + L*POLYETA_PACKEDBYTES \
+                               + K*POLYETA_PACKEDBYTES \
+                               + K*POLYT0_PACKEDBYTES)
+#define CRYPTO_BYTES (SEEDBYTES + L*POLYZ_PACKEDBYTES + POLYVECH_PACKEDBYTES)
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.c
new file mode 100644
index 000000000..a6ba0749b
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.c
@@ -0,0 +1,907 @@
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+#include "ntt.h"
+#include "reduce.h"
+#include "rounding.h"
+#include "symmetric.h"
+
+#ifdef DBENCH
+#include "test/cpucycles.h"
+extern const uint64_t timing_overhead;
+extern uint64_t *tred, *tadd, *tmul, *tround, *tsample, *tpack;
+#define DBENCH_START() uint64_t time = cpucycles()
+#define DBENCH_STOP(t) t += cpucycles() - time - timing_overhead
+#else
+#define DBENCH_START()
+#define DBENCH_STOP(t)
+#endif
+
+/*************************************************
+* Name:        poly_reduce
+*
+* Description: Inplace reduction of all coefficients of polynomial to
+*              representative in [-6283009,6283007].
+*
+* Arguments:   - poly *a: pointer to input/output polynomial
+**************************************************/
+void poly_reduce(poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    a->coeffs[i] = reduce32(a->coeffs[i]);
+
+  DBENCH_STOP(*tred);
+}
+
+/*************************************************
+* Name:        poly_caddq
+*
+* Description: For all coefficients of in/out polynomial add Q if
+*              coefficient is negative.
+*
+* Arguments:   - poly *a: pointer to input/output polynomial
+**************************************************/
+void poly_caddq(poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    a->coeffs[i] = caddq(a->coeffs[i]);
+
+  DBENCH_STOP(*tred);
+}
+
+/*************************************************
+* Name:        poly_add
+*
+* Description: Add polynomials. No modular reduction is performed.
+*
+* Arguments:   - poly *c: pointer to output polynomial
+*              - const poly *a: pointer to first summand
+*              - const poly *b: pointer to second summand
+**************************************************/
+void poly_add(poly *c, const poly *a, const poly *b)  {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    c->coeffs[i] = a->coeffs[i] + b->coeffs[i];
+
+  DBENCH_STOP(*tadd);
+}
+
+/*************************************************
+* Name:        poly_sub
+*
+* Description: Subtract polynomials. No modular reduction is
+*              performed.
+*
+* Arguments:   - poly *c: pointer to output polynomial
+*              - const poly *a: pointer to first input polynomial
+*              - const poly *b: pointer to second input polynomial to be
+*                               subtraced from first input polynomial
+**************************************************/
+void poly_sub(poly *c, const poly *a, const poly *b) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    c->coeffs[i] = a->coeffs[i] - b->coeffs[i];
+
+  DBENCH_STOP(*tadd);
+}
+
+/*************************************************
+* Name:        poly_shiftl
+*
+* Description: Multiply polynomial by 2^D without modular reduction. Assumes
+*              input coefficients to be less than 2^{31-D} in absolute value.
+*
+* Arguments:   - poly *a: pointer to input/output polynomial
+**************************************************/
+void poly_shiftl(poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    a->coeffs[i] <<= D;
+
+  DBENCH_STOP(*tmul);
+}
+
+/*************************************************
+* Name:        poly_ntt
+*
+* Description: Inplace forward NTT. Coefficients can grow by
+*              8*Q in absolute value.
+*
+* Arguments:   - poly *a: pointer to input/output polynomial
+**************************************************/
+void poly_ntt(poly *a) {
+  DBENCH_START();
+
+  ntt(a->coeffs);
+
+  DBENCH_STOP(*tmul);
+}
+
+/*************************************************
+* Name:        poly_invntt_tomont
+*
+* Description: Inplace inverse NTT and multiplication by 2^{32}.
+*              Input coefficients need to be less than Q in absolute
+*              value and output coefficients are again bounded by Q.
+*
+* Arguments:   - poly *a: pointer to input/output polynomial
+**************************************************/
+void poly_invntt_tomont(poly *a) {
+  DBENCH_START();
+
+  invntt_tomont(a->coeffs);
+
+  DBENCH_STOP(*tmul);
+}
+
+/*************************************************
+* Name:        poly_pointwise_montgomery
+*
+* Description: Pointwise multiplication of polynomials in NTT domain
+*              representation and multiplication of resulting polynomial
+*              by 2^{-32}.
+*
+* Arguments:   - poly *c: pointer to output polynomial
+*              - const poly *a: pointer to first input polynomial
+*              - const poly *b: pointer to second input polynomial
+**************************************************/
+void poly_pointwise_montgomery(poly *c, const poly *a, const poly *b) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    c->coeffs[i] = montgomery_reduce((int64_t)a->coeffs[i] * b->coeffs[i]);
+
+  DBENCH_STOP(*tmul);
+}
+
+/*************************************************
+* Name:        poly_power2round
+*
+* Description: For all coefficients c of the input polynomial,
+*              compute c0, c1 such that c mod Q = c1*2^D + c0
+*              with -2^{D-1} < c0 <= 2^{D-1}. Assumes coefficients to be
+*              standard representatives.
+*
+* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
+*              - poly *a0: pointer to output polynomial with coefficients c0
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void poly_power2round(poly *a1, poly *a0, const poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    a1->coeffs[i] = power2round(&a0->coeffs[i], a->coeffs[i]);
+
+  DBENCH_STOP(*tround);
+}
+
+/*************************************************
+* Name:        poly_decompose
+*
+* Description: For all coefficients c of the input polynomial,
+*              compute high and low bits c0, c1 such c mod Q = c1*ALPHA + c0
+*              with -ALPHA/2 < c0 <= ALPHA/2 except c1 = (Q-1)/ALPHA where we
+*              set c1 = 0 and -ALPHA/2 <= c0 = c mod Q - Q < 0.
+*              Assumes coefficients to be standard representatives.
+*
+* Arguments:   - poly *a1: pointer to output polynomial with coefficients c1
+*              - poly *a0: pointer to output polynomial with coefficients c0
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void poly_decompose(poly *a1, poly *a0, const poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    a1->coeffs[i] = decompose(&a0->coeffs[i], a->coeffs[i]);
+
+  DBENCH_STOP(*tround);
+}
+
+/*************************************************
+* Name:        poly_make_hint
+*
+* Description: Compute hint polynomial. The coefficients of which indicate
+*              whether the low bits of the corresponding coefficient of
+*              the input polynomial overflow into the high bits.
+*
+* Arguments:   - poly *h: pointer to output hint polynomial
+*              - const poly *a0: pointer to low part of input polynomial
+*              - const poly *a1: pointer to high part of input polynomial
+*
+* Returns number of 1 bits.
+**************************************************/
+unsigned int poly_make_hint(poly *h, const poly *a0, const poly *a1) {
+  unsigned int i, s = 0;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i) {
+    h->coeffs[i] = make_hint(a0->coeffs[i], a1->coeffs[i]);
+    s += h->coeffs[i];
+  }
+
+  DBENCH_STOP(*tround);
+  return s;
+}
+
+/*************************************************
+* Name:        poly_use_hint
+*
+* Description: Use hint polynomial to correct the high bits of a polynomial.
+*
+* Arguments:   - poly *b: pointer to output polynomial with corrected high bits
+*              - const poly *a: pointer to input polynomial
+*              - const poly *h: pointer to input hint polynomial
+**************************************************/
+void poly_use_hint(poly *b, const poly *a, const poly *h) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N; ++i)
+    b->coeffs[i] = use_hint(a->coeffs[i], h->coeffs[i]);
+
+  DBENCH_STOP(*tround);
+}
+
+/*************************************************
+* Name:        poly_chknorm
+*
+* Description: Check infinity norm of polynomial against given bound.
+*              Assumes input coefficients were reduced by reduce32().
+*
+* Arguments:   - const poly *a: pointer to polynomial
+*              - int32_t B: norm bound
+*
+* Returns 0 if norm is strictly smaller than B <= (Q-1)/8 and 1 otherwise.
+**************************************************/
+int poly_chknorm(const poly *a, int32_t B) {
+  unsigned int i;
+  int32_t t;
+  DBENCH_START();
+
+  if(B > (Q-1)/8)
+    return 1;
+
+  /* It is ok to leak which coefficient violates the bound since
+     the probability for each coefficient is independent of secret
+     data but we must not leak the sign of the centralized representative. */
+  for(i = 0; i < N; ++i) {
+    /* Absolute value */
+    t = a->coeffs[i] >> 31;
+    t = a->coeffs[i] - (t & 2*a->coeffs[i]);
+
+    if(t >= B) {
+      DBENCH_STOP(*tsample);
+      return 1;
+    }
+  }
+
+  DBENCH_STOP(*tsample);
+  return 0;
+}
+
+/*************************************************
+* Name:        rej_uniform
+*
+* Description: Sample uniformly random coefficients in [0, Q-1] by
+*              performing rejection sampling on array of random bytes.
+*
+* Arguments:   - int32_t *a: pointer to output array (allocated)
+*              - unsigned int len: number of coefficients to be sampled
+*              - const uint8_t *buf: array of random bytes
+*              - unsigned int buflen: length of array of random bytes
+*
+* Returns number of sampled coefficients. Can be smaller than len if not enough
+* random bytes were given.
+**************************************************/
+static unsigned int rej_uniform(int32_t *a,
+                                unsigned int len,
+                                const uint8_t *buf,
+                                unsigned int buflen)
+{
+  unsigned int ctr, pos;
+  uint32_t t;
+  DBENCH_START();
+
+  ctr = pos = 0;
+  while(ctr < len && pos + 3 <= buflen) {
+    t  = buf[pos++];
+    t |= (uint32_t)buf[pos++] << 8;
+    t |= (uint32_t)buf[pos++] << 16;
+    t &= 0x7FFFFF;
+
+    if(t < Q)
+      a[ctr++] = t;
+  }
+
+  DBENCH_STOP(*tsample);
+  return ctr;
+}
+
+/*************************************************
+* Name:        poly_uniform
+*
+* Description: Sample polynomial with uniformly random coefficients
+*              in [0,Q-1] by performing rejection sampling on the
+*              output stream of SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
+*
+* Arguments:   - poly *a: pointer to output polynomial
+*              - const uint8_t seed[]: byte array with seed of length SEEDBYTES
+*              - uint16_t nonce: 2-byte nonce
+**************************************************/
+#define POLY_UNIFORM_NBLOCKS ((768 + STREAM128_BLOCKBYTES - 1)/STREAM128_BLOCKBYTES)
+void poly_uniform(poly *a,
+                  const uint8_t seed[SEEDBYTES],
+                  uint16_t nonce)
+{
+  unsigned int i, ctr, off;
+  unsigned int buflen = POLY_UNIFORM_NBLOCKS*STREAM128_BLOCKBYTES;
+  uint8_t buf[POLY_UNIFORM_NBLOCKS*STREAM128_BLOCKBYTES + 2];
+  stream128_state state;
+
+  stream128_init(&state, seed, nonce);
+  stream128_squeezeblocks(buf, POLY_UNIFORM_NBLOCKS, &state);
+
+  ctr = rej_uniform(a->coeffs, N, buf, buflen);
+
+  while(ctr < N) {
+    off = buflen % 3;
+    for(i = 0; i < off; ++i)
+      buf[i] = buf[buflen - off + i];
+
+    stream128_squeezeblocks(buf + off, 1, &state);
+    buflen = STREAM128_BLOCKBYTES + off;
+    ctr += rej_uniform(a->coeffs + ctr, N - ctr, buf, buflen);
+  }
+}
+
+/*************************************************
+* Name:        rej_eta
+*
+* Description: Sample uniformly random coefficients in [-ETA, ETA] by
+*              performing rejection sampling on array of random bytes.
+*
+* Arguments:   - int32_t *a: pointer to output array (allocated)
+*              - unsigned int len: number of coefficients to be sampled
+*              - const uint8_t *buf: array of random bytes
+*              - unsigned int buflen: length of array of random bytes
+*
+* Returns number of sampled coefficients. Can be smaller than len if not enough
+* random bytes were given.
+**************************************************/
+static unsigned int rej_eta(int32_t *a,
+                            unsigned int len,
+                            const uint8_t *buf,
+                            unsigned int buflen)
+{
+  unsigned int ctr, pos;
+  uint32_t t0, t1;
+  DBENCH_START();
+
+  ctr = pos = 0;
+  while(ctr < len && pos < buflen) {
+    t0 = buf[pos] & 0x0F;
+    t1 = buf[pos++] >> 4;
+
+#if ETA == 2
+    if(t0 < 15) {
+      t0 = t0 - (205*t0 >> 10)*5;
+      a[ctr++] = 2 - t0;
+    }
+    if(t1 < 15 && ctr < len) {
+      t1 = t1 - (205*t1 >> 10)*5;
+      a[ctr++] = 2 - t1;
+    }
+#elif ETA == 4
+    if(t0 < 9)
+      a[ctr++] = 4 - t0;
+    if(t1 < 9 && ctr < len)
+      a[ctr++] = 4 - t1;
+#endif
+  }
+
+  DBENCH_STOP(*tsample);
+  return ctr;
+}
+
+/*************************************************
+* Name:        poly_uniform_eta
+*
+* Description: Sample polynomial with uniformly random coefficients
+*              in [-ETA,ETA] by performing rejection sampling on the
+*              output stream from SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
+*
+* Arguments:   - poly *a: pointer to output polynomial
+*              - const uint8_t seed[]: byte array with seed of length CRHBYTES
+*              - uint16_t nonce: 2-byte nonce
+**************************************************/
+#if ETA == 2
+#define POLY_UNIFORM_ETA_NBLOCKS ((136 + STREAM256_BLOCKBYTES - 1)/STREAM256_BLOCKBYTES)
+#elif ETA == 4
+#define POLY_UNIFORM_ETA_NBLOCKS ((227 + STREAM256_BLOCKBYTES - 1)/STREAM256_BLOCKBYTES)
+#endif
+void poly_uniform_eta(poly *a,
+                      const uint8_t seed[CRHBYTES],
+                      uint16_t nonce)
+{
+  unsigned int ctr;
+  unsigned int buflen = POLY_UNIFORM_ETA_NBLOCKS*STREAM256_BLOCKBYTES;
+  uint8_t buf[POLY_UNIFORM_ETA_NBLOCKS*STREAM256_BLOCKBYTES];
+  stream256_state state;
+
+  stream256_init(&state, seed, nonce);
+  stream256_squeezeblocks(buf, POLY_UNIFORM_ETA_NBLOCKS, &state);
+
+  ctr = rej_eta(a->coeffs, N, buf, buflen);
+
+  while(ctr < N) {
+    stream256_squeezeblocks(buf, 1, &state);
+    ctr += rej_eta(a->coeffs + ctr, N - ctr, buf, STREAM256_BLOCKBYTES);
+  }
+}
+
+/*************************************************
+* Name:        poly_uniform_gamma1m1
+*
+* Description: Sample polynomial with uniformly random coefficients
+*              in [-(GAMMA1 - 1), GAMMA1] by unpacking output stream
+*              of SHAKE256(seed|nonce) or AES256CTR(seed,nonce).
+*
+* Arguments:   - poly *a: pointer to output polynomial
+*              - const uint8_t seed[]: byte array with seed of length CRHBYTES
+*              - uint16_t nonce: 16-bit nonce
+**************************************************/
+#define POLY_UNIFORM_GAMMA1_NBLOCKS ((POLYZ_PACKEDBYTES + STREAM256_BLOCKBYTES - 1)/STREAM256_BLOCKBYTES)
+void poly_uniform_gamma1(poly *a,
+                         const uint8_t seed[CRHBYTES],
+                         uint16_t nonce)
+{
+  uint8_t buf[POLY_UNIFORM_GAMMA1_NBLOCKS*STREAM256_BLOCKBYTES];
+  stream256_state state;
+
+  stream256_init(&state, seed, nonce);
+  stream256_squeezeblocks(buf, POLY_UNIFORM_GAMMA1_NBLOCKS, &state);
+  polyz_unpack(a, buf);
+}
+
+/*************************************************
+* Name:        challenge
+*
+* Description: Implementation of H. Samples polynomial with TAU nonzero
+*              coefficients in {-1,1} using the output stream of
+*              SHAKE256(seed).
+*
+* Arguments:   - poly *c: pointer to output polynomial
+*              - const uint8_t mu[]: byte array containing seed of length SEEDBYTES
+**************************************************/
+void poly_challenge(poly *c, const uint8_t seed[SEEDBYTES]) {
+  unsigned int i, b, pos;
+  uint64_t signs;
+  uint8_t buf[SHAKE256_RATE];
+  keccak_state state;
+
+  shake256_init(&state);
+  shake256_absorb(&state, seed, SEEDBYTES);
+  shake256_finalize(&state);
+  shake256_squeezeblocks(buf, 1, &state);
+
+  signs = 0;
+  for(i = 0; i < 8; ++i)
+    signs |= (uint64_t)buf[i] << 8*i;
+  pos = 8;
+
+  for(i = 0; i < N; ++i)
+    c->coeffs[i] = 0;
+  for(i = N-TAU; i < N; ++i) {
+    do {
+      if(pos >= SHAKE256_RATE) {
+        shake256_squeezeblocks(buf, 1, &state);
+        pos = 0;
+      }
+
+      b = buf[pos++];
+    } while(b > i);
+
+    c->coeffs[i] = c->coeffs[b];
+    c->coeffs[b] = 1 - 2*(signs & 1);
+    signs >>= 1;
+  }
+}
+
+/*************************************************
+* Name:        polyeta_pack
+*
+* Description: Bit-pack polynomial with coefficients in [-ETA,ETA].
+*
+* Arguments:   - uint8_t *r: pointer to output byte array with at least
+*                            POLYETA_PACKEDBYTES bytes
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void polyeta_pack(uint8_t *r, const poly *a) {
+  unsigned int i;
+  uint8_t t[8];
+  DBENCH_START();
+
+#if ETA == 2
+  for(i = 0; i < N/8; ++i) {
+    t[0] = ETA - a->coeffs[8*i+0];
+    t[1] = ETA - a->coeffs[8*i+1];
+    t[2] = ETA - a->coeffs[8*i+2];
+    t[3] = ETA - a->coeffs[8*i+3];
+    t[4] = ETA - a->coeffs[8*i+4];
+    t[5] = ETA - a->coeffs[8*i+5];
+    t[6] = ETA - a->coeffs[8*i+6];
+    t[7] = ETA - a->coeffs[8*i+7];
+
+    r[3*i+0]  = (t[0] >> 0) | (t[1] << 3) | (t[2] << 6);
+    r[3*i+1]  = (t[2] >> 2) | (t[3] << 1) | (t[4] << 4) | (t[5] << 7);
+    r[3*i+2]  = (t[5] >> 1) | (t[6] << 2) | (t[7] << 5);
+  }
+#elif ETA == 4
+  for(i = 0; i < N/2; ++i) {
+    t[0] = ETA - a->coeffs[2*i+0];
+    t[1] = ETA - a->coeffs[2*i+1];
+    r[i] = t[0] | (t[1] << 4);
+  }
+#endif
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyeta_unpack
+*
+* Description: Unpack polynomial with coefficients in [-ETA,ETA].
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: byte array with bit-packed polynomial
+**************************************************/
+void polyeta_unpack(poly *r, const uint8_t *a) {
+  unsigned int i;
+  DBENCH_START();
+
+#if ETA == 2
+  for(i = 0; i < N/8; ++i) {
+    r->coeffs[8*i+0] =  (a[3*i+0] >> 0) & 7;
+    r->coeffs[8*i+1] =  (a[3*i+0] >> 3) & 7;
+    r->coeffs[8*i+2] = ((a[3*i+0] >> 6) | (a[3*i+1] << 2)) & 7;
+    r->coeffs[8*i+3] =  (a[3*i+1] >> 1) & 7;
+    r->coeffs[8*i+4] =  (a[3*i+1] >> 4) & 7;
+    r->coeffs[8*i+5] = ((a[3*i+1] >> 7) | (a[3*i+2] << 1)) & 7;
+    r->coeffs[8*i+6] =  (a[3*i+2] >> 2) & 7;
+    r->coeffs[8*i+7] =  (a[3*i+2] >> 5) & 7;
+
+    r->coeffs[8*i+0] = ETA - r->coeffs[8*i+0];
+    r->coeffs[8*i+1] = ETA - r->coeffs[8*i+1];
+    r->coeffs[8*i+2] = ETA - r->coeffs[8*i+2];
+    r->coeffs[8*i+3] = ETA - r->coeffs[8*i+3];
+    r->coeffs[8*i+4] = ETA - r->coeffs[8*i+4];
+    r->coeffs[8*i+5] = ETA - r->coeffs[8*i+5];
+    r->coeffs[8*i+6] = ETA - r->coeffs[8*i+6];
+    r->coeffs[8*i+7] = ETA - r->coeffs[8*i+7];
+  }
+#elif ETA == 4
+  for(i = 0; i < N/2; ++i) {
+    r->coeffs[2*i+0] = a[i] & 0x0F;
+    r->coeffs[2*i+1] = a[i] >> 4;
+    r->coeffs[2*i+0] = ETA - r->coeffs[2*i+0];
+    r->coeffs[2*i+1] = ETA - r->coeffs[2*i+1];
+  }
+#endif
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyt1_pack
+*
+* Description: Bit-pack polynomial t1 with coefficients fitting in 10 bits.
+*              Input coefficients are assumed to be standard representatives.
+*
+* Arguments:   - uint8_t *r: pointer to output byte array with at least
+*                            POLYT1_PACKEDBYTES bytes
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void polyt1_pack(uint8_t *r, const poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N/4; ++i) {
+    r[5*i+0] = (a->coeffs[4*i+0] >> 0);
+    r[5*i+1] = (a->coeffs[4*i+0] >> 8) | (a->coeffs[4*i+1] << 2);
+    r[5*i+2] = (a->coeffs[4*i+1] >> 6) | (a->coeffs[4*i+2] << 4);
+    r[5*i+3] = (a->coeffs[4*i+2] >> 4) | (a->coeffs[4*i+3] << 6);
+    r[5*i+4] = (a->coeffs[4*i+3] >> 2);
+  }
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyt1_unpack
+*
+* Description: Unpack polynomial t1 with 10-bit coefficients.
+*              Output coefficients are standard representatives.
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: byte array with bit-packed polynomial
+**************************************************/
+void polyt1_unpack(poly *r, const uint8_t *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N/4; ++i) {
+    r->coeffs[4*i+0] = ((a[5*i+0] >> 0) | ((uint32_t)a[5*i+1] << 8)) & 0x3FF;
+    r->coeffs[4*i+1] = ((a[5*i+1] >> 2) | ((uint32_t)a[5*i+2] << 6)) & 0x3FF;
+    r->coeffs[4*i+2] = ((a[5*i+2] >> 4) | ((uint32_t)a[5*i+3] << 4)) & 0x3FF;
+    r->coeffs[4*i+3] = ((a[5*i+3] >> 6) | ((uint32_t)a[5*i+4] << 2)) & 0x3FF;
+  }
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyt0_pack
+*
+* Description: Bit-pack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
+*
+* Arguments:   - uint8_t *r: pointer to output byte array with at least
+*                            POLYT0_PACKEDBYTES bytes
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void polyt0_pack(uint8_t *r, const poly *a) {
+  unsigned int i;
+  uint32_t t[8];
+  DBENCH_START();
+
+  for(i = 0; i < N/8; ++i) {
+    t[0] = (1 << (D-1)) - a->coeffs[8*i+0];
+    t[1] = (1 << (D-1)) - a->coeffs[8*i+1];
+    t[2] = (1 << (D-1)) - a->coeffs[8*i+2];
+    t[3] = (1 << (D-1)) - a->coeffs[8*i+3];
+    t[4] = (1 << (D-1)) - a->coeffs[8*i+4];
+    t[5] = (1 << (D-1)) - a->coeffs[8*i+5];
+    t[6] = (1 << (D-1)) - a->coeffs[8*i+6];
+    t[7] = (1 << (D-1)) - a->coeffs[8*i+7];
+
+    r[13*i+ 0]  =  t[0];
+    r[13*i+ 1]  =  t[0] >>  8;
+    r[13*i+ 1] |=  t[1] <<  5;
+    r[13*i+ 2]  =  t[1] >>  3;
+    r[13*i+ 3]  =  t[1] >> 11;
+    r[13*i+ 3] |=  t[2] <<  2;
+    r[13*i+ 4]  =  t[2] >>  6;
+    r[13*i+ 4] |=  t[3] <<  7;
+    r[13*i+ 5]  =  t[3] >>  1;
+    r[13*i+ 6]  =  t[3] >>  9;
+    r[13*i+ 6] |=  t[4] <<  4;
+    r[13*i+ 7]  =  t[4] >>  4;
+    r[13*i+ 8]  =  t[4] >> 12;
+    r[13*i+ 8] |=  t[5] <<  1;
+    r[13*i+ 9]  =  t[5] >>  7;
+    r[13*i+ 9] |=  t[6] <<  6;
+    r[13*i+10]  =  t[6] >>  2;
+    r[13*i+11]  =  t[6] >> 10;
+    r[13*i+11] |=  t[7] <<  3;
+    r[13*i+12]  =  t[7] >>  5;
+  }
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyt0_unpack
+*
+* Description: Unpack polynomial t0 with coefficients in ]-2^{D-1}, 2^{D-1}].
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: byte array with bit-packed polynomial
+**************************************************/
+void polyt0_unpack(poly *r, const uint8_t *a) {
+  unsigned int i;
+  DBENCH_START();
+
+  for(i = 0; i < N/8; ++i) {
+    r->coeffs[8*i+0]  = a[13*i+0];
+    r->coeffs[8*i+0] |= (uint32_t)a[13*i+1] << 8;
+    r->coeffs[8*i+0] &= 0x1FFF;
+
+    r->coeffs[8*i+1]  = a[13*i+1] >> 5;
+    r->coeffs[8*i+1] |= (uint32_t)a[13*i+2] << 3;
+    r->coeffs[8*i+1] |= (uint32_t)a[13*i+3] << 11;
+    r->coeffs[8*i+1] &= 0x1FFF;
+
+    r->coeffs[8*i+2]  = a[13*i+3] >> 2;
+    r->coeffs[8*i+2] |= (uint32_t)a[13*i+4] << 6;
+    r->coeffs[8*i+2] &= 0x1FFF;
+
+    r->coeffs[8*i+3]  = a[13*i+4] >> 7;
+    r->coeffs[8*i+3] |= (uint32_t)a[13*i+5] << 1;
+    r->coeffs[8*i+3] |= (uint32_t)a[13*i+6] << 9;
+    r->coeffs[8*i+3] &= 0x1FFF;
+
+    r->coeffs[8*i+4]  = a[13*i+6] >> 4;
+    r->coeffs[8*i+4] |= (uint32_t)a[13*i+7] << 4;
+    r->coeffs[8*i+4] |= (uint32_t)a[13*i+8] << 12;
+    r->coeffs[8*i+4] &= 0x1FFF;
+
+    r->coeffs[8*i+5]  = a[13*i+8] >> 1;
+    r->coeffs[8*i+5] |= (uint32_t)a[13*i+9] << 7;
+    r->coeffs[8*i+5] &= 0x1FFF;
+
+    r->coeffs[8*i+6]  = a[13*i+9] >> 6;
+    r->coeffs[8*i+6] |= (uint32_t)a[13*i+10] << 2;
+    r->coeffs[8*i+6] |= (uint32_t)a[13*i+11] << 10;
+    r->coeffs[8*i+6] &= 0x1FFF;
+
+    r->coeffs[8*i+7]  = a[13*i+11] >> 3;
+    r->coeffs[8*i+7] |= (uint32_t)a[13*i+12] << 5;
+    r->coeffs[8*i+7] &= 0x1FFF;
+
+    r->coeffs[8*i+0] = (1 << (D-1)) - r->coeffs[8*i+0];
+    r->coeffs[8*i+1] = (1 << (D-1)) - r->coeffs[8*i+1];
+    r->coeffs[8*i+2] = (1 << (D-1)) - r->coeffs[8*i+2];
+    r->coeffs[8*i+3] = (1 << (D-1)) - r->coeffs[8*i+3];
+    r->coeffs[8*i+4] = (1 << (D-1)) - r->coeffs[8*i+4];
+    r->coeffs[8*i+5] = (1 << (D-1)) - r->coeffs[8*i+5];
+    r->coeffs[8*i+6] = (1 << (D-1)) - r->coeffs[8*i+6];
+    r->coeffs[8*i+7] = (1 << (D-1)) - r->coeffs[8*i+7];
+  }
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyz_pack
+*
+* Description: Bit-pack polynomial with coefficients
+*              in [-(GAMMA1 - 1), GAMMA1].
+*
+* Arguments:   - uint8_t *r: pointer to output byte array with at least
+*                            POLYZ_PACKEDBYTES bytes
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void polyz_pack(uint8_t *r, const poly *a) {
+  unsigned int i;
+  uint32_t t[4];
+  DBENCH_START();
+
+#if GAMMA1 == (1 << 17)
+  for(i = 0; i < N/4; ++i) {
+    t[0] = GAMMA1 - a->coeffs[4*i+0];
+    t[1] = GAMMA1 - a->coeffs[4*i+1];
+    t[2] = GAMMA1 - a->coeffs[4*i+2];
+    t[3] = GAMMA1 - a->coeffs[4*i+3];
+
+    r[9*i+0]  = t[0];
+    r[9*i+1]  = t[0] >> 8;
+    r[9*i+2]  = t[0] >> 16;
+    r[9*i+2] |= t[1] << 2;
+    r[9*i+3]  = t[1] >> 6;
+    r[9*i+4]  = t[1] >> 14;
+    r[9*i+4] |= t[2] << 4;
+    r[9*i+5]  = t[2] >> 4;
+    r[9*i+6]  = t[2] >> 12;
+    r[9*i+6] |= t[3] << 6;
+    r[9*i+7]  = t[3] >> 2;
+    r[9*i+8]  = t[3] >> 10;
+  }
+#elif GAMMA1 == (1 << 19)
+  for(i = 0; i < N/2; ++i) {
+    t[0] = GAMMA1 - a->coeffs[2*i+0];
+    t[1] = GAMMA1 - a->coeffs[2*i+1];
+
+    r[5*i+0]  = t[0];
+    r[5*i+1]  = t[0] >> 8;
+    r[5*i+2]  = t[0] >> 16;
+    r[5*i+2] |= t[1] << 4;
+    r[5*i+3]  = t[1] >> 4;
+    r[5*i+4]  = t[1] >> 12;
+  }
+#endif
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyz_unpack
+*
+* Description: Unpack polynomial z with coefficients
+*              in [-(GAMMA1 - 1), GAMMA1].
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: byte array with bit-packed polynomial
+**************************************************/
+void polyz_unpack(poly *r, const uint8_t *a) {
+  unsigned int i;
+  DBENCH_START();
+
+#if GAMMA1 == (1 << 17)
+  for(i = 0; i < N/4; ++i) {
+    r->coeffs[4*i+0]  = a[9*i+0];
+    r->coeffs[4*i+0] |= (uint32_t)a[9*i+1] << 8;
+    r->coeffs[4*i+0] |= (uint32_t)a[9*i+2] << 16;
+    r->coeffs[4*i+0] &= 0x3FFFF;
+
+    r->coeffs[4*i+1]  = a[9*i+2] >> 2;
+    r->coeffs[4*i+1] |= (uint32_t)a[9*i+3] << 6;
+    r->coeffs[4*i+1] |= (uint32_t)a[9*i+4] << 14;
+    r->coeffs[4*i+1] &= 0x3FFFF;
+
+    r->coeffs[4*i+2]  = a[9*i+4] >> 4;
+    r->coeffs[4*i+2] |= (uint32_t)a[9*i+5] << 4;
+    r->coeffs[4*i+2] |= (uint32_t)a[9*i+6] << 12;
+    r->coeffs[4*i+2] &= 0x3FFFF;
+
+    r->coeffs[4*i+3]  = a[9*i+6] >> 6;
+    r->coeffs[4*i+3] |= (uint32_t)a[9*i+7] << 2;
+    r->coeffs[4*i+3] |= (uint32_t)a[9*i+8] << 10;
+    r->coeffs[4*i+3] &= 0x3FFFF;
+
+    r->coeffs[4*i+0] = GAMMA1 - r->coeffs[4*i+0];
+    r->coeffs[4*i+1] = GAMMA1 - r->coeffs[4*i+1];
+    r->coeffs[4*i+2] = GAMMA1 - r->coeffs[4*i+2];
+    r->coeffs[4*i+3] = GAMMA1 - r->coeffs[4*i+3];
+  }
+#elif GAMMA1 == (1 << 19)
+  for(i = 0; i < N/2; ++i) {
+    r->coeffs[2*i+0]  = a[5*i+0];
+    r->coeffs[2*i+0] |= (uint32_t)a[5*i+1] << 8;
+    r->coeffs[2*i+0] |= (uint32_t)a[5*i+2] << 16;
+    r->coeffs[2*i+0] &= 0xFFFFF;
+
+    r->coeffs[2*i+1]  = a[5*i+2] >> 4;
+    r->coeffs[2*i+1] |= (uint32_t)a[5*i+3] << 4;
+    r->coeffs[2*i+1] |= (uint32_t)a[5*i+4] << 12;
+    r->coeffs[2*i+0] &= 0xFFFFF;
+
+    r->coeffs[2*i+0] = GAMMA1 - r->coeffs[2*i+0];
+    r->coeffs[2*i+1] = GAMMA1 - r->coeffs[2*i+1];
+  }
+#endif
+
+  DBENCH_STOP(*tpack);
+}
+
+/*************************************************
+* Name:        polyw1_pack
+*
+* Description: Bit-pack polynomial w1 with coefficients in [0,15] or [0,43].
+*              Input coefficients are assumed to be standard representatives.
+*
+* Arguments:   - uint8_t *r: pointer to output byte array with at least
+*                            POLYW1_PACKEDBYTES bytes
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void polyw1_pack(uint8_t *r, const poly *a) {
+  unsigned int i;
+  DBENCH_START();
+
+#if GAMMA2 == (Q-1)/88
+  for(i = 0; i < N/4; ++i) {
+    r[3*i+0]  = a->coeffs[4*i+0];
+    r[3*i+0] |= a->coeffs[4*i+1] << 6;
+    r[3*i+1]  = a->coeffs[4*i+1] >> 2;
+    r[3*i+1] |= a->coeffs[4*i+2] << 4;
+    r[3*i+2]  = a->coeffs[4*i+2] >> 4;
+    r[3*i+2] |= a->coeffs[4*i+3] << 2;
+  }
+#elif GAMMA2 == (Q-1)/32
+  for(i = 0; i < N/2; ++i)
+    r[i] = a->coeffs[2*i+0] | (a->coeffs[2*i+1] << 4);
+#endif
+
+  DBENCH_STOP(*tpack);
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.h
new file mode 100644
index 000000000..d2fd989b6
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/poly.h
@@ -0,0 +1,79 @@
+#ifndef POLY_H
+#define POLY_H
+
+#include <stdint.h>
+#include "params.h"
+
+typedef struct {
+  int32_t coeffs[N];
+} poly;
+
+#define poly_reduce DILITHIUM_NAMESPACE(poly_reduce)
+void poly_reduce(poly *a);
+#define poly_caddq DILITHIUM_NAMESPACE(poly_caddq)
+void poly_caddq(poly *a);
+
+#define poly_add DILITHIUM_NAMESPACE(poly_add)
+void poly_add(poly *c, const poly *a, const poly *b);
+#define poly_sub DILITHIUM_NAMESPACE(poly_sub)
+void poly_sub(poly *c, const poly *a, const poly *b);
+#define poly_shiftl DILITHIUM_NAMESPACE(poly_shiftl)
+void poly_shiftl(poly *a);
+
+#define poly_ntt DILITHIUM_NAMESPACE(poly_ntt)
+void poly_ntt(poly *a);
+#define poly_invntt_tomont DILITHIUM_NAMESPACE(poly_invntt_tomont)
+void poly_invntt_tomont(poly *a);
+#define poly_pointwise_montgomery DILITHIUM_NAMESPACE(poly_pointwise_montgomery)
+void poly_pointwise_montgomery(poly *c, const poly *a, const poly *b);
+
+#define poly_power2round DILITHIUM_NAMESPACE(poly_power2round)
+void poly_power2round(poly *a1, poly *a0, const poly *a);
+#define poly_decompose DILITHIUM_NAMESPACE(poly_decompose)
+void poly_decompose(poly *a1, poly *a0, const poly *a);
+#define poly_make_hint DILITHIUM_NAMESPACE(poly_make_hint)
+unsigned int poly_make_hint(poly *h, const poly *a0, const poly *a1);
+#define poly_use_hint DILITHIUM_NAMESPACE(poly_use_hint)
+void poly_use_hint(poly *b, const poly *a, const poly *h);
+
+#define poly_chknorm DILITHIUM_NAMESPACE(poly_chknorm)
+int poly_chknorm(const poly *a, int32_t B);
+#define poly_uniform DILITHIUM_NAMESPACE(poly_uniform)
+void poly_uniform(poly *a,
+                  const uint8_t seed[SEEDBYTES],
+                  uint16_t nonce);
+#define poly_uniform_eta DILITHIUM_NAMESPACE(poly_uniform_eta)
+void poly_uniform_eta(poly *a,
+                      const uint8_t seed[CRHBYTES],
+                      uint16_t nonce);
+#define poly_uniform_gamma1 DILITHIUM_NAMESPACE(poly_uniform_gamma1)
+void poly_uniform_gamma1(poly *a,
+                         const uint8_t seed[CRHBYTES],
+                         uint16_t nonce);
+#define poly_challenge DILITHIUM_NAMESPACE(poly_challenge)
+void poly_challenge(poly *c, const uint8_t seed[SEEDBYTES]);
+
+#define polyeta_pack DILITHIUM_NAMESPACE(polyeta_pack)
+void polyeta_pack(uint8_t *r, const poly *a);
+#define polyeta_unpack DILITHIUM_NAMESPACE(polyeta_unpack)
+void polyeta_unpack(poly *r, const uint8_t *a);
+
+#define polyt1_pack DILITHIUM_NAMESPACE(polyt1_pack)
+void polyt1_pack(uint8_t *r, const poly *a);
+#define polyt1_unpack DILITHIUM_NAMESPACE(polyt1_unpack)
+void polyt1_unpack(poly *r, const uint8_t *a);
+
+#define polyt0_pack DILITHIUM_NAMESPACE(polyt0_pack)
+void polyt0_pack(uint8_t *r, const poly *a);
+#define polyt0_unpack DILITHIUM_NAMESPACE(polyt0_unpack)
+void polyt0_unpack(poly *r, const uint8_t *a);
+
+#define polyz_pack DILITHIUM_NAMESPACE(polyz_pack)
+void polyz_pack(uint8_t *r, const poly *a);
+#define polyz_unpack DILITHIUM_NAMESPACE(polyz_unpack)
+void polyz_unpack(poly *r, const uint8_t *a);
+
+#define polyw1_pack DILITHIUM_NAMESPACE(polyw1_pack)
+void polyw1_pack(uint8_t *r, const poly *a);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.c
new file mode 100644
index 000000000..c4e9037ab
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.c
@@ -0,0 +1,390 @@
+#include <stdint.h>
+#include "params.h"
+#include "polyvec.h"
+#include "poly.h"
+
+/*************************************************
+* Name:        expand_mat
+*
+* Description: Implementation of ExpandA. Generates matrix A with uniformly
+*              random coefficients a_{i,j} by performing rejection
+*              sampling on the output stream of SHAKE128(rho|j|i)
+*              or AES256CTR(rho,j|i).
+*
+* Arguments:   - polyvecl mat[K]: output matrix
+*              - const uint8_t rho[]: byte array containing seed rho
+**************************************************/
+void polyvec_matrix_expand(polyvecl mat[K], const uint8_t rho[SEEDBYTES]) {
+  unsigned int i, j;
+
+  for(i = 0; i < K; ++i)
+    for(j = 0; j < L; ++j)
+      poly_uniform(&mat[i].vec[j], rho, (i << 8) + j);
+}
+
+void polyvec_matrix_pointwise_montgomery(polyveck *t, const polyvecl mat[K], const polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    polyvecl_pointwise_acc_montgomery(&t->vec[i], &mat[i], v);
+}
+
+/**************************************************************/
+/************ Vectors of polynomials of length L **************/
+/**************************************************************/
+
+void polyvecl_uniform_eta(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_uniform_eta(&v->vec[i], seed, nonce++);
+}
+
+void polyvecl_uniform_gamma1(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_uniform_gamma1(&v->vec[i], seed, L*nonce + i);
+}
+
+void polyvecl_reduce(polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_reduce(&v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvecl_add
+*
+* Description: Add vectors of polynomials of length L.
+*              No modular reduction is performed.
+*
+* Arguments:   - polyvecl *w: pointer to output vector
+*              - const polyvecl *u: pointer to first summand
+*              - const polyvecl *v: pointer to second summand
+**************************************************/
+void polyvecl_add(polyvecl *w, const polyvecl *u, const polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvecl_ntt
+*
+* Description: Forward NTT of all polynomials in vector of length L. Output
+*              coefficients can be up to 16*Q larger than input coefficients.
+*
+* Arguments:   - polyvecl *v: pointer to input/output vector
+**************************************************/
+void polyvecl_ntt(polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_ntt(&v->vec[i]);
+}
+
+void polyvecl_invntt_tomont(polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_invntt_tomont(&v->vec[i]);
+}
+
+void polyvecl_pointwise_poly_montgomery(polyvecl *r, const poly *a, const polyvecl *v) {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    poly_pointwise_montgomery(&r->vec[i], a, &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvecl_pointwise_acc_montgomery
+*
+* Description: Pointwise multiply vectors of polynomials of length L, multiply
+*              resulting vector by 2^{-32} and add (accumulate) polynomials
+*              in it. Input/output vectors are in NTT domain representation.
+*
+* Arguments:   - poly *w: output polynomial
+*              - const polyvecl *u: pointer to first input vector
+*              - const polyvecl *v: pointer to second input vector
+**************************************************/
+void polyvecl_pointwise_acc_montgomery(poly *w,
+                                       const polyvecl *u,
+                                       const polyvecl *v)
+{
+  unsigned int i;
+  poly t;
+
+  poly_pointwise_montgomery(w, &u->vec[0], &v->vec[0]);
+  for(i = 1; i < L; ++i) {
+    poly_pointwise_montgomery(&t, &u->vec[i], &v->vec[i]);
+    poly_add(w, w, &t);
+  }
+}
+
+/*************************************************
+* Name:        polyvecl_chknorm
+*
+* Description: Check infinity norm of polynomials in vector of length L.
+*              Assumes input polyvecl to be reduced by polyvecl_reduce().
+*
+* Arguments:   - const polyvecl *v: pointer to vector
+*              - int32_t B: norm bound
+*
+* Returns 0 if norm of all polynomials is strictly smaller than B <= (Q-1)/8
+* and 1 otherwise.
+**************************************************/
+int polyvecl_chknorm(const polyvecl *v, int32_t bound)  {
+  unsigned int i;
+
+  for(i = 0; i < L; ++i)
+    if(poly_chknorm(&v->vec[i], bound))
+      return 1;
+
+  return 0;
+}
+
+/**************************************************************/
+/************ Vectors of polynomials of length K **************/
+/**************************************************************/
+
+void polyveck_uniform_eta(polyveck *v, const uint8_t seed[CRHBYTES], uint16_t nonce) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_uniform_eta(&v->vec[i], seed, nonce++);
+}
+
+/*************************************************
+* Name:        polyveck_reduce
+*
+* Description: Reduce coefficients of polynomials in vector of length K
+*              to representatives in [-6283009,6283007].
+*
+* Arguments:   - polyveck *v: pointer to input/output vector
+**************************************************/
+void polyveck_reduce(polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_reduce(&v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_caddq
+*
+* Description: For all coefficients of polynomials in vector of length K
+*              add Q if coefficient is negative.
+*
+* Arguments:   - polyveck *v: pointer to input/output vector
+**************************************************/
+void polyveck_caddq(polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_caddq(&v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_add
+*
+* Description: Add vectors of polynomials of length K.
+*              No modular reduction is performed.
+*
+* Arguments:   - polyveck *w: pointer to output vector
+*              - const polyveck *u: pointer to first summand
+*              - const polyveck *v: pointer to second summand
+**************************************************/
+void polyveck_add(polyveck *w, const polyveck *u, const polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_add(&w->vec[i], &u->vec[i], &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_sub
+*
+* Description: Subtract vectors of polynomials of length K.
+*              No modular reduction is performed.
+*
+* Arguments:   - polyveck *w: pointer to output vector
+*              - const polyveck *u: pointer to first input vector
+*              - const polyveck *v: pointer to second input vector to be
+*                                   subtracted from first input vector
+**************************************************/
+void polyveck_sub(polyveck *w, const polyveck *u, const polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_sub(&w->vec[i], &u->vec[i], &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_shiftl
+*
+* Description: Multiply vector of polynomials of Length K by 2^D without modular
+*              reduction. Assumes input coefficients to be less than 2^{31-D}.
+*
+* Arguments:   - polyveck *v: pointer to input/output vector
+**************************************************/
+void polyveck_shiftl(polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_shiftl(&v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_ntt
+*
+* Description: Forward NTT of all polynomials in vector of length K. Output
+*              coefficients can be up to 16*Q larger than input coefficients.
+*
+* Arguments:   - polyveck *v: pointer to input/output vector
+**************************************************/
+void polyveck_ntt(polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_ntt(&v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_invntt_tomont
+*
+* Description: Inverse NTT and multiplication by 2^{32} of polynomials
+*              in vector of length K. Input coefficients need to be less
+*              than 2*Q.
+*
+* Arguments:   - polyveck *v: pointer to input/output vector
+**************************************************/
+void polyveck_invntt_tomont(polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_invntt_tomont(&v->vec[i]);
+}
+
+void polyveck_pointwise_poly_montgomery(polyveck *r, const poly *a, const polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_pointwise_montgomery(&r->vec[i], a, &v->vec[i]);
+}
+
+
+/*************************************************
+* Name:        polyveck_chknorm
+*
+* Description: Check infinity norm of polynomials in vector of length K.
+*              Assumes input polyveck to be reduced by polyveck_reduce().
+*
+* Arguments:   - const polyveck *v: pointer to vector
+*              - int32_t B: norm bound
+*
+* Returns 0 if norm of all polynomials are strictly smaller than B <= (Q-1)/8
+* and 1 otherwise.
+**************************************************/
+int polyveck_chknorm(const polyveck *v, int32_t bound) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    if(poly_chknorm(&v->vec[i], bound))
+      return 1;
+
+  return 0;
+}
+
+/*************************************************
+* Name:        polyveck_power2round
+*
+* Description: For all coefficients a of polynomials in vector of length K,
+*              compute a0, a1 such that a mod^+ Q = a1*2^D + a0
+*              with -2^{D-1} < a0 <= 2^{D-1}. Assumes coefficients to be
+*              standard representatives.
+*
+* Arguments:   - polyveck *v1: pointer to output vector of polynomials with
+*                              coefficients a1
+*              - polyveck *v0: pointer to output vector of polynomials with
+*                              coefficients a0
+*              - const polyveck *v: pointer to input vector
+**************************************************/
+void polyveck_power2round(polyveck *v1, polyveck *v0, const polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_power2round(&v1->vec[i], &v0->vec[i], &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_decompose
+*
+* Description: For all coefficients a of polynomials in vector of length K,
+*              compute high and low bits a0, a1 such a mod^+ Q = a1*ALPHA + a0
+*              with -ALPHA/2 < a0 <= ALPHA/2 except a1 = (Q-1)/ALPHA where we
+*              set a1 = 0 and -ALPHA/2 <= a0 = a mod Q - Q < 0.
+*              Assumes coefficients to be standard representatives.
+*
+* Arguments:   - polyveck *v1: pointer to output vector of polynomials with
+*                              coefficients a1
+*              - polyveck *v0: pointer to output vector of polynomials with
+*                              coefficients a0
+*              - const polyveck *v: pointer to input vector
+**************************************************/
+void polyveck_decompose(polyveck *v1, polyveck *v0, const polyveck *v) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_decompose(&v1->vec[i], &v0->vec[i], &v->vec[i]);
+}
+
+/*************************************************
+* Name:        polyveck_make_hint
+*
+* Description: Compute hint vector.
+*
+* Arguments:   - polyveck *h: pointer to output vector
+*              - const polyveck *v0: pointer to low part of input vector
+*              - const polyveck *v1: pointer to high part of input vector
+*
+* Returns number of 1 bits.
+**************************************************/
+unsigned int polyveck_make_hint(polyveck *h,
+                                const polyveck *v0,
+                                const polyveck *v1)
+{
+  unsigned int i, s = 0;
+
+  for(i = 0; i < K; ++i)
+    s += poly_make_hint(&h->vec[i], &v0->vec[i], &v1->vec[i]);
+
+  return s;
+}
+
+/*************************************************
+* Name:        polyveck_use_hint
+*
+* Description: Use hint vector to correct the high bits of input vector.
+*
+* Arguments:   - polyveck *w: pointer to output vector of polynomials with
+*                             corrected high bits
+*              - const polyveck *u: pointer to input vector
+*              - const polyveck *h: pointer to input hint vector
+**************************************************/
+void polyveck_use_hint(polyveck *w, const polyveck *u, const polyveck *h) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    poly_use_hint(&w->vec[i], &u->vec[i], &h->vec[i]);
+}
+
+void polyveck_pack_w1(uint8_t r[K*POLYW1_PACKEDBYTES], const polyveck *w1) {
+  unsigned int i;
+
+  for(i = 0; i < K; ++i)
+    polyw1_pack(&r[i*POLYW1_PACKEDBYTES], &w1->vec[i]);
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.h
new file mode 100644
index 000000000..615ac5299
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/polyvec.h
@@ -0,0 +1,93 @@
+#ifndef POLYVEC_H
+#define POLYVEC_H
+
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+
+/* Vectors of polynomials of length L */
+typedef struct {
+  poly vec[L];
+} polyvecl;
+
+#define polyvecl_uniform_eta DILITHIUM_NAMESPACE(polyvecl_uniform_eta)
+void polyvecl_uniform_eta(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce);
+
+#define polyvecl_uniform_gamma1 DILITHIUM_NAMESPACE(polyvecl_uniform_gamma1)
+void polyvecl_uniform_gamma1(polyvecl *v, const uint8_t seed[CRHBYTES], uint16_t nonce);
+
+#define polyvecl_reduce DILITHIUM_NAMESPACE(polyvecl_reduce)
+void polyvecl_reduce(polyvecl *v);
+
+#define polyvecl_add DILITHIUM_NAMESPACE(polyvecl_add)
+void polyvecl_add(polyvecl *w, const polyvecl *u, const polyvecl *v);
+
+#define polyvecl_ntt DILITHIUM_NAMESPACE(polyvecl_ntt)
+void polyvecl_ntt(polyvecl *v);
+#define polyvecl_invntt_tomont DILITHIUM_NAMESPACE(polyvecl_invntt_tomont)
+void polyvecl_invntt_tomont(polyvecl *v);
+#define polyvecl_pointwise_poly_montgomery DILITHIUM_NAMESPACE(polyvecl_pointwise_poly_montgomery)
+void polyvecl_pointwise_poly_montgomery(polyvecl *r, const poly *a, const polyvecl *v);
+#define polyvecl_pointwise_acc_montgomery \
+        DILITHIUM_NAMESPACE(polyvecl_pointwise_acc_montgomery)
+void polyvecl_pointwise_acc_montgomery(poly *w,
+                                       const polyvecl *u,
+                                       const polyvecl *v);
+
+
+#define polyvecl_chknorm DILITHIUM_NAMESPACE(polyvecl_chknorm)
+int polyvecl_chknorm(const polyvecl *v, int32_t B);
+
+
+
+/* Vectors of polynomials of length K */
+typedef struct {
+  poly vec[K];
+} polyveck;
+
+#define polyveck_uniform_eta DILITHIUM_NAMESPACE(polyveck_uniform_eta)
+void polyveck_uniform_eta(polyveck *v, const uint8_t seed[CRHBYTES], uint16_t nonce);
+
+#define polyveck_reduce DILITHIUM_NAMESPACE(polyveck_reduce)
+void polyveck_reduce(polyveck *v);
+#define polyveck_caddq DILITHIUM_NAMESPACE(polyveck_caddq)
+void polyveck_caddq(polyveck *v);
+
+#define polyveck_add DILITHIUM_NAMESPACE(polyveck_add)
+void polyveck_add(polyveck *w, const polyveck *u, const polyveck *v);
+#define polyveck_sub DILITHIUM_NAMESPACE(polyveck_sub)
+void polyveck_sub(polyveck *w, const polyveck *u, const polyveck *v);
+#define polyveck_shiftl DILITHIUM_NAMESPACE(polyveck_shiftl)
+void polyveck_shiftl(polyveck *v);
+
+#define polyveck_ntt DILITHIUM_NAMESPACE(polyveck_ntt)
+void polyveck_ntt(polyveck *v);
+#define polyveck_invntt_tomont DILITHIUM_NAMESPACE(polyveck_invntt_tomont)
+void polyveck_invntt_tomont(polyveck *v);
+#define polyveck_pointwise_poly_montgomery DILITHIUM_NAMESPACE(polyveck_pointwise_poly_montgomery)
+void polyveck_pointwise_poly_montgomery(polyveck *r, const poly *a, const polyveck *v);
+
+#define polyveck_chknorm DILITHIUM_NAMESPACE(polyveck_chknorm)
+int polyveck_chknorm(const polyveck *v, int32_t B);
+
+#define polyveck_power2round DILITHIUM_NAMESPACE(polyveck_power2round)
+void polyveck_power2round(polyveck *v1, polyveck *v0, const polyveck *v);
+#define polyveck_decompose DILITHIUM_NAMESPACE(polyveck_decompose)
+void polyveck_decompose(polyveck *v1, polyveck *v0, const polyveck *v);
+#define polyveck_make_hint DILITHIUM_NAMESPACE(polyveck_make_hint)
+unsigned int polyveck_make_hint(polyveck *h,
+                                const polyveck *v0,
+                                const polyveck *v1);
+#define polyveck_use_hint DILITHIUM_NAMESPACE(polyveck_use_hint)
+void polyveck_use_hint(polyveck *w, const polyveck *v, const polyveck *h);
+
+#define polyveck_pack_w1 DILITHIUM_NAMESPACE(polyveck_pack_w1)
+void polyveck_pack_w1(uint8_t r[K*POLYW1_PACKEDBYTES], const polyveck *w1);
+
+#define polyvec_matrix_expand DILITHIUM_NAMESPACE(polyvec_matrix_expand)
+void polyvec_matrix_expand(polyvecl mat[K], const uint8_t rho[SEEDBYTES]);
+
+#define polyvec_matrix_pointwise_montgomery DILITHIUM_NAMESPACE(polyvec_matrix_pointwise_montgomery)
+void polyvec_matrix_pointwise_montgomery(polyveck *t, const polyvecl mat[K], const polyvecl *v);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.c
new file mode 100644
index 000000000..a105522db
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.c
@@ -0,0 +1,69 @@
+#include <stdint.h>
+#include "params.h"
+#include "reduce.h"
+
+/*************************************************
+* Name:        montgomery_reduce
+*
+* Description: For finite field element a with -2^{31}Q <= a <= Q*2^31,
+*              compute r \equiv a*2^{-32} (mod Q) such that -Q < r < Q.
+*
+* Arguments:   - int64_t: finite field element a
+*
+* Returns r.
+**************************************************/
+int32_t montgomery_reduce(int64_t a) {
+  int32_t t;
+
+  t = (int64_t)(int32_t)a*QINV;
+  t = (a - (int64_t)t*Q) >> 32;
+  return t;
+}
+
+/*************************************************
+* Name:        reduce32
+*
+* Description: For finite field element a with a <= 2^{31} - 2^{22} - 1,
+*              compute r \equiv a (mod Q) such that -6283009 <= r <= 6283008.
+*
+* Arguments:   - int32_t: finite field element a
+*
+* Returns r.
+**************************************************/
+int32_t reduce32(int32_t a) {
+  int32_t t;
+
+  t = (a + (1 << 22)) >> 23;
+  t = a - t*Q;
+  return t;
+}
+
+/*************************************************
+* Name:        caddq
+*
+* Description: Add Q if input coefficient is negative.
+*
+* Arguments:   - int32_t: finite field element a
+*
+* Returns r.
+**************************************************/
+int32_t caddq(int32_t a) {
+  a += (a >> 31) & Q;
+  return a;
+}
+
+/*************************************************
+* Name:        freeze
+*
+* Description: For finite field element a, compute standard
+*              representative r = a mod^+ Q.
+*
+* Arguments:   - int32_t: finite field element a
+*
+* Returns r.
+**************************************************/
+int32_t freeze(int32_t a) {
+  a = reduce32(a);
+  a = caddq(a);
+  return a;
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.h
new file mode 100644
index 000000000..26d9b4ee2
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/reduce.h
@@ -0,0 +1,22 @@
+#ifndef REDUCE_H
+#define REDUCE_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define MONT -4186625 // 2^32 % Q
+#define QINV 58728449 // q^(-1) mod 2^32
+
+#define montgomery_reduce DILITHIUM_NAMESPACE(montgomery_reduce)
+int32_t montgomery_reduce(int64_t a);
+
+#define reduce32 DILITHIUM_NAMESPACE(reduce32)
+int32_t reduce32(int32_t a);
+
+#define caddq DILITHIUM_NAMESPACE(caddq)
+int32_t caddq(int32_t a);
+
+#define freeze DILITHIUM_NAMESPACE(freeze)
+int32_t freeze(int32_t a);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.c
new file mode 100644
index 000000000..889f0a296
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.c
@@ -0,0 +1,102 @@
+#include <stdint.h>
+#include "params.h"
+#include "rounding.h"
+
+/*************************************************
+* Name:        power2round
+*
+* Description: For finite field element a, compute a0, a1 such that
+*              a mod^+ Q = a1*2^D + a0 with -2^{D-1} < a0 <= 2^{D-1}.
+*              Assumes a to be standard representative.
+*
+* Arguments:   - int32_t a: input element
+*              - int32_t *a0: pointer to output element a0
+*
+* Returns a1.
+**************************************************/
+int32_t power2round(int32_t *a0, int32_t a)  {
+  int32_t a1;
+
+  a1 = (a + (1 << (D-1)) - 1) >> D;
+  *a0 = a - (a1 << D);
+  return a1;
+}
+
+/*************************************************
+* Name:        decompose
+*
+* Description: For finite field element a, compute high and low bits a0, a1 such
+*              that a mod^+ Q = a1*ALPHA + a0 with -ALPHA/2 < a0 <= ALPHA/2 except
+*              if a1 = (Q-1)/ALPHA where we set a1 = 0 and
+*              -ALPHA/2 <= a0 = a mod^+ Q - Q < 0. Assumes a to be standard
+*              representative.
+*
+* Arguments:   - int32_t a: input element
+*              - int32_t *a0: pointer to output element a0
+*
+* Returns a1.
+**************************************************/
+int32_t decompose(int32_t *a0, int32_t a) {
+  int32_t a1;
+
+  a1  = (a + 127) >> 7;
+#if GAMMA2 == (Q-1)/32
+  a1  = (a1*1025 + (1 << 21)) >> 22;
+  a1 &= 15;
+#elif GAMMA2 == (Q-1)/88
+  a1  = (a1*11275 + (1 << 23)) >> 24;
+  a1 ^= ((43 - a1) >> 31) & a1;
+#endif
+
+  *a0  = a - a1*2*GAMMA2;
+  *a0 -= (((Q-1)/2 - *a0) >> 31) & Q;
+  return a1;
+}
+
+/*************************************************
+* Name:        make_hint
+*
+* Description: Compute hint bit indicating whether the low bits of the
+*              input element overflow into the high bits.
+*
+* Arguments:   - int32_t a0: low bits of input element
+*              - int32_t a1: high bits of input element
+*
+* Returns 1 if overflow.
+**************************************************/
+unsigned int make_hint(int32_t a0, int32_t a1) {
+  if(a0 > GAMMA2 || a0 < -GAMMA2 || (a0 == -GAMMA2 && a1 != 0))
+    return 1;
+
+  return 0;
+}
+
+/*************************************************
+* Name:        use_hint
+*
+* Description: Correct high bits according to hint.
+*
+* Arguments:   - int32_t a: input element
+*              - unsigned int hint: hint bit
+*
+* Returns corrected high bits.
+**************************************************/
+int32_t use_hint(int32_t a, unsigned int hint) {
+  int32_t a0, a1;
+
+  a1 = decompose(&a0, a);
+  if(hint == 0)
+    return a1;
+
+#if GAMMA2 == (Q-1)/32
+  if(a0 > 0)
+    return (a1 + 1) & 15;
+  else
+    return (a1 - 1) & 15;
+#elif GAMMA2 == (Q-1)/88
+  if(a0 > 0)
+    return (a1 == 43) ?  0 : a1 + 1;
+  else
+    return (a1 ==  0) ? 43 : a1 - 1;
+#endif
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.h
new file mode 100644
index 000000000..b72e8e8d6
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/rounding.h
@@ -0,0 +1,19 @@
+#ifndef ROUNDING_H
+#define ROUNDING_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define power2round DILITHIUM_NAMESPACE(power2round)
+int32_t power2round(int32_t *a0, int32_t a);
+
+#define decompose DILITHIUM_NAMESPACE(decompose)
+int32_t decompose(int32_t *a0, int32_t a);
+
+#define make_hint DILITHIUM_NAMESPACE(make_hint)
+unsigned int make_hint(int32_t a0, int32_t a1);
+
+#define use_hint DILITHIUM_NAMESPACE(use_hint)
+int32_t use_hint(int32_t a, unsigned int hint);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.c
new file mode 100644
index 000000000..c4cb68887
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.c
@@ -0,0 +1,334 @@
+#include <stdint.h>
+#include "params.h"
+#include "sign.h"
+#include "packing.h"
+#include "polyvec.h"
+#include "poly.h"
+#include "../../rand_extra/pq_custom_randombytes.h"
+#include "symmetric.h"
+#include "fips202.h"
+
+/*************************************************
+* Name:        crypto_sign_keypair
+*
+* Description: Generates public and private key.
+*
+* Arguments:   - uint8_t *pk: pointer to output public key (allocated
+*                             array of CRYPTO_PUBLICKEYBYTES bytes)
+*              - uint8_t *sk: pointer to output private key (allocated
+*                             array of CRYPTO_SECRETKEYBYTES bytes)
+*
+* Returns 0 (success)
+**************************************************/
+int crypto_sign_keypair(uint8_t *pk, uint8_t *sk) {
+  uint8_t seedbuf[2*SEEDBYTES + CRHBYTES];
+  uint8_t tr[SEEDBYTES];
+  const uint8_t *rho, *rhoprime, *key;
+  polyvecl mat[K];
+  polyvecl s1, s1hat;
+  polyveck s2, t1, t0;
+
+  /* Get randomness for rho, rhoprime and key */
+  pq_custom_randombytes(seedbuf, SEEDBYTES);
+  shake256(seedbuf, 2*SEEDBYTES + CRHBYTES, seedbuf, SEEDBYTES);
+  rho = seedbuf;
+  rhoprime = rho + SEEDBYTES;
+  key = rhoprime + CRHBYTES;
+
+  /* Expand matrix */
+  polyvec_matrix_expand(mat, rho);
+
+  /* Sample short vectors s1 and s2 */
+  polyvecl_uniform_eta(&s1, rhoprime, 0);
+  polyveck_uniform_eta(&s2, rhoprime, L);
+
+  /* Matrix-vector multiplication */
+  s1hat = s1;
+  polyvecl_ntt(&s1hat);
+  polyvec_matrix_pointwise_montgomery(&t1, mat, &s1hat);
+  polyveck_reduce(&t1);
+  polyveck_invntt_tomont(&t1);
+
+  /* Add error vector s2 */
+  polyveck_add(&t1, &t1, &s2);
+
+  /* Extract t1 and write public key */
+  polyveck_caddq(&t1);
+  polyveck_power2round(&t1, &t0, &t1);
+  pack_pk(pk, rho, &t1);
+
+  /* Compute H(rho, t1) and write secret key */
+  shake256(tr, SEEDBYTES, pk, CRYPTO_PUBLICKEYBYTES);
+  pack_sk(sk, rho, tr, key, &t0, &s1, &s2);
+
+  return 0;
+}
+
+/*************************************************
+* Name:        crypto_sign_signature
+*
+* Description: Computes signature.
+*
+* Arguments:   - uint8_t *sig:   pointer to output signature (of length CRYPTO_BYTES)
+*              - size_t *siglen: pointer to output length of signature
+*              - uint8_t *m:     pointer to message to be signed
+*              - size_t mlen:    length of message
+*              - uint8_t *sk:    pointer to bit-packed secret key
+*
+* Returns 0 (success)
+**************************************************/
+int crypto_sign_signature(uint8_t *sig,
+                          size_t *siglen,
+                          const uint8_t *m,
+                          size_t mlen,
+                          const uint8_t *sk)
+{
+  unsigned int n;
+  uint8_t seedbuf[3*SEEDBYTES + 2*CRHBYTES];
+  uint8_t *rho, *tr, *key, *mu, *rhoprime;
+  uint16_t nonce = 0;
+  polyvecl mat[K], s1, y, z;
+  polyveck t0, s2, w1, w0, h;
+  poly cp;
+  keccak_state state;
+
+  rho = seedbuf;
+  tr = rho + SEEDBYTES;
+  key = tr + SEEDBYTES;
+  mu = key + SEEDBYTES;
+  rhoprime = mu + CRHBYTES;
+  unpack_sk(rho, tr, key, &t0, &s1, &s2, sk);
+
+  /* Compute CRH(tr, msg) */
+  shake256_init(&state);
+  shake256_absorb(&state, tr, SEEDBYTES);
+  shake256_absorb(&state, m, mlen);
+  shake256_finalize(&state);
+  shake256_squeeze(mu, CRHBYTES, &state);
+
+#ifdef DILITHIUM_RANDOMIZED_SIGNING
+  pq_custom_randombytes(rhoprime, CRHBYTES);
+#else
+  shake256(rhoprime, CRHBYTES, key, SEEDBYTES + CRHBYTES);
+#endif
+
+  /* Expand matrix and transform vectors */
+  polyvec_matrix_expand(mat, rho);
+  polyvecl_ntt(&s1);
+  polyveck_ntt(&s2);
+  polyveck_ntt(&t0);
+
+rej:
+  /* Sample intermediate vector y */
+  polyvecl_uniform_gamma1(&y, rhoprime, nonce++);
+
+  /* Matrix-vector multiplication */
+  z = y;
+  polyvecl_ntt(&z);
+  polyvec_matrix_pointwise_montgomery(&w1, mat, &z);
+  polyveck_reduce(&w1);
+  polyveck_invntt_tomont(&w1);
+
+  /* Decompose w and call the random oracle */
+  polyveck_caddq(&w1);
+  polyveck_decompose(&w1, &w0, &w1);
+  polyveck_pack_w1(sig, &w1);
+
+  shake256_init(&state);
+  shake256_absorb(&state, mu, CRHBYTES);
+  shake256_absorb(&state, sig, K*POLYW1_PACKEDBYTES);
+  shake256_finalize(&state);
+  shake256_squeeze(sig, SEEDBYTES, &state);
+  poly_challenge(&cp, sig);
+  poly_ntt(&cp);
+
+  /* Compute z, reject if it reveals secret */
+  polyvecl_pointwise_poly_montgomery(&z, &cp, &s1);
+  polyvecl_invntt_tomont(&z);
+  polyvecl_add(&z, &z, &y);
+  polyvecl_reduce(&z);
+  if(polyvecl_chknorm(&z, GAMMA1 - BETA))
+    goto rej;
+
+  /* Check that subtracting cs2 does not change high bits of w and low bits
+   * do not reveal secret information */
+  polyveck_pointwise_poly_montgomery(&h, &cp, &s2);
+  polyveck_invntt_tomont(&h);
+  polyveck_sub(&w0, &w0, &h);
+  polyveck_reduce(&w0);
+  if(polyveck_chknorm(&w0, GAMMA2 - BETA))
+    goto rej;
+
+  /* Compute hints for w1 */
+  polyveck_pointwise_poly_montgomery(&h, &cp, &t0);
+  polyveck_invntt_tomont(&h);
+  polyveck_reduce(&h);
+  if(polyveck_chknorm(&h, GAMMA2))
+    goto rej;
+
+  polyveck_add(&w0, &w0, &h);
+  n = polyveck_make_hint(&h, &w0, &w1);
+  if(n > OMEGA)
+    goto rej;
+
+  /* Write signature */
+  pack_sig(sig, sig, &z, &h);
+  *siglen = CRYPTO_BYTES;
+  return 0;
+}
+
+/*************************************************
+* Name:        crypto_sign
+*
+* Description: Compute signed message.
+*
+* Arguments:   - uint8_t *sm: pointer to output signed message (allocated
+*                             array with CRYPTO_BYTES + mlen bytes),
+*                             can be equal to m
+*              - size_t *smlen: pointer to output length of signed
+*                               message
+*              - const uint8_t *m: pointer to message to be signed
+*              - size_t mlen: length of message
+*              - const uint8_t *sk: pointer to bit-packed secret key
+*
+* Returns 0 (success)
+**************************************************/
+int crypto_sign(uint8_t *sm,
+                size_t *smlen,
+                const uint8_t *m,
+                size_t mlen,
+                const uint8_t *sk)
+{
+  size_t i;
+
+  for(i = 0; i < mlen; ++i)
+    sm[CRYPTO_BYTES + mlen - 1 - i] = m[mlen - 1 - i];
+  crypto_sign_signature(sm, smlen, sm + CRYPTO_BYTES, mlen, sk);
+  *smlen += mlen;
+  return 0;
+}
+
+/*************************************************
+* Name:        crypto_sign_verify
+*
+* Description: Verifies signature.
+*
+* Arguments:   - const uint8_t *sig: pointer to input signature
+*              - size_t siglen: length of signature
+*              - const uint8_t *m: pointer to message
+*              - size_t mlen: length of message
+*              - const uint8_t *pk: pointer to bit-packed public key
+*
+* Returns 0 if signature could be verified correctly and -1 otherwise
+**************************************************/
+int crypto_sign_verify(const uint8_t *sig,
+                       size_t siglen,
+                       const uint8_t *m,
+                       size_t mlen,
+                       const uint8_t *pk)
+{
+  unsigned int i;
+  uint8_t buf[K*POLYW1_PACKEDBYTES];
+  uint8_t rho[SEEDBYTES];
+  uint8_t mu[CRHBYTES];
+  uint8_t c[SEEDBYTES];
+  uint8_t c2[SEEDBYTES];
+  poly cp;
+  polyvecl mat[K], z;
+  polyveck t1, w1, h;
+  keccak_state state;
+
+  if(siglen != CRYPTO_BYTES)
+    return -1;
+
+  unpack_pk(rho, &t1, pk);
+  if(unpack_sig(c, &z, &h, sig))
+    return -1;
+  if(polyvecl_chknorm(&z, GAMMA1 - BETA))
+    return -1;
+
+  /* Compute CRH(H(rho, t1), msg) */
+  shake256(mu, SEEDBYTES, pk, CRYPTO_PUBLICKEYBYTES);
+  shake256_init(&state);
+  shake256_absorb(&state, mu, SEEDBYTES);
+  shake256_absorb(&state, m, mlen);
+  shake256_finalize(&state);
+  shake256_squeeze(mu, CRHBYTES, &state);
+
+  /* Matrix-vector multiplication; compute Az - c2^dt1 */
+  poly_challenge(&cp, c);
+  polyvec_matrix_expand(mat, rho);
+
+  polyvecl_ntt(&z);
+  polyvec_matrix_pointwise_montgomery(&w1, mat, &z);
+
+  poly_ntt(&cp);
+  polyveck_shiftl(&t1);
+  polyveck_ntt(&t1);
+  polyveck_pointwise_poly_montgomery(&t1, &cp, &t1);
+
+  polyveck_sub(&w1, &w1, &t1);
+  polyveck_reduce(&w1);
+  polyveck_invntt_tomont(&w1);
+
+  /* Reconstruct w1 */
+  polyveck_caddq(&w1);
+  polyveck_use_hint(&w1, &w1, &h);
+  polyveck_pack_w1(buf, &w1);
+
+  /* Call random oracle and verify challenge */
+  shake256_init(&state);
+  shake256_absorb(&state, mu, CRHBYTES);
+  shake256_absorb(&state, buf, K*POLYW1_PACKEDBYTES);
+  shake256_finalize(&state);
+  shake256_squeeze(c2, SEEDBYTES, &state);
+  for(i = 0; i < SEEDBYTES; ++i)
+    if(c[i] != c2[i])
+      return -1;
+
+  return 0;
+}
+
+/*************************************************
+* Name:        crypto_sign_open
+*
+* Description: Verify signed message.
+*
+* Arguments:   - uint8_t *m: pointer to output message (allocated
+*                            array with smlen bytes), can be equal to sm
+*              - size_t *mlen: pointer to output length of message
+*              - const uint8_t *sm: pointer to signed message
+*              - size_t smlen: length of signed message
+*              - const uint8_t *pk: pointer to bit-packed public key
+*
+* Returns 0 if signed message could be verified correctly and -1 otherwise
+**************************************************/
+int crypto_sign_open(uint8_t *m,
+                     size_t *mlen,
+                     const uint8_t *sm,
+                     size_t smlen,
+                     const uint8_t *pk)
+{
+  size_t i;
+
+  if(smlen < CRYPTO_BYTES)
+    goto badsig;
+
+  *mlen = smlen - CRYPTO_BYTES;
+  if(crypto_sign_verify(sm, CRYPTO_BYTES, sm + CRYPTO_BYTES, *mlen, pk))
+    goto badsig;
+  else {
+    /* All good, copy msg, return 0 */
+    for(i = 0; i < *mlen; ++i)
+      m[i] = sm[CRYPTO_BYTES + i];
+    return 0;
+  }
+
+badsig:
+  /* Signature verification failed */
+  *mlen = 0; /* Deviation from CRYSTALS (this is set as -1 i.e. not a size_t) */
+  for(i = 0; i < smlen; ++i)
+    m[i] = 0;
+
+  return -1;
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.h
new file mode 100644
index 000000000..295f378c0
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/sign.h
@@ -0,0 +1,36 @@
+#ifndef SIGN_H
+#define SIGN_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include "params.h"
+#include "polyvec.h"
+#include "poly.h"
+
+#define challenge DILITHIUM_NAMESPACE(challenge)
+void challenge(poly *c, const uint8_t seed[SEEDBYTES]);
+
+#define crypto_sign_keypair DILITHIUM_NAMESPACE(keypair)
+int crypto_sign_keypair(uint8_t *pk, uint8_t *sk);
+
+#define crypto_sign_signature DILITHIUM_NAMESPACE(signature)
+int crypto_sign_signature(uint8_t *sig, size_t *siglen,
+                          const uint8_t *m, size_t mlen,
+                          const uint8_t *sk);
+
+#define crypto_sign DILITHIUM_NAMESPACETOP
+int crypto_sign(uint8_t *sm, size_t *smlen,
+                const uint8_t *m, size_t mlen,
+                const uint8_t *sk);
+
+#define crypto_sign_verify DILITHIUM_NAMESPACE(verify)
+int crypto_sign_verify(const uint8_t *sig, size_t siglen,
+                       const uint8_t *m, size_t mlen,
+                       const uint8_t *pk);
+
+#define crypto_sign_open DILITHIUM_NAMESPACE(open)
+int crypto_sign_open(uint8_t *m, size_t *mlen,
+                     const uint8_t *sm, size_t smlen,
+                     const uint8_t *pk);
+
+#endif
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric-shake.c b/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric-shake.c
new file mode 100644
index 000000000..11ec09cce
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric-shake.c
@@ -0,0 +1,28 @@
+#include <stdint.h>
+#include "params.h"
+#include "symmetric.h"
+#include "fips202.h"
+
+void dilithium_shake128_stream_init(keccak_state *state, const uint8_t seed[SEEDBYTES], uint16_t nonce)
+{
+  uint8_t t[2];
+  t[0] = nonce;
+  t[1] = nonce >> 8;
+
+  shake128_init(state);
+  shake128_absorb(state, seed, SEEDBYTES);
+  shake128_absorb(state, t, 2);
+  shake128_finalize(state);
+}
+
+void dilithium_shake256_stream_init(keccak_state *state, const uint8_t seed[CRHBYTES], uint16_t nonce)
+{
+  uint8_t t[2];
+  t[0] = nonce;
+  t[1] = nonce >> 8;
+
+  shake256_init(state);
+  shake256_absorb(state, seed, CRHBYTES);
+  shake256_absorb(state, t, 2);
+  shake256_finalize(state);
+}
diff --git a/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric.h b/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric.h
new file mode 100644
index 000000000..cba12d1c2
--- /dev/null
+++ b/crypto/dilithium/pqcrystals_dilithium_ref_common/symmetric.h
@@ -0,0 +1,34 @@
+#ifndef SYMMETRIC_H
+#define SYMMETRIC_H
+
+#include <stdint.h>
+#include "params.h"
+
+#include "fips202.h"
+
+typedef keccak_state stream128_state;
+typedef keccak_state stream256_state;
+
+#define dilithium_shake128_stream_init DILITHIUM_NAMESPACE(dilithium_shake128_stream_init)
+void dilithium_shake128_stream_init(keccak_state *state,
+                                    const uint8_t seed[SEEDBYTES],
+                                    uint16_t nonce);
+
+#define dilithium_shake256_stream_init DILITHIUM_NAMESPACE(dilithium_shake256_stream_init)
+void dilithium_shake256_stream_init(keccak_state *state,
+                                    const uint8_t seed[CRHBYTES],
+                                    uint16_t nonce);
+
+#define STREAM128_BLOCKBYTES SHAKE128_RATE
+#define STREAM256_BLOCKBYTES SHAKE256_RATE
+
+#define stream128_init(STATE, SEED, NONCE) \
+        dilithium_shake128_stream_init(STATE, SEED, NONCE)
+#define stream128_squeezeblocks(OUT, OUTBLOCKS, STATE) \
+        shake128_squeezeblocks(OUT, OUTBLOCKS, STATE)
+#define stream256_init(STATE, SEED, NONCE) \
+        dilithium_shake256_stream_init(STATE, SEED, NONCE)
+#define stream256_squeezeblocks(OUT, OUTBLOCKS, STATE) \
+        shake256_squeezeblocks(OUT, OUTBLOCKS, STATE)
+
+#endif
diff --git a/crypto/dilithium/sig_dilithium.h b/crypto/dilithium/sig_dilithium.h
new file mode 100644
index 000000000..3daf5ba98
--- /dev/null
+++ b/crypto/dilithium/sig_dilithium.h
@@ -0,0 +1,45 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef SIG_DILITHIUM_H
+#define SIG_DILITHIUM_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <openssl/base.h>
+#include <openssl/evp.h>
+
+// The values below are taken from the |api.h| file in the
+// |crypto/dilithium/pqcrystals_dilithium_ref_common| directory.
+#define DILITHIUM3_PUBLIC_KEY_BYTES 1952
+#define DILITHIUM3_PRIVATE_KEY_BYTES 4000
+#define DILITHIUM3_SIGNATURE_BYTES 3293
+
+// DILITHIUM3_keypair generates a Dilithium3 keypair and assigns a public key to
+// |public_key| and a private key to |secret_key|. The function is a wrapper for
+// the keygen function from the Dilithium source. It returns 0 upon success.
+int DILITHIUM3_keypair(uint8_t *public_key,
+                       uint8_t *secret_key);
+
+// DILITHIUM3_sign generates a Dilithium3 signature. Where |sig| is a pointer to
+// output signature, |sig_len| is a pointer to output length of signature,
+// |message| is a pointer to message to be signed, |message_len| is the length
+// of the message and |secret_key| is a pointer to bit-packed secret key.
+// It returns 0 upon success.
+int DILITHIUM3_sign(uint8_t *sig, size_t *sig_len,
+                    const uint8_t *message,
+                    size_t message_len,
+                    const uint8_t *secret_key);
+
+// DILITHIUM3_verify generates a Dilithium3 signature. Where |sig| is a pointer
+// to input signature, |sig_len| is the length of the signature, |message| is
+// a pointer to message, |message_len| is the length of the message and
+// |public_key| is a pointer to bit-packed public key. Returns 0 if signature
+// could be verified successfully and -1 otherwise.
+int DILITHIUM3_verify(const uint8_t *message,
+                      size_t message_len,
+                      const uint8_t *sig,
+                      size_t sig_len,
+                      const uint8_t *public_key);
+
+#endif
diff --git a/crypto/dilithium/sig_dilithium3.c b/crypto/dilithium/sig_dilithium3.c
new file mode 100644
index 000000000..e3a0dbf57
--- /dev/null
+++ b/crypto/dilithium/sig_dilithium3.c
@@ -0,0 +1,36 @@
+// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+// SPDX-License-Identifier: Apache-2.0
+
+#include "../evp_extra/internal.h"
+#include "../fipsmodule/evp/internal.h"
+#include "sig_dilithium.h"
+#include "pqcrystals_dilithium_ref_common/api.h"
+
+// Note: These methods currently default to using the reference code for
+// Dilithium. In a future where AWS-LC has optimized options available,
+// those can be conditionally (or based on compile-time flags) called here,
+// depending on platform support.
+
+
+int DILITHIUM3_keypair(uint8_t *public_key /* OUT */,
+                       uint8_t *secret_key /* OUT */) {
+  return pqcrystals_dilithium3_ref_keypair(public_key, secret_key);
+}
+
+int DILITHIUM3_sign(uint8_t *sig               /* OUT */,
+                    size_t *sig_len            /* OUT */,
+                    const uint8_t *message     /* IN */,
+                    size_t message_len,        /* IN */
+                    const uint8_t *secret_key  /* IN */) {
+  return pqcrystals_dilithium3_ref_signature(sig, sig_len, message, message_len,
+                                             secret_key);
+}
+
+int DILITHIUM3_verify(const uint8_t *message    /* IN */,
+                      size_t message_len        /* IN */,
+                      const uint8_t *sig        /* IN */,
+                      size_t sig_len            /* IN */,
+                      const uint8_t *public_key /* IN */) {
+  return pqcrystals_dilithium3_ref_verify(sig, sig_len, message, message_len,
+                                          public_key);
+}
diff --git a/crypto/evp_extra/evp_extra_test.cc b/crypto/evp_extra/evp_extra_test.cc
index 4c55d919e..be982e54b 100644
--- a/crypto/evp_extra/evp_extra_test.cc
+++ b/crypto/evp_extra/evp_extra_test.cc
@@ -696,6 +696,351 @@ static const uint8_t kInvalidPrivateKey[] = {
     0x48, 0x30, 0x01, 0xaa, 0x02, 0x86, 0xc0, 0x30, 0xdf, 0xe9, 0x80,
 };
 
+#ifdef ENABLE_DILITHIUM
+
+// kExampleDilithium3KeyDER is a Dilithium private key in ASN.1, DER format.
+// Of course, you should never use this key anywhere but in an example.
+static const uint8_t kExampleDilithium3KeyDER[] = {
+    0x30, 0x82, 0x0f, 0xb6, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x0b, 0x2b,
+    0x06, 0x01, 0x04, 0x01, 0x02, 0x82, 0x0b, 0x07, 0x06, 0x05, 0x04, 0x82,
+    0x0f, 0xa0, 0xfa, 0xdd, 0x76, 0x89, 0x8f, 0x69, 0x44, 0x5f, 0x8f, 0x1f,
+    0xa9, 0x63, 0x93, 0xbd, 0x11, 0x9f, 0x39, 0x97, 0x49, 0xe8, 0x1b, 0x61,
+    0x31, 0x19, 0x84, 0xe2, 0x49, 0x63, 0x91, 0x7a, 0xcf, 0x6d, 0x37, 0x5f,
+    0x0d, 0x04, 0x2e, 0x73, 0xa2, 0x93, 0x12, 0x1a, 0x2b, 0x5e, 0x20, 0x76,
+    0xe6, 0x36, 0x02, 0x89, 0x70, 0x8e, 0xd8, 0x79, 0x55, 0x30, 0xe8, 0xef,
+    0x05, 0x94, 0x4f, 0x48, 0xf1, 0x29, 0x9b, 0x04, 0xa0, 0x3f, 0xc5, 0xe2,
+    0x0b, 0xc2, 0xbe, 0x6c, 0x25, 0xa0, 0x2d, 0xb2, 0xcb, 0x40, 0x00, 0x1a,
+    0xbf, 0x18, 0xa0, 0xaa, 0xd9, 0x3c, 0x8b, 0xff, 0xfa, 0x3d, 0x17, 0x5b,
+    0xe7, 0x0a, 0x08, 0x57, 0x17, 0x08, 0x47, 0x28, 0x26, 0x44, 0x62, 0x28,
+    0x40, 0x42, 0x64, 0x21, 0x08, 0x30, 0x66, 0x82, 0x85, 0x71, 0x50, 0x47,
+    0x60, 0x02, 0x43, 0x66, 0x87, 0x23, 0x56, 0x48, 0x06, 0x81, 0x80, 0x76,
+    0x63, 0x71, 0x73, 0x04, 0x55, 0x33, 0x70, 0x02, 0x00, 0x55, 0x76, 0x11,
+    0x40, 0x71, 0x44, 0x50, 0x11, 0x18, 0x50, 0x03, 0x78, 0x05, 0x15, 0x02,
+    0x10, 0x57, 0x14, 0x15, 0x71, 0x64, 0x31, 0x47, 0x24, 0x61, 0x61, 0x10,
+    0x25, 0x28, 0x30, 0x30, 0x62, 0x78, 0x75, 0x40, 0x65, 0x77, 0x33, 0x08,
+    0x12, 0x41, 0x32, 0x55, 0x70, 0x10, 0x57, 0x76, 0x77, 0x71, 0x72, 0x64,
+    0x61, 0x26, 0x11, 0x24, 0x36, 0x34, 0x74, 0x11, 0x03, 0x77, 0x41, 0x74,
+    0x23, 0x70, 0x16, 0x30, 0x58, 0x62, 0x26, 0x01, 0x12, 0x41, 0x76, 0x23,
+    0x50, 0x88, 0x47, 0x80, 0x73, 0x56, 0x38, 0x62, 0x57, 0x20, 0x01, 0x81,
+    0x03, 0x76, 0x16, 0x17, 0x37, 0x07, 0x28, 0x52, 0x84, 0x28, 0x56, 0x82,
+    0x86, 0x16, 0x73, 0x04, 0x74, 0x80, 0x85, 0x57, 0x31, 0x78, 0x25, 0x10,
+    0x45, 0x20, 0x12, 0x78, 0x61, 0x21, 0x80, 0x00, 0x16, 0x15, 0x25, 0x60,
+    0x40, 0x52, 0x20, 0x72, 0x71, 0x73, 0x61, 0x11, 0x75, 0x55, 0x85, 0x42,
+    0x33, 0x65, 0x73, 0x68, 0x82, 0x20, 0x37, 0x87, 0x41, 0x00, 0x02, 0x40,
+    0x61, 0x25, 0x41, 0x62, 0x04, 0x21, 0x04, 0x40, 0x21, 0x03, 0x61, 0x80,
+    0x66, 0x41, 0x60, 0x16, 0x27, 0x44, 0x78, 0x01, 0x37, 0x50, 0x10, 0x27,
+    0x21, 0x01, 0x80, 0x00, 0x70, 0x20, 0x68, 0x70, 0x26, 0x54, 0x48, 0x07,
+    0x74, 0x80, 0x23, 0x70, 0x12, 0x63, 0x30, 0x50, 0x22, 0x70, 0x04, 0x04,
+    0x23, 0x73, 0x08, 0x02, 0x86, 0x16, 0x67, 0x47, 0x24, 0x64, 0x68, 0x18,
+    0x85, 0x35, 0x73, 0x62, 0x18, 0x50, 0x44, 0x64, 0x58, 0x78, 0x66, 0x77,
+    0x51, 0x18, 0x64, 0x17, 0x23, 0x53, 0x16, 0x88, 0x38, 0x12, 0x55, 0x07,
+    0x68, 0x25, 0x24, 0x84, 0x27, 0x70, 0x04, 0x20, 0x56, 0x13, 0x72, 0x05,
+    0x11, 0x85, 0x15, 0x84, 0x81, 0x25, 0x64, 0x67, 0x03, 0x70, 0x67, 0x28,
+    0x62, 0x42, 0x28, 0x65, 0x21, 0x13, 0x78, 0x48, 0x43, 0x58, 0x60, 0x45,
+    0x33, 0x84, 0x36, 0x54, 0x32, 0x14, 0x17, 0x87, 0x27, 0x86, 0x83, 0x40,
+    0x51, 0x16, 0x68, 0x60, 0x73, 0x38, 0x73, 0x44, 0x06, 0x26, 0x23, 0x11,
+    0x12, 0x70, 0x71, 0x03, 0x25, 0x83, 0x54, 0x17, 0x55, 0x63, 0x67, 0x04,
+    0x85, 0x01, 0x74, 0x68, 0x56, 0x48, 0x10, 0x11, 0x05, 0x78, 0x51, 0x54,
+    0x61, 0x00, 0x47, 0x00, 0x04, 0x25, 0x53, 0x14, 0x75, 0x61, 0x10, 0x27,
+    0x61, 0x03, 0x04, 0x27, 0x62, 0x46, 0x12, 0x66, 0x36, 0x47, 0x03, 0x37,
+    0x48, 0x78, 0x03, 0x61, 0x61, 0x23, 0x04, 0x82, 0x68, 0x88, 0x58, 0x43,
+    0x01, 0x87, 0x06, 0x31, 0x18, 0x73, 0x23, 0x48, 0x44, 0x34, 0x41, 0x70,
+    0x37, 0x53, 0x28, 0x76, 0x23, 0x27, 0x01, 0x14, 0x25, 0x08, 0x24, 0x17,
+    0x02, 0x53, 0x02, 0x78, 0x34, 0x25, 0x11, 0x26, 0x54, 0x81, 0x21, 0x78,
+    0x48, 0x74, 0x76, 0x03, 0x48, 0x62, 0x07, 0x65, 0x65, 0x36, 0x23, 0x25,
+    0x65, 0x12, 0x37, 0x26, 0x02, 0x16, 0x07, 0x37, 0x30, 0x85, 0x42, 0x08,
+    0x07, 0x02, 0x82, 0x47, 0x61, 0x87, 0x01, 0x84, 0x45, 0x03, 0x38, 0x41,
+    0x26, 0x82, 0x73, 0x03, 0x73, 0x02, 0x04, 0x47, 0x44, 0x67, 0x20, 0x21,
+    0x06, 0x14, 0x40, 0x51, 0x81, 0x31, 0x73, 0x33, 0x76, 0x26, 0x00, 0x57,
+    0x67, 0x66, 0x81, 0x32, 0x32, 0x82, 0x16, 0x45, 0x41, 0x45, 0x05, 0x68,
+    0x51, 0x34, 0x73, 0x35, 0x52, 0x15, 0x75, 0x38, 0x62, 0x74, 0x86, 0x31,
+    0x86, 0x54, 0x61, 0x35, 0x06, 0x67, 0x45, 0x85, 0x60, 0x56, 0x75, 0x88,
+    0x26, 0x51, 0x21, 0x66, 0x17, 0x25, 0x54, 0x48, 0x31, 0x85, 0x84, 0x74,
+    0x76, 0x21, 0x28, 0x23, 0x68, 0x47, 0x78, 0x38, 0x64, 0x38, 0x18, 0x84,
+    0x21, 0x00, 0x84, 0x70, 0x14, 0x06, 0x80, 0x51, 0x31, 0x84, 0x00, 0x15,
+    0x82, 0x73, 0x34, 0x34, 0x60, 0x07, 0x71, 0x11, 0x67, 0x78, 0x54, 0x66,
+    0x51, 0x81, 0x13, 0x57, 0x50, 0x46, 0x43, 0x68, 0x75, 0x07, 0x12, 0x81,
+    0x13, 0x54, 0x12, 0x12, 0x55, 0x54, 0x75, 0x72, 0x40, 0x60, 0x18, 0x85,
+    0x71, 0x84, 0x43, 0x61, 0x65, 0x17, 0x57, 0x76, 0x56, 0x46, 0x34, 0x76,
+    0x72, 0x04, 0x53, 0x20, 0x53, 0x52, 0x78, 0x65, 0x60, 0x25, 0x50, 0x80,
+    0x27, 0x01, 0x23, 0x87, 0x21, 0x32, 0x67, 0x00, 0x64, 0x07, 0x77, 0x75,
+    0x63, 0x43, 0x80, 0x18, 0x75, 0x12, 0x43, 0x33, 0x31, 0x38, 0x76, 0x27,
+    0x12, 0x62, 0x18, 0x62, 0x11, 0x60, 0x30, 0x46, 0x51, 0x26, 0x14, 0x84,
+    0x78, 0x60, 0x06, 0x23, 0x56, 0x36, 0x07, 0x51, 0x70, 0x58, 0x84, 0x76,
+    0x00, 0x01, 0x68, 0x58, 0x03, 0x11, 0x65, 0x42, 0x21, 0x21, 0x53, 0x78,
+    0x37, 0x27, 0x24, 0x78, 0x47, 0x82, 0x65, 0x32, 0x57, 0x42, 0x46, 0x66,
+    0x12, 0x77, 0x10, 0x10, 0x66, 0x02, 0x54, 0x37, 0x38, 0x46, 0x16, 0x06,
+    0x83, 0x03, 0x01, 0x25, 0x80, 0x82, 0x07, 0x61, 0x66, 0x83, 0x86, 0x12,
+    0x15, 0x37, 0x44, 0x17, 0x31, 0x13, 0x35, 0x05, 0x30, 0x41, 0x74, 0x44,
+    0x02, 0x57, 0x53, 0x74, 0x65, 0x40, 0x48, 0x33, 0x60, 0x65, 0x11, 0x82,
+    0x36, 0x62, 0x01, 0x73, 0x67, 0x23, 0x18, 0x13, 0x28, 0x28, 0x48, 0x51,
+    0x64, 0x16, 0x10, 0x21, 0x34, 0x02, 0x47, 0x30, 0x82, 0x32, 0x34, 0x17,
+    0x40, 0x74, 0x64, 0x42, 0x34, 0x81, 0x27, 0x68, 0x67, 0x26, 0x33, 0x33,
+    0x58, 0x81, 0x73, 0x28, 0x46, 0x07, 0x44, 0x56, 0x70, 0x43, 0x22, 0x38,
+    0x40, 0x22, 0x31, 0x20, 0x54, 0x42, 0x60, 0x34, 0x41, 0x26, 0x53, 0x75,
+    0x88, 0x87, 0x34, 0x14, 0x71, 0x64, 0x64, 0x14, 0x08, 0x32, 0x78, 0x62,
+    0x13, 0x86, 0x17, 0x50, 0x70, 0x23, 0x38, 0x21, 0x71, 0x53, 0x50, 0x20,
+    0x54, 0x55, 0x82, 0x74, 0x21, 0x86, 0x38, 0x75, 0x25, 0x21, 0x20, 0x61,
+    0x86, 0x28, 0x60, 0x33, 0x13, 0x41, 0x56, 0x30, 0x66, 0x45, 0x22, 0x22,
+    0x53, 0x31, 0x11, 0x54, 0x82, 0x08, 0x55, 0x64, 0x36, 0x41, 0x01, 0x40,
+    0x62, 0x34, 0x21, 0x42, 0x16, 0x02, 0x78, 0x43, 0x76, 0x28, 0x02, 0x53,
+    0x26, 0x42, 0x41, 0x27, 0x30, 0x53, 0x57, 0x61, 0x00, 0x88, 0x63, 0x22,
+    0x31, 0x12, 0x20, 0x63, 0x42, 0x84, 0x55, 0x34, 0x82, 0x41, 0x12, 0x21,
+    0x17, 0x00, 0x57, 0x04, 0x20, 0x30, 0x37, 0x01, 0x06, 0x68, 0x54, 0x03,
+    0x67, 0x25, 0x50, 0x76, 0x72, 0x16, 0x75, 0x66, 0x55, 0x77, 0x66, 0x83,
+    0x47, 0x45, 0x16, 0x16, 0x43, 0x50, 0x25, 0x15, 0x03, 0x33, 0x03, 0x33,
+    0x70, 0x25, 0x60, 0x70, 0x83, 0x54, 0x86, 0x06, 0x15, 0x23, 0x24, 0x86,
+    0x22, 0x10, 0x24, 0x78, 0x84, 0x74, 0x78, 0x84, 0x30, 0x83, 0x74, 0x36,
+    0x73, 0x81, 0x54, 0x67, 0x46, 0x42, 0x63, 0x86, 0x62, 0x85, 0x61, 0x27,
+    0x54, 0x75, 0x42, 0x37, 0x61, 0x26, 0x82, 0x71, 0x58, 0x81, 0x34, 0x85,
+    0x18, 0x57, 0x63, 0x41, 0x72, 0x08, 0x20, 0x84, 0x00, 0x88, 0x18, 0x05,
+    0x74, 0x08, 0x85, 0x64, 0x40, 0x21, 0x70, 0x32, 0x75, 0x76, 0x56, 0x86,
+    0x00, 0x77, 0x38, 0x03, 0x62, 0x67, 0x54, 0x72, 0x53, 0x42, 0x43, 0x60,
+    0x42, 0x86, 0x04, 0x44, 0x40, 0x76, 0x38, 0x04, 0x01, 0x45, 0x01, 0x03,
+    0x88, 0x83, 0x25, 0x66, 0x14, 0x15, 0x47, 0x10, 0x75, 0x05, 0x38, 0x61,
+    0x36, 0x50, 0x86, 0x47, 0x80, 0x83, 0x11, 0x67, 0x24, 0x87, 0x08, 0x55,
+    0x77, 0x31, 0x37, 0x43, 0x38, 0x70, 0x21, 0x81, 0x15, 0x34, 0x33, 0x68,
+    0x71, 0x53, 0x22, 0x04, 0x77, 0x87, 0x65, 0x53, 0x41, 0x46, 0x33, 0x12,
+    0x47, 0x36, 0x35, 0x47, 0x43, 0x44, 0x56, 0x20, 0x30, 0x75, 0x62, 0x15,
+    0x51, 0x46, 0x43, 0x37, 0x47, 0x56, 0x88, 0x47, 0x22, 0x04, 0x68, 0x05,
+    0x48, 0x06, 0x08, 0x52, 0x30, 0x08, 0x83, 0x87, 0x42, 0x60, 0x58, 0x77,
+    0x80, 0x87, 0x75, 0x85, 0x61, 0x83, 0x37, 0x40, 0x33, 0x83, 0x17, 0x86,
+    0x71, 0x58, 0x84, 0x31, 0x25, 0x45, 0x57, 0x76, 0x15, 0x01, 0x11, 0x13,
+    0x16, 0x60, 0x14, 0x07, 0x77, 0x07, 0x27, 0x04, 0x73, 0x25, 0x78, 0x38,
+    0x10, 0x88, 0x08, 0x52, 0x17, 0x45, 0x44, 0x16, 0x57, 0x40, 0x08, 0x00,
+    0x53, 0x47, 0x17, 0x86, 0x10, 0x15, 0x03, 0x81, 0x55, 0x07, 0x31, 0x63,
+    0x45, 0x07, 0x05, 0x38, 0x58, 0x42, 0x41, 0x66, 0x12, 0x17, 0x60, 0x36,
+    0x08, 0x55, 0x35, 0x28, 0x54, 0x78, 0x22, 0x84, 0x34, 0x43, 0x72, 0x57,
+    0x25, 0x75, 0x03, 0x88, 0x02, 0x05, 0x81, 0x84, 0x83, 0x18, 0x82, 0x77,
+    0x32, 0x05, 0x06, 0x20, 0x30, 0x10, 0x02, 0x20, 0x62, 0x06, 0x25, 0x25,
+    0x34, 0x53, 0x18, 0x17, 0x88, 0x47, 0x84, 0x35, 0x06, 0x22, 0x67, 0x78,
+    0x77, 0x48, 0x82, 0x88, 0x60, 0x25, 0x05, 0x35, 0x54, 0x27, 0x16, 0x26,
+    0x27, 0x61, 0x57, 0x08, 0x24, 0x08, 0x04, 0x45, 0x84, 0x67, 0x54, 0x68,
+    0x68, 0x81, 0x61, 0x60, 0x36, 0x73, 0x60, 0x80, 0x42, 0x41, 0x53, 0x47,
+    0x57, 0x00, 0x02, 0x17, 0x62, 0x30, 0x47, 0x86, 0x54, 0x44, 0x50, 0x82,
+    0x16, 0x40, 0x21, 0x36, 0x42, 0x27, 0x51, 0x73, 0x46, 0x46, 0x70, 0x40,
+    0x11, 0x28, 0x51, 0x83, 0x33, 0x78, 0x41, 0x77, 0x26, 0x55, 0x73, 0x45,
+    0x10, 0x72, 0x36, 0x50, 0x74, 0x50, 0x44, 0x15, 0x00, 0x62, 0x42, 0x88,
+    0x87, 0x48, 0x37, 0x43, 0x10, 0x54, 0x03, 0x63, 0x13, 0x37, 0x21, 0x15,
+    0x22, 0x62, 0x50, 0x38, 0x01, 0x15, 0x05, 0x61, 0x62, 0x14, 0x22, 0x47,
+    0x42, 0x76, 0x31, 0x72, 0x27, 0x27, 0x36, 0x10, 0x44, 0x70, 0x15, 0x23,
+    0x37, 0x52, 0x35, 0x12, 0x00, 0x31, 0x02, 0x58, 0x14, 0x28, 0x57, 0x68,
+    0x05, 0x87, 0x57, 0x84, 0x24, 0x07, 0x16, 0x42, 0x13, 0x07, 0x18, 0x84,
+    0x13, 0x46, 0x47, 0x82, 0x05, 0x67, 0x21, 0x28, 0x56, 0x80, 0x35, 0x44,
+    0x31, 0x07, 0x32, 0x36, 0x33, 0x86, 0x50, 0x32, 0x81, 0x37, 0x01, 0x53,
+    0x74, 0x67, 0x48, 0x56, 0x05, 0x08, 0x73, 0xc0, 0x1c, 0x42, 0x4f, 0xf0,
+    0xf5, 0x89, 0x2c, 0x3f, 0x0a, 0x96, 0xa9, 0x37, 0xb5, 0x82, 0xdc, 0xa8,
+    0x4d, 0x50, 0x52, 0x47, 0xd8, 0x20, 0xb7, 0xc4, 0x6a, 0xc8, 0xd4, 0x61,
+    0xd3, 0x19, 0xfd, 0x1d, 0xc6, 0x00, 0xe5, 0x5e, 0x49, 0xdd, 0x6b, 0xd8,
+    0x42, 0x65, 0xb0, 0x73, 0x68, 0xa9, 0x18, 0xec, 0x3c, 0x22, 0x6e, 0x48,
+    0x8f, 0x5d, 0x96, 0xc8, 0xe6, 0xa5, 0xc9, 0x98, 0x3e, 0x77, 0xd8, 0xb6,
+    0x98, 0x70, 0x15, 0xc5, 0x46, 0xf3, 0xd9, 0x51, 0x2e, 0x89, 0x72, 0xee,
+    0xc6, 0xa8, 0x52, 0xe0, 0x06, 0x78, 0xd3, 0x09, 0x21, 0x93, 0xce, 0x7c,
+    0xeb, 0x30, 0x4b, 0xc0, 0x23, 0xde, 0xca, 0xdf, 0xe7, 0xcc, 0xd8, 0xb9,
+    0xcf, 0x99, 0x4d, 0xeb, 0x14, 0x1b, 0x8d, 0xc8, 0x5e, 0x03, 0xec, 0x27,
+    0xd4, 0x22, 0xa2, 0x29, 0x6d, 0xfb, 0xdc, 0x89, 0x5a, 0x5e, 0x21, 0xb8,
+    0x14, 0xa1, 0xd1, 0x47, 0x6a, 0x40, 0x9f, 0x55, 0x3c, 0x72, 0xb4, 0xe6,
+    0x55, 0x8d, 0xf5, 0x46, 0xc6, 0xef, 0x7d, 0xd6, 0x64, 0x03, 0x7a, 0xd2,
+    0xfa, 0x72, 0xdc, 0x02, 0x97, 0x4a, 0x65, 0x30, 0x8a, 0xd0, 0xdb, 0x6e,
+    0xc7, 0xc6, 0x9e, 0x34, 0x65, 0x94, 0x02, 0xd6, 0xd4, 0x0a, 0x75, 0xe0,
+    0x47, 0x6c, 0x4a, 0xee, 0x8b, 0xc3, 0x83, 0xd2, 0x97, 0xaa, 0xaa, 0x80,
+    0xc9, 0xf0, 0x47, 0x74, 0x02, 0x03, 0x60, 0x1c, 0x59, 0xfc, 0xa7, 0xb1,
+    0xc9, 0x85, 0x07, 0xc1, 0xd1, 0xb8, 0xc4, 0x04, 0x1f, 0xbf, 0x80, 0xbe,
+    0xe6, 0x1c, 0x6c, 0xf0, 0xbc, 0x9f, 0xf2, 0x68, 0x66, 0xac, 0x0a, 0x08,
+    0x7b, 0x1f, 0x09, 0x50, 0x89, 0x95, 0xec, 0xa2, 0x6f, 0x72, 0xc0, 0x84,
+    0x3c, 0x8b, 0xf1, 0xd0, 0xcb, 0xd7, 0x76, 0xb3, 0x77, 0x7f, 0x37, 0x1e,
+    0x06, 0xd3, 0x48, 0x88, 0x84, 0xd0, 0x5d, 0x0e, 0x2b, 0xff, 0xdc, 0x5f,
+    0x0e, 0x06, 0xbf, 0x6a, 0x81, 0xb9, 0xea, 0x88, 0xee, 0x05, 0xc4, 0xad,
+    0xcd, 0x57, 0x8f, 0x94, 0xf0, 0x91, 0x61, 0x57, 0x22, 0xd3, 0x9d, 0x5d,
+    0x4a, 0x88, 0xa3, 0xed, 0x04, 0xc7, 0x0f, 0x90, 0x71, 0xdb, 0xea, 0xcd,
+    0x0b, 0x37, 0x39, 0xc0, 0xaa, 0x88, 0x87, 0x3a, 0xf4, 0xe6, 0x46, 0x73,
+    0x16, 0xb6, 0xc5, 0xe1, 0x82, 0x1c, 0xb4, 0x0e, 0xb0, 0xcd, 0x55, 0x11,
+    0xa7, 0x27, 0xcf, 0xc8, 0x74, 0xfd, 0x00, 0x03, 0x5e, 0x1e, 0xd8, 0x80,
+    0xa4, 0xdf, 0xeb, 0xd5, 0x23, 0x59, 0x45, 0xae, 0xe1, 0x79, 0x7a, 0xe9,
+    0x0f, 0x30, 0x14, 0x29, 0x65, 0x51, 0x68, 0x08, 0xe7, 0xd9, 0x31, 0xa2,
+    0xed, 0xc2, 0x72, 0x2c, 0xf7, 0x48, 0x35, 0xd2, 0xb6, 0x03, 0x88, 0xeb,
+    0x08, 0xb0, 0xfb, 0x9c, 0xb9, 0x1a, 0xd4, 0x27, 0x47, 0x7b, 0x5d, 0x9a,
+    0xf6, 0xe3, 0xf1, 0x2b, 0x4e, 0x4a, 0x31, 0x10, 0xd2, 0xfb, 0x4e, 0x26,
+    0xe3, 0xb3, 0x87, 0xcc, 0xeb, 0x11, 0xed, 0x80, 0x0c, 0x75, 0x31, 0x10,
+    0x0f, 0x51, 0x49, 0xf7, 0x6f, 0x9a, 0x13, 0xc2, 0x0b, 0x16, 0xfa, 0x3e,
+    0x43, 0x7d, 0xed, 0x8b, 0x6a, 0x3e, 0xbc, 0xfb, 0xf0, 0xf6, 0x35, 0xbd,
+    0xf9, 0x98, 0x68, 0x01, 0x0f, 0x3a, 0x74, 0x5d, 0x98, 0x16, 0xa9, 0x19,
+    0x7b, 0x7b, 0xb9, 0x0f, 0xf5, 0xc5, 0x74, 0x25, 0xb4, 0xb7, 0x9b, 0xcc,
+    0x71, 0xd8, 0xca, 0x60, 0xd2, 0xd3, 0x92, 0xd4, 0x0e, 0x08, 0xc9, 0x60,
+    0x21, 0xc5, 0xca, 0x86, 0xcf, 0xc7, 0x3d, 0x3c, 0x6d, 0xa2, 0xa0, 0xe3,
+    0x39, 0x33, 0x34, 0x52, 0xd3, 0x3b, 0x37, 0xd7, 0x13, 0xe2, 0xfe, 0x9b,
+    0x2d, 0x6d, 0xb6, 0x1f, 0xb7, 0x4d, 0xfc, 0x43, 0x7d, 0x37, 0x0e, 0xfe,
+    0x60, 0xa0, 0x1d, 0x47, 0x5f, 0xa9, 0x24, 0x20, 0x9d, 0xbc, 0x13, 0xd7,
+    0x05, 0x63, 0x5e, 0x39, 0x1f, 0x07, 0x96, 0xd0, 0x68, 0x56, 0xb2, 0xa3,
+    0x46, 0xbc, 0x2c, 0xeb, 0xf6, 0x0d, 0x5c, 0x42, 0x49, 0x48, 0xdd, 0x2b,
+    0x52, 0x7b, 0x6b, 0x99, 0xc9, 0x98, 0x01, 0xd2, 0x4c, 0x7e, 0xbf, 0xd3,
+    0x6d, 0x8d, 0x98, 0xc7, 0x19, 0x23, 0xd3, 0x0c, 0xc7, 0x8d, 0x5e, 0x1f,
+    0xfd, 0xad, 0xa9, 0x22, 0xd6, 0x7e, 0x64, 0x1a, 0x6b, 0xdd, 0xae, 0xbb,
+    0x37, 0x90, 0xdc, 0x79, 0x08, 0x2f, 0x84, 0x6d, 0x2b, 0x6a, 0x49, 0xa8,
+    0xc4, 0x7a, 0xe7, 0x33, 0xa7, 0x09, 0x4b, 0x7c, 0x5e, 0x95, 0x6d, 0xbb,
+    0x02, 0x83, 0xba, 0xc2, 0x48, 0x47, 0x8d, 0xbd, 0x85, 0x16, 0xc0, 0x59,
+    0x52, 0x34, 0x2f, 0x25, 0xeb, 0x21, 0x91, 0x9c, 0x17, 0x8e, 0x20, 0xf2,
+    0x68, 0x42, 0xc8, 0xd6, 0x96, 0x37, 0x47, 0x7b, 0xa8, 0x4c, 0xd1, 0xd8,
+    0x1e, 0x1a, 0x73, 0x73, 0x32, 0x61, 0xa9, 0x97, 0xb7, 0x4c, 0xae, 0xaa,
+    0xf0, 0xc0, 0xf8, 0xd3, 0xc4, 0x53, 0x56, 0x32, 0xbd, 0xfb, 0xb4, 0xfd,
+    0xeb, 0x64, 0xac, 0x0b, 0xc8, 0x5a, 0x73, 0xe0, 0x3d, 0xae, 0x9a, 0x01,
+    0x58, 0x6e, 0x3d, 0xb2, 0x4d, 0x7a, 0x00, 0x51, 0xc5, 0x1a, 0x0a, 0xe4,
+    0xa7, 0x45, 0xba, 0xa8, 0xb9, 0xdd, 0xfa, 0x6b, 0xb9, 0xfd, 0x33, 0xea,
+    0x7e, 0x17, 0x17, 0xf5, 0x6f, 0xdc, 0x85, 0x1f, 0x12, 0x80, 0xa9, 0xd9,
+    0xc7, 0x2f, 0x12, 0x9d, 0x6e, 0x73, 0x5a, 0x8e, 0x79, 0xf0, 0x01, 0x35,
+    0x07, 0x94, 0x98, 0x76, 0x66, 0x91, 0xc8, 0x52, 0x2b, 0xa5, 0x49, 0x2c,
+    0x7d, 0xaa, 0x74, 0xe2, 0x12, 0x4f, 0x87, 0x86, 0x52, 0x15, 0x6a, 0x40,
+    0x45, 0xbc, 0xaa, 0x02, 0x8d, 0x90, 0xb3, 0x2c, 0xe3, 0xa8, 0x3a, 0x36,
+    0xae, 0xe7, 0xb5, 0x2c, 0xa5, 0x10, 0x25, 0xed, 0x4f, 0xe8, 0x65, 0x10,
+    0x7c, 0xed, 0xec, 0x2f, 0x7b, 0x54, 0x08, 0x85, 0x79, 0x0e, 0xc1, 0x4d,
+    0x89, 0xde, 0x06, 0xbc, 0xb9, 0x6b, 0x7b, 0x78, 0x27, 0xc8, 0x69, 0x79,
+    0xe1, 0x89, 0xaf, 0xee, 0x9b, 0x35, 0xf7, 0x9a, 0xd9, 0xf2, 0x97, 0x8e,
+    0xc9, 0x69, 0x3c, 0xc5, 0xb2, 0xa6, 0x67, 0x2e, 0x7c, 0xca, 0x9b, 0x78,
+    0x73, 0x56, 0x08, 0x28, 0xce, 0xd5, 0x68, 0x41, 0xd0, 0x26, 0xa2, 0x5e,
+    0x70, 0xb3, 0xda, 0xdf, 0xfb, 0x71, 0x74, 0x35, 0x18, 0x03, 0x90, 0x7e,
+    0x58, 0x72, 0xb1, 0xb8, 0x76, 0x0d, 0x13, 0x51, 0x61, 0x2d, 0xc4, 0xa3,
+    0xca, 0x29, 0x5d, 0xa5, 0xee, 0x37, 0x58, 0x8d, 0x68, 0x50, 0xbc, 0x66,
+    0x73, 0xee, 0x6e, 0xa8, 0xf5, 0xce, 0x5d, 0x07, 0x8b, 0x56, 0xf8, 0xed,
+    0x71, 0xeb, 0x0c, 0x61, 0x24, 0x12, 0x07, 0x0a, 0xd0, 0x48, 0x5a, 0x3d,
+    0xa7, 0x03, 0xe8, 0xdd, 0x06, 0x0e, 0x85, 0xfb, 0x4f, 0xdc, 0x58, 0x3f,
+    0x80, 0x43, 0x6b, 0xb0, 0x43, 0xc7, 0x14, 0x21, 0x77, 0xc6, 0xd1, 0x29,
+    0x76, 0xbf, 0x54, 0x36, 0x32, 0x30, 0xa5, 0xef, 0xa0, 0x93, 0x01, 0x5e,
+    0x74, 0x44, 0x06, 0xfb, 0x1e, 0xd3, 0xef, 0xc5, 0xcb, 0x2e, 0x3f, 0x30,
+    0xe7, 0x3c, 0x2b, 0xfa, 0xfa, 0xa2, 0xac, 0x1c, 0xf3, 0xd5, 0xb0, 0x38,
+    0xeb, 0xe9, 0x33, 0xe6, 0xc8, 0x96, 0xcc, 0x22, 0x57, 0x3d, 0x39, 0x3e,
+    0xc6, 0x5d, 0xb4, 0x37, 0x86, 0xe0, 0xbd, 0x1f, 0x1c, 0xa8, 0x38, 0xc7,
+    0x79, 0x5a, 0x34, 0xca, 0x80, 0xed, 0x88, 0x60, 0xc0, 0x2e, 0x30, 0x77,
+    0x3c, 0x94, 0x98, 0x53, 0xf4, 0x76, 0x41, 0x72, 0xd5, 0xcd, 0x37, 0x10,
+    0x57, 0xdc, 0x6f, 0x6b, 0xed, 0xf7, 0x26, 0xd0, 0xab, 0xfb, 0xce, 0x0a,
+    0x30, 0x9e, 0x1d, 0xc7, 0xdd, 0x9b, 0xf7, 0xea, 0x70, 0x79, 0x8a, 0x0e,
+    0x5b, 0xcf, 0xee, 0x7a, 0xdc, 0x91, 0xe4, 0xa0, 0x66, 0x56, 0x55, 0xf3,
+    0x2c, 0xcd, 0x26, 0x6c, 0x0a, 0xc2, 0xe9, 0xef, 0xa4, 0xf8, 0x6f, 0xa4,
+    0xce, 0x7b, 0xce, 0xab, 0x6b, 0x21, 0x4b, 0xe0, 0xa5, 0x1f, 0x65, 0x3e,
+    0x88, 0x0e, 0xb5, 0x69, 0x74, 0x34, 0x0e, 0x96, 0x87, 0xeb, 0x77, 0x2a,
+    0x88, 0x93, 0x22, 0xba, 0x3e, 0xf0, 0x5a, 0x90, 0x76, 0x74, 0xf1, 0xfc,
+    0xa9, 0xb0, 0xc7, 0x56, 0xf9, 0xd0, 0xd3, 0x66, 0xa7, 0xea, 0x48, 0x14,
+    0x1a, 0x8e, 0xec, 0x76, 0xeb, 0x8c, 0x0b, 0x77, 0x8a, 0xad, 0x90, 0x39,
+    0x57, 0x70, 0xf5, 0x39, 0x71, 0xc0, 0x8c, 0x24, 0xf4, 0x74, 0xdf, 0x64,
+    0x72, 0x33, 0x15, 0xef, 0x7d, 0xa2, 0x33, 0x10, 0x19, 0xf0, 0xcd, 0xe7,
+    0xb1, 0xc9, 0x5a, 0x6d, 0x4d, 0x91, 0xda, 0x6a, 0xa2, 0x84, 0xf1, 0x4d,
+    0x34, 0x99, 0xea, 0xee, 0x93, 0x37, 0x57, 0x1f, 0x01, 0xce, 0xb4, 0xbd,
+    0x33, 0xe3, 0x3a, 0x47, 0xf5, 0x16, 0x54, 0xef, 0xb1, 0xac, 0xff, 0x8f,
+    0x6a, 0x3f, 0x28, 0x13, 0x74, 0xa7, 0x03, 0xdc, 0x89, 0xe6, 0x27, 0x16,
+    0x92, 0xb9, 0x6a, 0x7c, 0x5a, 0x23, 0x95, 0x2c, 0x62, 0x75, 0xe7, 0x96,
+    0x73, 0x0c, 0xc3, 0xbf, 0x26, 0xb4, 0x99, 0x32, 0xb3, 0x08, 0x18, 0xd7,
+    0x3c, 0x6a, 0xa0, 0x72, 0xb5, 0x97, 0x39, 0xba, 0x16, 0x4a, 0x87, 0x0c,
+    0x41, 0xf7, 0xaa, 0x18, 0x25, 0xef, 0xec, 0xaf, 0xaf, 0x2b, 0x37, 0xe3,
+    0x60, 0xe9, 0x65, 0xc3, 0xba, 0xec, 0x83, 0x0a, 0x0b, 0xe7, 0x9d, 0xac,
+    0x18, 0xe2, 0x48, 0xbd, 0x36, 0x46, 0x0b, 0xf1, 0xe5, 0x74, 0x5f, 0x8d,
+    0xe6, 0x1e, 0x56, 0x02, 0xdc, 0xfa, 0x3f, 0x59, 0x13, 0xe2, 0xff, 0x9a,
+    0x7f, 0x5b, 0xb7, 0xa2, 0xf7, 0x30, 0x34, 0x1d, 0xe0, 0x47, 0xc9, 0x19,
+    0x52, 0x9b, 0x95, 0x93, 0x81, 0x74, 0xeb, 0x27, 0xd1, 0x55, 0xad, 0x4f,
+    0x6f, 0xf1, 0x67, 0x97, 0x90, 0xf0, 0xce, 0x06, 0x45, 0xa2, 0x13, 0x4b,
+    0x8a, 0x7e, 0x72, 0xdc, 0x8b, 0xe4, 0x9a, 0x45, 0xa0, 0xf3, 0x29, 0xeb,
+    0x81, 0xb1, 0x21, 0x36, 0x77, 0x0d, 0x64, 0x4d, 0xe4, 0x19, 0x96, 0x82,
+    0xf7, 0x82, 0xa5, 0x15, 0x44, 0xa2, 0x55, 0xb4, 0x29, 0xfd, 0x58, 0x59,
+    0x14, 0x05, 0x2f, 0xe6, 0xb5, 0xa4, 0x1c, 0xb4, 0x80, 0xf8, 0x8e, 0xb1,
+    0x05, 0x17, 0x55, 0xe8, 0x23, 0xb9, 0x27, 0x91, 0x8c, 0x88, 0x2d, 0x0b,
+    0xbb, 0x8b, 0xcf, 0xac, 0x15, 0x55, 0x15, 0x1f, 0xde, 0x2a, 0xad, 0x03,
+    0xb2, 0xd9, 0x95, 0x2c, 0xb8, 0x4f, 0xeb, 0xe6, 0xe2, 0xf6, 0xf7, 0x79,
+    0x27, 0x93, 0x39, 0xc5, 0xbc, 0xde, 0x0d, 0x23, 0xd3, 0x0d, 0xa1, 0x4a,
+    0x3b, 0xdf, 0xfe, 0x0e, 0x4d, 0x5f, 0x23, 0x0a, 0xbd, 0xd5, 0x96, 0x97,
+    0x04, 0xce, 0xa0, 0xc4, 0x19, 0x61, 0x26, 0x4e, 0xb4, 0xf7, 0x9c, 0x29,
+    0xd2, 0xe7, 0x50, 0x95, 0xe9, 0xf1, 0x40, 0x94, 0xcf, 0x2a, 0x18, 0xbb,
+    0x7b, 0xbc, 0xab, 0x95, 0x59, 0x28, 0xc7, 0x5c, 0x1e, 0xe7, 0xd2, 0xf2,
+    0xd1, 0xd6, 0x63, 0xf2, 0x09, 0xab, 0xa5, 0x1b, 0x42, 0xa4, 0xd6, 0xf4,
+    0xa9, 0x7f, 0xdf, 0x06, 0xdb, 0xea, 0x6c, 0xea, 0xa7, 0xcd, 0x72, 0xfb,
+    0xbb, 0xb0, 0xe3, 0x35, 0xd2, 0x30, 0x3a, 0x57, 0x53, 0x1e, 0xce, 0x49,
+    0x31, 0x32, 0x0d, 0xfc, 0x92, 0x44, 0x73, 0x35, 0x6c, 0x43, 0xf1, 0x00,
+    0x02, 0xa8, 0x8a, 0x13, 0xb5, 0xd4, 0xd7, 0x6e, 0x09, 0x8c, 0xf0, 0x77,
+    0x61, 0xa5, 0x75, 0xfb, 0xb4, 0x6a, 0x5c, 0x45, 0x7d, 0x17, 0xdf, 0xb4,
+    0xf7, 0xed, 0x71, 0x5b, 0x85, 0x1d, 0xf0, 0xc5, 0x7a, 0x73, 0x5b, 0x42,
+    0xcc, 0x51, 0xea, 0xcf, 0xef, 0x91, 0x1f, 0xb1, 0x33, 0xed, 0x66, 0xbf,
+    0x73, 0xfa, 0x21, 0x0a, 0xaf, 0xa1, 0x2e, 0x02, 0x9b, 0x57, 0xd7, 0x5e,
+    0x41, 0xe1, 0xe4, 0xdf, 0x87, 0x19, 0x0c, 0x80, 0x91, 0x04, 0x59, 0x74,
+    0x57, 0x89, 0x58, 0xeb, 0x67, 0xfb, 0xda, 0xd5, 0xbb, 0xa8, 0x93, 0x12,
+    0x9f, 0xd6, 0xa4, 0x16, 0x3d, 0x86, 0x39, 0xe9, 0xa7, 0x44, 0x19, 0x36,
+    0x90, 0x27, 0x28, 0x8c, 0xd1, 0xaa, 0x1d, 0x16, 0x5a, 0x7e, 0x2b, 0xf1,
+    0x5f, 0xce, 0xec, 0xb4, 0x77, 0x5c, 0x66, 0x15, 0x10, 0x48, 0x38, 0x25,
+    0x08, 0x35, 0x59, 0x3e, 0x3b, 0xd8, 0x23, 0xb9, 0x4c, 0x94, 0x8d, 0x11,
+    0x43, 0x47, 0x0e, 0x5e, 0x0b, 0x7e, 0x34, 0x22, 0x56, 0x67, 0x69, 0x23,
+    0x8d, 0x21, 0x5c, 0xfa, 0xf1, 0x52, 0x08, 0x51, 0xeb, 0x6a, 0xb4, 0x89,
+    0x34, 0x3f, 0x8c, 0x7e, 0x49, 0x3c, 0x9a, 0x10, 0x77, 0xc8, 0xe0, 0xec,
+    0xac, 0x00, 0x8f, 0x61, 0xda, 0x82, 0x6e, 0xa0, 0x8e, 0x65, 0x53, 0xc7,
+    0x8f, 0x16, 0xb9, 0xda, 0xf6, 0xa9, 0x91, 0x74, 0x04, 0x0e, 0xc7, 0x45,
+    0x23, 0xb4, 0x02, 0x70, 0xcc, 0x12, 0xde, 0x9f, 0x1c, 0x6e, 0x99, 0x6a,
+    0x25, 0xb4, 0xe8, 0xaa, 0x6f, 0xf0, 0x94, 0xd0, 0x8c, 0x78, 0xf8, 0xea,
+    0x83, 0x88, 0x90, 0xd0, 0x75, 0xd8, 0xfa, 0xee, 0x48, 0x22, 0x41, 0x42,
+    0x3f, 0xec, 0xb7, 0x46, 0xe6, 0x7d, 0xaf, 0x14, 0x8a, 0x8f, 0x03, 0x46,
+    0x7e, 0x36, 0x11, 0x2c, 0xf2, 0xe8, 0xcc, 0x4c, 0xc2, 0x09, 0xaa, 0x0e,
+    0x42, 0x08, 0x63, 0x63, 0x80, 0xd6, 0x84, 0x03, 0xfa, 0x43, 0xdc, 0xb1,
+    0x05, 0xcf, 0x15, 0xca, 0x5c, 0xb2, 0xda, 0x8c, 0x84, 0x34, 0xa4, 0x23,
+    0x9b, 0xb0, 0x85, 0xf8, 0x47, 0xd2, 0xfd, 0xaa, 0xf2, 0xf1, 0x29, 0x0c,
+    0xc5, 0xd5, 0xdc, 0x56, 0x0b, 0x8c, 0xb6, 0xb5, 0xed, 0xfd, 0xff, 0x93,
+    0xd3, 0xec, 0x29, 0x27, 0x3b, 0x79, 0x5a, 0xda, 0x3b, 0xa0, 0xa0, 0xcc,
+    0x23, 0xac, 0x9f, 0x44, 0x65, 0xb6, 0xf2, 0xff, 0xc0, 0x4b, 0xb4, 0xb4,
+    0xbc, 0xcf, 0x07, 0x69, 0x75, 0xb3, 0x11, 0xb6, 0x28, 0x5b, 0x11, 0xfb,
+    0xab, 0x05, 0xd9, 0x4f, 0x8e, 0xea, 0x25, 0xcd, 0xf4, 0x8e, 0xdd, 0x93,
+    0x9b, 0x9f, 0xa4, 0x2b, 0x65, 0x90, 0xf4, 0x4e, 0x8a, 0x0a, 0x4a, 0x2d,
+    0xe3, 0xbd, 0xc9, 0x59, 0x4f, 0x91, 0xc6, 0x3d, 0x31, 0x26, 0x9a, 0xe1,
+    0x38, 0xe3, 0xb4, 0xaa, 0x4d, 0x56, 0x24, 0x6a, 0x62, 0xd5, 0x54, 0x38,
+    0x9d, 0x82, 0xf6, 0xa9, 0xfe, 0xef, 0x13, 0x7c, 0x4e, 0xcc, 0xcc, 0xd9,
+    0xe0, 0x3f, 0xd5, 0x0a, 0x54, 0x2a, 0xe8, 0xbf, 0x51, 0xc7, 0x98, 0xf3,
+    0x3d, 0xc5, 0xde, 0x46, 0x6d, 0x52, 0x10, 0x98, 0x47, 0x91, 0xa1, 0x2d,
+    0x5f, 0xa9, 0xc5, 0x0b, 0x14, 0xf0, 0x89, 0x2f, 0x6c, 0x8a, 0x1e, 0xec,
+    0xf6, 0x50, 0x51, 0x87, 0xca, 0x11, 0x2c, 0x97, 0x28, 0x28, 0x1d, 0x9c,
+    0x64, 0x0f, 0xaf, 0xe7, 0xbd, 0x4a, 0x89, 0x21, 0x9f, 0xf2, 0xdb, 0xf3,
+    0xd5, 0x85, 0x1e, 0x84, 0x9a, 0x5b, 0x84, 0x27, 0x7c, 0xc7, 0xb5, 0xde,
+    0xf6, 0x11, 0x6d, 0xb2, 0x4c, 0x6c, 0x38, 0x9d, 0x2e, 0x33, 0x8e, 0xf2,
+    0x18, 0x9e, 0xdd, 0x21, 0x6b, 0x75, 0xaf, 0x1a, 0x96, 0x81, 0x0c, 0x7b,
+    0x2e, 0xd8, 0xc5, 0xfb, 0x53, 0x56, 0x69, 0x8b, 0x43, 0x72, 0xa0, 0xd3,
+    0x61, 0xde, 0x39, 0x28, 0x4b, 0xd0, 0xc3, 0x86, 0x79, 0x80, 0x24, 0xb7,
+    0xf5, 0xa5, 0x7d, 0xf9, 0x9e, 0xf7, 0x56, 0x66, 0xc5, 0x8e, 0xd5, 0xae,
+    0x68, 0x3b, 0x34, 0x86, 0x61, 0x28, 0xe9, 0x09, 0xd1, 0x01, 0xf6, 0x07,
+    0x85, 0x11, 0x68, 0xf9, 0x1e, 0x60, 0x07, 0xe5, 0xca, 0x20, 0xb4, 0x8d,
+    0xeb, 0x67, 0x19, 0xdc, 0x8b, 0xd8, 0xd2, 0x85, 0x0e, 0xb6, 0xf9, 0x12,
+    0x4e, 0x7d, 0xf1, 0xeb, 0xa0, 0x5d, 0x0d, 0xe5, 0x1f, 0xa3, 0x19, 0xfc,
+    0x4e, 0x66, 0xbf, 0x0e, 0x9f, 0xc0, 0x84, 0xaa, 0x02, 0x79, 0x3f, 0xb0,
+    0x03, 0x5a, 0xf0, 0x81, 0xce, 0xbc, 0x2f, 0x22, 0x7d, 0x1f, 0xdd, 0x08,
+    0xf9, 0x28, 0x1c, 0xb4, 0xa0, 0xdf, 0x93, 0xa2, 0xd2, 0x32, 0xf8, 0xd0,
+    0xf1, 0x6c, 0x56, 0x57, 0xfb, 0x12, 0x0a, 0xc2, 0xbf, 0x1c, 0xf7, 0x74,
+    0xe0, 0x3d, 0x92, 0xac, 0xcf, 0xa4, 0xca, 0xf7, 0xb0, 0x6d, 0x1a, 0xd3,
+    0x13, 0x4e, 0xbf, 0x2b, 0xd2, 0x9c, 0x3a, 0x36, 0x94, 0x95, 0x3e, 0xfd,
+    0x8d, 0xa7, 0xdb, 0xb5, 0xa8, 0xcc, 0xc1, 0xf0, 0x4a, 0x59, 0x4a, 0xb9,
+    0xbe, 0x2c, 0xbe, 0x6a, 0x5b, 0x69, 0xc0, 0x00, 0xcb, 0xaf, 0x8f, 0xe2,
+    0x89, 0x45, 0x4d, 0x29, 0xa3, 0xf5, 0x03, 0xa3, 0xd3, 0xdb, 0xbe, 0x22,
+    0xbd, 0xbd, 0x06, 0x83, 0x69, 0xaf, 0xcd, 0x77, 0x4b, 0x13, 0xc7, 0x5b,
+    0x9f, 0xb9, 0x3e, 0xa7, 0xa0, 0x34, 0xe8, 0x6d, 0x90, 0xc6, 0x08, 0x11,
+    0x52, 0x53, 0x8f, 0x2a, 0x81, 0x8b, 0x47, 0x01, 0x6e, 0xab, 0x4d, 0x66,
+    0x3d, 0x2f, 0x2f, 0xc3, 0x41, 0xd7, 0x39, 0x7b, 0x17, 0x3e, 0x5a, 0xbb,
+    0xd2, 0x31, 0x0e, 0xbf, 0x74, 0x5b, 0x54, 0x1f, 0xf0, 0x0b, 0x10, 0x57,
+    0xc2, 0x53, 0x77, 0x4d, 0xe4, 0x3e, 0x0d, 0x29, 0xe6, 0xa2, 0xb0, 0x99,
+    0x0a, 0x96, 0xb8, 0x1c, 0x41, 0x99, 0x7d, 0xef, 0x6c, 0xe0, 0x67, 0xc7,
+    0x23, 0xc8, 0x1f, 0x8c, 0x69, 0x82, 0xd4, 0x64, 0x57, 0xda, 0x0d, 0xf6,
+    0x88, 0xea, 0x02, 0xf9, 0x3f, 0x2f, 0xdf, 0x11, 0x41, 0xa5, 0x3e, 0xab,
+    0x38, 0x16, 0x52, 0x72, 0xa4, 0xfc, 0xd7, 0xfd, 0x3a, 0x0f, 0x3a, 0xe2,
+    0xe0, 0xf2, 0x4b, 0xec, 0xc3, 0xc9, 0x81, 0x1b, 0x25, 0xed, 0x5d, 0xd0,
+    0x3b, 0xb4, 0xa3, 0x5f, 0x47, 0x81, 0x9f, 0x3a, 0x57, 0x72, 0x2a, 0xbf,
+    0x07, 0x86, 0x83, 0x98, 0xd4, 0x3f, 0xaf, 0xa7, 0x92, 0x6a, 0x0c, 0xe0,
+    0x4c, 0x3d, 0xc0, 0xff, 0x01, 0x5a, 0xaf, 0x94, 0x35, 0x39, 0x55, 0x60,
+    0x0d, 0x20, 0x4f, 0xf7, 0x7a, 0xac, 0x5c, 0xd1, 0xd1, 0xb0, 0x01, 0xe3,
+    0xed, 0xaf, 0x64, 0x22, 0xe6, 0xdb, 0xd9, 0x3e, 0xb5, 0x6f, 0x93, 0xbd,
+    0x03, 0xb4, 0x7b, 0x60, 0xcc, 0x77, 0x13, 0x98, 0xda, 0xd5, 0x59, 0xe4,
+    0x16, 0x1e, 0xfb, 0xff, 0x2a, 0x89, 0x05, 0x10, 0x4e, 0xca, 0x7a, 0xde,
+    0xa6, 0x44, 0xe6, 0x37, 0xf5, 0xd4, 0x5d, 0xa6, 0x9c, 0x86, 0x19, 0x1a,
+    0x6d, 0x78, 0xde, 0xb5, 0xd3, 0x4e, 0xbe, 0xfc, 0x21, 0x85, 0xb3, 0x3e,
+    0x73, 0xbb, 0x9e, 0x3e, 0x72, 0x60, 0xf1, 0x73, 0xfa, 0xec, 0xfb, 0x72,
+    0x0a, 0x91, 0x7c, 0xec, 0xd7, 0x21, 0x3f, 0xf2, 0x02, 0x08, 0x19, 0xfc,
+    0x68, 0x33, 0x45, 0x96, 0x3d, 0xe5, 0xab, 0x6d, 0x45, 0x8c, 0xef, 0x5c,
+    0x05, 0xb7, 0x57, 0x69, 0x75, 0x13, 0xe0, 0x88, 0x96, 0xba, 0x6e, 0x2e,
+    0x77, 0xea, 0x0a, 0x62, 0x90, 0x1d, 0x9e, 0xa0, 0x5e, 0xdd, 0xe7, 0xf2,
+    0x17, 0x29, 0x10, 0xb6, 0xa1, 0x01, 0x89, 0x58, 0xd4, 0xba, 0xcc, 0xf8,
+    0x36, 0x30, 0x58, 0x6a, 0x49, 0xb3, 0x24, 0xe0, 0x73, 0x20, 0x0e, 0xaa,
+    0x2c, 0xd4, 0xb8, 0x14, 0x91, 0xd5,
+};
+
+#endif
+
 static bssl::UniquePtr<EVP_PKEY> LoadExampleRSAKey() {
   bssl::UniquePtr<RSA> rsa(RSA_private_key_from_bytes(kExampleRSAKeyDER,
                                            sizeof(kExampleRSAKeyDER)));
@@ -1168,6 +1513,11 @@ TEST(EVPExtraTest, d2i_PrivateKey) {
   EXPECT_TRUE(
       ParsePrivateKey(EVP_PKEY_EC, kExampleECKeyDER, sizeof(kExampleECKeyDER)));
 
+#ifdef ENABLE_DILITHIUM
+  EXPECT_TRUE(ParsePrivateKey(EVP_PKEY_DILITHIUM3, kExampleDilithium3KeyDER,
+                              sizeof(kExampleDilithium3KeyDER)));
+#endif
+
   EXPECT_FALSE(ParsePrivateKey(EVP_PKEY_EC, kExampleBadECKeyDER,
                                sizeof(kExampleBadECKeyDER)));
   ERR_clear_error();
diff --git a/crypto/evp_extra/internal.h b/crypto/evp_extra/internal.h
index 26c823b40..528212cfb 100644
--- a/crypto/evp_extra/internal.h
+++ b/crypto/evp_extra/internal.h
@@ -23,17 +23,31 @@ typedef struct {
   char has_private;
 } X25519_KEY;
 
+#ifdef ENABLE_DILITHIUM
+
+typedef struct {
+  uint8_t pub[1952];
+  uint8_t priv[4000];
+  char has_private;
+} DILITHIUM3_KEY;
+
+#endif
+
 extern const EVP_PKEY_ASN1_METHOD dsa_asn1_meth;
 extern const EVP_PKEY_ASN1_METHOD ec_asn1_meth;
 extern const EVP_PKEY_ASN1_METHOD rsa_asn1_meth;
 extern const EVP_PKEY_ASN1_METHOD rsa_pss_asn1_meth;
 extern const EVP_PKEY_ASN1_METHOD ed25519_asn1_meth;
 extern const EVP_PKEY_ASN1_METHOD x25519_asn1_meth;
+#ifdef ENABLE_DILITHIUM
+extern const EVP_PKEY_ASN1_METHOD dilithium3_asn1_meth;
+#endif
 extern const EVP_PKEY_ASN1_METHOD kem_asn1_meth;
 
 extern const EVP_PKEY_METHOD ed25519_pkey_meth;
 extern const EVP_PKEY_METHOD x25519_pkey_meth;
 extern const EVP_PKEY_METHOD hkdf_pkey_meth;
+extern const EVP_PKEY_METHOD dilithium3_pkey_meth;
 extern const EVP_PKEY_METHOD kem_pkey_meth;
 
 // Returns a reference to the list |non_fips_pkey_evp_methods|. The list has
diff --git a/crypto/evp_extra/p_methods.c b/crypto/evp_extra/p_methods.c
index a6284e5b9..8d97d4978 100644
--- a/crypto/evp_extra/p_methods.c
+++ b/crypto/evp_extra/p_methods.c
@@ -10,6 +10,9 @@
 static const EVP_PKEY_METHOD *const non_fips_pkey_evp_methods[] = {
   &ed25519_pkey_meth,
   &x25519_pkey_meth,
+#ifdef ENABLE_DILITHIUM
+  &dilithium3_pkey_meth,
+#endif
   &kem_pkey_meth,
 };
 
@@ -20,6 +23,9 @@ static const EVP_PKEY_ASN1_METHOD *const asn1_evp_pkey_methods[] = {
   &dsa_asn1_meth,
   &ed25519_asn1_meth,
   &x25519_asn1_meth,
+#ifdef ENABLE_DILITHIUM
+  &dilithium3_asn1_meth,
+#endif
   &kem_asn1_meth,
 };
 
diff --git a/crypto/evp_extra/print.c b/crypto/evp_extra/print.c
index 925074e5a..3e15fe626 100644
--- a/crypto/evp_extra/print.c
+++ b/crypto/evp_extra/print.c
@@ -60,9 +60,15 @@
 #include <openssl/mem.h>
 #include <openssl/rsa.h>
 
+#include "internal.h"
 #include "../internal.h"
+#include "../fipsmodule/evp/internal.h"
 #include "../fipsmodule/rsa/internal.h"
 
+#ifdef ENABLE_DILITHIUM
+#include "../dilithium/sig_dilithium.h"
+#endif
+
 
 static int print_hex(BIO *bp, const uint8_t *data, size_t len, int off) {
   for (size_t i = 0; i < len; i++) {
@@ -305,6 +311,52 @@ static int eckey_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent) {
   return do_EC_KEY_print(bp, EVP_PKEY_get0_EC_KEY(pkey), indent, 2);
 }
 
+#ifdef ENABLE_DILITHIUM
+
+// Dilithium keys.
+
+static int do_dilithium3_print(BIO *bp, const EVP_PKEY *pkey, int off, int ptype) {
+  if (pkey == NULL) {
+    OPENSSL_PUT_ERROR(EVP, ERR_R_PASSED_NULL_PARAMETER);
+    return 0;
+  }
+
+  if (!BIO_indent(bp, off, 128)) {
+    return 0;
+  }
+
+  const DILITHIUM3_KEY *key = pkey->pkey.ptr;
+  int bit_len = 0;
+
+  if (ptype == 2) {
+    bit_len = DILITHIUM3_PRIVATE_KEY_BYTES;
+    if (BIO_printf(bp, "Private-Key: (%d bit)\n", bit_len) <= 0) {
+      return 0;
+    }
+    print_hex(bp, key->priv, bit_len, off);
+  } else {
+    bit_len = DILITHIUM3_PUBLIC_KEY_BYTES;
+    if (BIO_printf(bp, "Public-Key: (%d bit)\n", bit_len) <= 0) {
+      return 0;
+    }
+    int ret = print_hex(bp, key->pub, bit_len, off);
+    if (!ret) {
+      return 0;
+    }
+  }
+
+  return 1;
+}
+
+static int dilithium3_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent) {
+  return do_dilithium3_print(bp, pkey, indent, 1);
+}
+
+static int dilithium3_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent) {
+  return do_dilithium3_print(bp, pkey, indent, 2);
+}
+
+#endif
 
 typedef struct {
   int type;
@@ -332,6 +384,14 @@ static EVP_PKEY_PRINT_METHOD kPrintMethods[] = {
         eckey_priv_print,
         eckey_param_print,
     },
+#ifdef ENABLE_DILITHIUM
+    {
+        EVP_PKEY_DILITHIUM3,
+        dilithium3_pub_print,
+        dilithium3_priv_print,
+        NULL /* param_print */,
+    },
+#endif
 };
 
 static size_t kPrintMethodsLen = OPENSSL_ARRAY_SIZE(kPrintMethods);
diff --git a/crypto/fipsmodule/evp/digestsign.c b/crypto/fipsmodule/evp/digestsign.c
index 6abd7722e..8fbca41f6 100644
--- a/crypto/fipsmodule/evp/digestsign.c
+++ b/crypto/fipsmodule/evp/digestsign.c
@@ -236,7 +236,7 @@ int EVP_DigestSign(EVP_MD_CTX *ctx, uint8_t *out_sig, size_t *out_sig_len,
   }
 
   // This is executed when |uses_prehash| is not true, which is the case for
-  // Ed25519.
+  // Ed25519 and Dilithium.
   ret = ctx->pctx->pmeth->sign_message(ctx->pctx, out_sig, out_sig_len, data,
                                         data_len);
 end:
@@ -266,7 +266,7 @@ int EVP_DigestVerify(EVP_MD_CTX *ctx, const uint8_t *sig, size_t sig_len,
   }
 
   // This is executed when |uses_prehash| is not true, which is the case for
-  // Ed25519.
+  // Ed25519 and Dilithium.
   ret = ctx->pctx->pmeth->verify_message(ctx->pctx, sig, sig_len, data, len);
 
 end:
diff --git a/crypto/fipsmodule/evp/internal.h b/crypto/fipsmodule/evp/internal.h
index 1e7abb827..3d15203d9 100644
--- a/crypto/fipsmodule/evp/internal.h
+++ b/crypto/fipsmodule/evp/internal.h
@@ -284,8 +284,14 @@ struct evp_pkey_method_st {
 }; // EVP_PKEY_METHOD
 
 #define FIPS_EVP_PKEY_METHODS 4
+
+#ifdef ENABLE_DILITHIUM
+#define NON_FIPS_EVP_PKEY_METHODS 4
+#define ASN1_EVP_PKEY_METHODS 8
+#else
 #define NON_FIPS_EVP_PKEY_METHODS 3
 #define ASN1_EVP_PKEY_METHODS 7
+#endif
 
 struct fips_evp_pkey_methods {
   const EVP_PKEY_METHOD * methods[FIPS_EVP_PKEY_METHODS];
diff --git a/crypto/kyber/pqcrystals_kyber_ref_common/fips202.h b/crypto/kyber/pqcrystals_kyber_ref_common/fips202.h
index 9710f033f..7be8dfe1f 100644
--- a/crypto/kyber/pqcrystals_kyber_ref_common/fips202.h
+++ b/crypto/kyber/pqcrystals_kyber_ref_common/fips202.h
@@ -18,7 +18,6 @@
 #define FIPS202_NAMESPACE(s) FIPS202_PREFIX(s)
 #endif
 
-
 typedef struct {
   uint64_t s[25];
   unsigned int pos;
diff --git a/crypto/obj/obj_dat.h b/crypto/obj/obj_dat.h
index ff368562a..296a537ab 100644
--- a/crypto/obj/obj_dat.h
+++ b/crypto/obj/obj_dat.h
@@ -56,7 +56,7 @@
 
 /* This file is generated by crypto/obj/objects.go. */
 
-#define NUM_NID 975
+#define NUM_NID 976
 
 static const uint8_t kObjectData[] = {
     /* NID_rsadsi */
@@ -7176,6 +7176,18 @@ static const uint8_t kObjectData[] = {
     0x04,
     0x02,
     0x0a,
+    /* NID_DILITHIUM3_R3 */
+    0x2b,
+    0x06,
+    0x01,
+    0x04,
+    0x01,
+    0x02,
+    0x82,
+    0x0b,
+    0x07,
+    0x06,
+    0x05,
 };
 
 static const ASN1_OBJECT kObjects[NUM_NID] = {
@@ -8834,6 +8846,8 @@ static const ASN1_OBJECT kObjects[NUM_NID] = {
     {"KYBER512_R3", "KYBER512_R3", NID_KYBER512_R3, 0, NULL, 0},
     {"KYBER768_R3", "KYBER768_R3", NID_KYBER768_R3, 0, NULL, 0},
     {"KYBER1024_R3", "KYBER1024_R3", NID_KYBER1024_R3, 0, NULL, 0},
+    {"DILITHIUM3_R3", "DILITHIUM3_R3", NID_DILITHIUM3_R3, 11,
+     &kObjectData[6232], 0},
 };
 
 static const uint16_t kNIDsInShortNameOrder[] = {
@@ -8923,6 +8937,7 @@ static const uint16_t kNIDsInShortNameOrder[] = {
     63 /* DES-EDE3-OFB */,
     45 /* DES-OFB */,
     80 /* DESX-CBC */,
+    975 /* DILITHIUM3_R3 */,
     380 /* DOD */,
     116 /* DSA */,
     66 /* DSA-SHA */,
@@ -9817,6 +9832,7 @@ static const uint16_t kNIDsInLongNameOrder[] = {
     785 /* CA Repository */,
     959 /* CECPQ2 */,
     131 /* Code Signing */,
+    975 /* DILITHIUM3_R3 */,
     783 /* Diffie-Hellman based MAC */,
     382 /* Directory */,
     392 /* Domain */,
@@ -11662,5 +11678,6 @@ static const uint16_t kNIDsInOIDOrder[] = {
     153 /* 1.2.840.113549.1.12.10.1.4 (OBJ_crlBag) */,
     154 /* 1.2.840.113549.1.12.10.1.5 (OBJ_secretBag) */,
     155 /* 1.2.840.113549.1.12.10.1.6 (OBJ_safeContentsBag) */,
+    975 /* 1.3.6.1.4.1.2.267.7.6.5 (OBJ_DILITHIUM3_R3) */,
     34 /* 1.3.6.1.4.1.188.7.1.1.2 (OBJ_idea_cbc) */,
 };
diff --git a/crypto/obj/obj_mac.num b/crypto/obj/obj_mac.num
index 22a961770..be8a3d2dd 100644
--- a/crypto/obj/obj_mac.num
+++ b/crypto/obj/obj_mac.num
@@ -963,3 +963,4 @@ KYBER512		971
 KYBER512_R3		972
 KYBER768_R3		973
 KYBER1024_R3		974
+DILITHIUM3_R3		975
diff --git a/crypto/obj/obj_xref.c b/crypto/obj/obj_xref.c
index 21bde279d..e6646e8d7 100644
--- a/crypto/obj/obj_xref.c
+++ b/crypto/obj/obj_xref.c
@@ -89,6 +89,7 @@ static const nid_triple kTriples[] = {
     // digest "undef" indicates the caller should handle this explicitly.
     {NID_rsassaPss, NID_undef, NID_rsaEncryption},
     {NID_ED25519, NID_undef, NID_ED25519},
+    {NID_DILITHIUM3_R3, NID_undef, NID_DILITHIUM3_R3},
 };
 
 int OBJ_find_sigid_algs(int sign_nid, int *out_digest_nid, int *out_pkey_nid) {
diff --git a/crypto/obj/objects.txt b/crypto/obj/objects.txt
index 82fe3e466..487bcdc5e 100644
--- a/crypto/obj/objects.txt
+++ b/crypto/obj/objects.txt
@@ -1376,3 +1376,8 @@ nist_sha3hashalgs 10		: SHA3-512		: sha3-512
  : KYBER512_R3
  : KYBER768_R3
  : KYBER1024_R3
+
+# OID for DILITHIUM3 SIG Round-3. These are temp values from
+# https://github.com/IETF-Hackathon/pqc-certificates/blob/master/docs/oid_mapping.md
+# as we await NIST to release official OIDs.
+1 3 6 1 4 1 2 267 7 6 5 : DILITHIUM3_R3
diff --git a/crypto/x509/algorithm.c b/crypto/x509/algorithm.c
index a0798a34c..2c69ca47a 100644
--- a/crypto/x509/algorithm.c
+++ b/crypto/x509/algorithm.c
@@ -96,6 +96,12 @@ int x509_digest_sign_algorithm(EVP_MD_CTX *ctx, X509_ALGOR *algor) {
     return X509_ALGOR_set0(algor, OBJ_nid2obj(NID_ED25519), V_ASN1_UNDEF, NULL);
   }
 
+#ifdef ENABLE_DILITHIUM
+  if (EVP_PKEY_id(pkey) == EVP_PKEY_DILITHIUM3) {
+    return X509_ALGOR_set0(algor, OBJ_nid2obj(NID_DILITHIUM3_R3), V_ASN1_UNDEF, NULL);
+  }
+#endif
+
   // Default behavior: look up the OID for the algorithm/hash pair and encode
   // that.
   const EVP_MD *digest = EVP_MD_CTX_md(ctx);
@@ -152,7 +158,11 @@ int x509_digest_verify_init(EVP_MD_CTX *ctx, const X509_ALGOR *sigalg,
     if (sigalg_nid == NID_rsassaPss) {
       return x509_rsa_pss_to_ctx(ctx, sigalg, pkey);
     }
+#ifdef ENABLE_DILITHIUM
+    if (sigalg_nid == NID_ED25519 || sigalg_nid == NID_DILITHIUM3_R3) {
+#else
     if (sigalg_nid == NID_ED25519) {
+#endif
       if (sigalg->parameter != NULL) {
         OPENSSL_PUT_ERROR(X509, X509_R_INVALID_PARAMETER);
         return 0;
diff --git a/crypto/x509/x509_test.cc b/crypto/x509/x509_test.cc
index 38e3c23d4..e9d298085 100644
--- a/crypto/x509/x509_test.cc
+++ b/crypto/x509/x509_test.cc
@@ -34,6 +34,7 @@
 #include <openssl/x509v3.h>
 
 #include "internal.h"
+#include "../evp_extra/internal.h"
 #include "../internal.h"
 #include "../test/test_util.h"
 #include "../x509v3/internal.h"
@@ -555,6 +556,368 @@ w1AH9efZBw==
 -----END CERTIFICATE-----
 )";
 
+#ifdef ENABLE_DILITHIUM
+
+static const char kDilithium3Cert[] = R"(
+-----BEGIN CERTIFICATE-----
+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
+-----END CERTIFICATE-----
+)";
+
+// kDilithium3CertNull is an invalid self-signed Dilithium3 with an explicit
+// NULL in the signature algorithm.
+static const char kDilithium3CertNull[] = R"(
+-----BEGIN CERTIFICATE-----
+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
+-----END CERTIFICATE-----
+)";
+
+// kDilithium3CertParam is an invalid self-signed Dilithium3 with an explicit
+// NULL in the AlgorithmIdentifier parameters.
+static const char kDilithium3CertParam[] = R"(
+-----BEGIN CERTIFICATE-----
+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
+-----END CERTIFICATE-----
+)";
+
+#endif
+
 // kSANTypesLeaf is a leaf certificate (signed by |kSANTypesRoot|) which
 // contains SANS for example.com, test@example.com, 127.0.0.1, and
 // https://example.com/. (The latter is useless for now since crypto/x509
@@ -2302,6 +2665,80 @@ TEST(X509Test, Ed25519Sign) {
   ASSERT_TRUE(SignatureRoundTrips(md_ctx.get(), pub.get()));
 }
 
+#ifdef ENABLE_DILITHIUM
+
+TEST(X509Test, Dilithium3SignVerifyCert) {
+  // This test generates a Dilithium3 keypair, generates and signs a
+  // certificate, then verifies the certificate's signature.
+  EVP_PKEY_CTX *pkey_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DILITHIUM3, nullptr);
+  ASSERT_NE(pkey_ctx, nullptr);
+  EVP_PKEY *pkey = EVP_PKEY_new();
+  ASSERT_NE(pkey, nullptr);
+  EXPECT_TRUE(EVP_PKEY_keygen_init(pkey_ctx));
+  EXPECT_TRUE(EVP_PKEY_keygen(pkey_ctx, &pkey));
+
+  bssl::UniquePtr<X509> leaf =
+      MakeTestCert("Intermediate", "Leaf", pkey, /*is_ca=*/false);
+  ASSERT_TRUE(leaf);
+
+  bssl::ScopedEVP_MD_CTX md_ctx;
+  EVP_DigestSignInit(md_ctx.get(), nullptr, nullptr, nullptr, pkey);
+  ASSERT_TRUE(X509_sign_ctx(leaf.get(), md_ctx.get()));
+
+  ASSERT_TRUE(X509_verify(leaf.get(), pkey));
+
+  EVP_PKEY_CTX_free(pkey_ctx);
+  EVP_PKEY_free(pkey);
+}
+
+TEST(X509Test, TestDilithium3) {
+  // This test decodes a Dilithium3 certificate from the PEM encoding,
+  // extracts the public key, and then verifies the certificate.
+  bssl::UniquePtr<X509> cert(CertFromPEM(kDilithium3Cert));
+  ASSERT_TRUE(cert);
+
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
+
+  ASSERT_TRUE(X509_verify(cert.get(), pkey.get()));
+}
+
+TEST(X509Test, TestBadSigAlgDilithium3) {
+  // This test generates a Dilithium3 certificate from the PEM encoding
+  // kDilithium3CertNull that has an explicit NULL in the signature algorithm.
+  // After extracting the public key, verification should fail.
+  bssl::UniquePtr<X509> cert(CertFromPEM(kDilithium3CertNull));
+  ASSERT_TRUE(cert);
+
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
+
+  ASSERT_FALSE(X509_verify(cert.get(), pkey.get()));
+  uint32_t err = ERR_get_error();
+  ASSERT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
+  ASSERT_EQ(X509_R_SIGNATURE_ALGORITHM_MISMATCH, ERR_GET_REASON(err));
+  ERR_clear_error();
+}
+
+TEST(X509Test, TestBadParamsDilithium3) {
+  // This test generates a Dilithium3 certificate from the PEM encoding
+  // kDilithium3CertParam that has an explicit NULL in the signature algorithm.
+  // After extracting the public key, verification should fail.
+  bssl::UniquePtr<X509> cert(CertFromPEM(kDilithium3CertParam));
+  ASSERT_TRUE(cert);
+
+  bssl::UniquePtr<EVP_PKEY> pkey(X509_get_pubkey(cert.get()));
+  ASSERT_TRUE(pkey);
+
+  ASSERT_FALSE(X509_verify(cert.get(), pkey.get()));
+  uint32_t err = ERR_get_error();
+  ASSERT_EQ(ERR_LIB_X509, ERR_GET_LIB(err));
+  ASSERT_EQ(X509_R_INVALID_PARAMETER, ERR_GET_REASON(err));
+  ERR_clear_error();
+}
+
+#endif
+
 static bool PEMToDER(bssl::UniquePtr<uint8_t> *out, size_t *out_len,
                      const char *pem) {
   bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(pem, strlen(pem)));
diff --git a/include/openssl/evp.h b/include/openssl/evp.h
index 830e603c2..bc17f0e81 100644
--- a/include/openssl/evp.h
+++ b/include/openssl/evp.h
@@ -124,14 +124,17 @@ OPENSSL_EXPORT int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
 // EVP_PKEY_size returns the maximum size, in bytes, of a signature signed by
 // |pkey|. For an RSA key, this returns the number of bytes needed to represent
 // the modulus. For an EC key, this returns the maximum size of a DER-encoded
-// ECDSA signature. For a KEM key, this returns the sum of the size of the
-// public key and the secret key.
+// ECDSA signature. For a Dilithium key, this returns the signature byte size.
+// For a KEM key, this returns the sum of the size of the public key and the
+// secret key.
 OPENSSL_EXPORT int EVP_PKEY_size(const EVP_PKEY *pkey);
 
 // EVP_PKEY_bits returns the "size", in bits, of |pkey|. For an RSA key, this
 // returns the bit length of the modulus. For an EC key, this returns the bit
-// length of the group order. For a KEM, this returns the the sum of the size
+// length of the group order. For a Dilithium key, this returns the bit length
+// of the public key. For a KEM, this returns the sum of the size
 // of the public key and the secret key.
+
 OPENSSL_EXPORT int EVP_PKEY_bits(const EVP_PKEY *pkey);
 
 // EVP_PKEY_id returns the type of |pkey|, which is one of the |EVP_PKEY_*|
@@ -184,6 +187,11 @@ OPENSSL_EXPORT EC_KEY *EVP_PKEY_get1_EC_KEY(const EVP_PKEY *pkey);
 
 #define EVP_PKEY_KYBER512 NID_KYBER512
 #define EVP_PKEY_HKDF NID_hkdf
+
+#ifdef ENABLE_DILITHIUM
+#define EVP_PKEY_DILITHIUM3 NID_DILITHIUM3_R3
+#endif
+
 #define EVP_PKEY_KEM NID_kem
 
 // EVP_PKEY_assign sets the underlying key of |pkey| to |key|, which must be of
@@ -252,10 +260,11 @@ OPENSSL_EXPORT int EVP_marshal_private_key_v2(CBB *cbb, const EVP_PKEY *key);
 
 // Raw keys
 //
-// Some keys types support a "raw" serialization. Currently the only supported
-// raw format is Ed25519, where the public key and private key formats are those
-// specified in RFC 8032. Note the RFC 8032 private key format is the 32-byte
-// prefix of |ED25519_sign|'s 64-byte private key.
+// Some keys types support a "raw" serialization. For Ed25519 the public key
+// and private key formats are those specified in RFC 8032. Note the RFC 8032
+// private key format is the 32-byte prefix of |ED25519_sign|'s 64-byte private
+// key. For Dilithium the public key and private key formats are those specified
+// in draft-ietf-lamps-dilithium-certificates-00 and the Dilithium specification.
 
 // EVP_PKEY_new_raw_private_key returns a newly allocated |EVP_PKEY| wrapping a
 // private key of the specified type. It returns NULL on error.
@@ -299,8 +308,8 @@ OPENSSL_EXPORT int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey,
 // signing options.
 //
 // For single-shot signing algorithms which do not use a pre-hash, such as
-// Ed25519, |type| should be NULL. The |EVP_MD_CTX| itself is unused but is
-// present so the API is uniform. See |EVP_DigestSign|.
+// Ed25519 and Dilithium, |type| should be NULL. The |EVP_MD_CTX| itself is
+// unused but is present so the API is uniform. See |EVP_DigestSign|.
 //
 // This function does not mutate |pkey| for thread-safety purposes and may be
 // used concurrently with other non-mutating functions on |pkey|.
@@ -355,8 +364,8 @@ OPENSSL_EXPORT int EVP_DigestSign(EVP_MD_CTX *ctx, uint8_t *out_sig,
 // signing options.
 //
 // For single-shot signing algorithms which do not use a pre-hash, such as
-// Ed25519, |type| should be NULL. The |EVP_MD_CTX| itself is unused but is
-// present so the API is uniform. See |EVP_DigestVerify|.
+// Ed25519 and Dilithium, |type| should be NULL. The |EVP_MD_CTX| itself is
+// unused but is present so the API is uniform. See |EVP_DigestVerify|.
 //
 // This function does not mutate |pkey| for thread-safety purposes and may be
 // used concurrently with other non-mutating functions on |pkey|.
@@ -564,7 +573,8 @@ OPENSSL_EXPORT int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
 // Otherwise, |*sig_len| must contain the number of bytes of space available at
 // |sig|. If sufficient, the signature will be written to |sig| and |*sig_len|
 // updated with the true length. This function will fail for signature
-// algorithms like Ed25519 that do not support signing pre-hashed inputs.
+// algorithms like Ed25519 and Dilithium that do not support signing pre-hashed
+// inputs.
 //
 // WARNING: |digest| must be the output of some hash function on the data to be
 // signed. Passing unhashed inputs will not result in a secure signature scheme.
@@ -587,7 +597,8 @@ OPENSSL_EXPORT int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
 
 // EVP_PKEY_verify verifies that |sig_len| bytes from |sig| are a valid
 // signature for |digest|. This function will fail for signature
-// algorithms like Ed25519 that do not support signing pre-hashed inputs.
+// algorithms like Ed25519 and Dilithium that do not support signing pre-hashed
+// inputs.
 //
 // WARNING: |digest| must be the output of some hash function on the data to be
 // verified. Passing unhashed inputs will not result in a secure signature
diff --git a/include/openssl/nid.h b/include/openssl/nid.h
index 897b70d8e..5889f1e22 100644
--- a/include/openssl/nid.h
+++ b/include/openssl/nid.h
@@ -4297,6 +4297,10 @@ extern "C" {
 #define SN_KYBER1024_R3 "KYBER1024_R3"
 #define NID_KYBER1024_R3 974
 
+#define SN_DILITHIUM3_R3 "DILITHIUM3_R3"
+#define NID_DILITHIUM3_R3 975
+#define OBJ_DILITHIUM3_R3 1L, 3L, 6L, 1L, 4L, 1L, 2L, 267L, 7L, 6L, 5L
+
 #if defined(__cplusplus)
 } /* extern C */
 #endif
diff --git a/include/openssl/pem.h b/include/openssl/pem.h
index d53e27345..639d9e7ba 100644
--- a/include/openssl/pem.h
+++ b/include/openssl/pem.h
@@ -88,6 +88,12 @@ extern "C" {
 #define PEM_STRING_PUBLIC "PUBLIC KEY"
 #define PEM_STRING_RSA "RSA PRIVATE KEY"
 #define PEM_STRING_RSA_PUBLIC "RSA PUBLIC KEY"
+
+#ifdef ENABLE_DILITHIUM
+#define PEM_STRING_DILITHIUM3 "DILITHIUM3 PRIVATE KEY"
+#define PEM_STRING_DILITHIUM3_PUBLIC "DILITHIUM3 PUBLIC KEY"
+#endif
+
 #define PEM_STRING_DSA "DSA PRIVATE KEY"
 #define PEM_STRING_DSA_PUBLIC "DSA PUBLIC KEY"
 #define PEM_STRING_EC "EC PRIVATE KEY"
diff --git a/tests/ci/run_benchmark_build_tests.sh b/tests/ci/run_benchmark_build_tests.sh
index f23470bd0..2a8ac05c3 100755
--- a/tests/ci/run_benchmark_build_tests.sh
+++ b/tests/ci/run_benchmark_build_tests.sh
@@ -15,7 +15,11 @@ openssl_3_0_branch='openssl-3.0.5'
 
 function build_aws_lc_fips {
   echo "building aws-lc in FIPS mode"
-  run_build -DCMAKE_INSTALL_PREFIX="${install_dir}/aws-lc-fips" -DFIPS=1 -DCMAKE_BUILD_TYPE=RelWithDebInfo
+  run_build \
+      -DCMAKE_INSTALL_PREFIX="${install_dir}/aws-lc-fips" \
+      -DFIPS=1 \
+      -DENABLE_DILITHIUM=ON \
+      -DCMAKE_BUILD_TYPE=RelWithDebInfo
   pushd "$BUILD_ROOT"
   ninja install
   popd
diff --git a/tests/ci/run_posix_tests.sh b/tests/ci/run_posix_tests.sh
index 22e8827ed..ec222221d 100755
--- a/tests/ci/run_posix_tests.sh
+++ b/tests/ci/run_posix_tests.sh
@@ -11,6 +11,9 @@ build_and_test
 echo "Testing AWS-LC in release mode."
 build_and_test -DCMAKE_BUILD_TYPE=Release
 
+echo "Testing AWS-LC with Dilithium3 enabled."
+build_and_test -DENABLE_DILITHIUM=ON
+
 echo "Testing AWS-LC small compilation."
 build_and_test -DOPENSSL_SMALL=1 -DCMAKE_BUILD_TYPE=Release
 
diff --git a/tool/speed.cc b/tool/speed.cc
index d83e703f7..e5e27b9bc 100644
--- a/tool/speed.cc
+++ b/tool/speed.cc
@@ -797,12 +797,80 @@ static bool SpeedSingleKEM(const std::string &name, int nid, const std::string &
   return true;
 }
 
-
 static bool SpeedKEM(std::string selected) {
   return SpeedSingleKEM("Kyber512_R3", NID_KYBER512_R3, selected) &&
          SpeedSingleKEM("Kyber768_R3", NID_KYBER768_R3, selected) &&
          SpeedSingleKEM("Kyber1024_R3", NID_KYBER1024_R3, selected);
 }
+
+#if defined(ENABLE_DILITHIUM)
+
+static bool SpeedDigestSignNID(const std::string &name, int nid,
+                            const std::string &selected) {
+  if (!selected.empty() && name.find(selected) == std::string::npos) {
+    return true;
+  }
+
+  // Setup CTX for Sign/Verify Operations
+  BM_NAMESPACE::UniquePtr<EVP_PKEY_CTX> pkey_ctx(EVP_PKEY_CTX_new_id(nid, nullptr));
+
+  // Setup CTX for Keygen Operations
+  if (!pkey_ctx || EVP_PKEY_keygen_init(pkey_ctx.get()) != 1) {
+    return false;
+  }
+
+  EVP_PKEY *key = NULL;
+
+  TimeResults results;
+  if (!TimeFunction(&results, [&pkey_ctx, &key]() -> bool {
+        return EVP_PKEY_keygen(pkey_ctx.get(), &key);
+      })) {
+    return false;
+  }
+  results.Print(name + " keygen");
+
+  // Setup CTX for Sign operations
+  bssl::ScopedEVP_MD_CTX md_ctx;
+
+  // message to be signed
+  static const uint8_t msg[32] = {0};
+  size_t msg_len = 32;
+
+  // to keep this function generic, we obtain the signature size (different for
+  // each algorithm) at run time by attempting a sign with a NULL signature.
+  // The sign algorithm must support calling NULL to obtain the signature length
+  size_t sig_len = 0;
+  EVP_DigestSignInit(md_ctx.get(), NULL, NULL, NULL, key);
+  EVP_DigestSign(md_ctx.get(), NULL, &sig_len, msg, msg_len);
+  std::unique_ptr<uint8_t[]> signature(new uint8_t[sig_len]);
+
+
+  if (!TimeFunction(&results, [&md_ctx, &signature, &sig_len, msg_len ]() -> bool {
+        return EVP_DigestSign(md_ctx.get(), signature.get(), &sig_len, msg, msg_len);
+      })) {
+    return false;
+  }
+  results.Print(name + " signing");
+
+  // Verify
+  if (!TimeFunction(&results, [&md_ctx, &signature, &sig_len, msg_len ]() -> bool {
+        return EVP_DigestVerify(md_ctx.get(), signature.get(), sig_len, msg, msg_len);
+      })) {
+    return false;
+  }
+  results.Print(name + " verify");
+
+  EVP_PKEY_free(key);
+  md_ctx.Reset();
+  return true;
+}
+
+static bool SpeedDigestSign(const std::string &selected) {
+  return SpeedDigestSignNID("Dilithium3", EVP_PKEY_DILITHIUM3, selected);
+}
+
+#endif
+
 #endif
 
 static bool SpeedAESBlock(const std::string &name, unsigned bits,
@@ -1338,7 +1406,6 @@ static bool SpeedECDSA(const std::string &selected) {
          SpeedECDSACurve("ECDSA secp256k1", NID_secp256k1, selected);
 }
 
-
 #if !defined(OPENSSL_1_0_BENCHMARK)
 static bool SpeedECMULCurve(const std::string &name, int nid,
                        const std::string &selected) {
@@ -2343,6 +2410,9 @@ bool Speed(const std::vector<std::string> &args) {
 #if !defined(OPENSSL_BENCHMARK)
      ||
      !SpeedKEM(selected) ||
+#if defined(ENABLE_DILITHIUM)
+     !SpeedDigestSign(selected) ||
+#endif
      !SpeedAEADSeal(EVP_aead_aes_128_gcm(), "AEAD-AES-128-GCM", kTLSADLen, selected) ||
      !SpeedAEADOpen(EVP_aead_aes_128_gcm(), "AEAD-AES-128-GCM", kTLSADLen, selected) ||
      !SpeedAEADSeal(EVP_aead_aes_256_gcm(), "AEAD-AES-256-GCM", kTLSADLen, selected) ||
