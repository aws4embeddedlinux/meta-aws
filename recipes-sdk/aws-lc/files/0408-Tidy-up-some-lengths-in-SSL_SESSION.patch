From 22585a05ab4439cf6c222241ae47cd5395a3c6c1 Mon Sep 17 00:00:00 2001
From: David Benjamin <davidben@google.com>
Date: Sat, 10 Dec 2022 00:46:54 -0500
Subject: [PATCH] Tidy up some lengths in SSL_SESSION

Normally these would be size_t, but we try to reduce per-connection
memory in libssl, so use uint8_t, then add asserts, checks, and casts as
appropriate.

Bug: 516
Change-Id: Ibdd9d88f2b05173daee2db5f6fb77d619302bfdf
Reviewed-on: https://boringssl-review.googlesource.com/c/boringssl/+/58547
Reviewed-by: Bob Beck <bbe@google.com>
Commit-Queue: David Benjamin <davidben@google.com>
(cherry picked from commit 44a389a7fce31013b5953038d4231f33cbf2ba9d)
---
 ssl/handshake_client.cc | 11 +++++++++--
 ssl/internal.h          |  4 ++--
 ssl/ssl_asn1.cc         | 10 +++++++---
 ssl/tls13_both.cc       |  3 ++-
 4 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index c1b6e63c3..34c58aacf 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -858,11 +858,18 @@ static enum ssl_hs_wait_t do_read_server_hello(SSL_HANDSHAKE *hs) {
       ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
       return ssl_hs_error;
     }
-    // Note: session_id could be empty.
-    hs->new_session->session_id_length = CBS_len(&server_hello.session_id);
+
+    // Save the session ID from the server. This may be empty if the session
+    // isn't resumable, or if we'll receive a session ticket later.
+    assert(CBS_len(&server_hello.session_id) <= SSL3_SESSION_ID_SIZE);
+    static_assert(SSL3_SESSION_ID_SIZE <= UINT8_MAX,
+                  "max session ID is too large");
+    hs->new_session->session_id_length =
+        static_cast<uint8_t>(CBS_len(&server_hello.session_id));
     OPENSSL_memcpy(hs->new_session->session_id,
                    CBS_data(&server_hello.session_id),
                    CBS_len(&server_hello.session_id));
+
     hs->new_session->cipher = hs->new_cipher;
   }
 
diff --git a/ssl/internal.h b/ssl/internal.h
index 39efc0d1f..619902d59 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -3902,11 +3902,11 @@ struct ssl_session_st {
   // session. In TLS 1.3 and up, it is the resumption PSK for sessions handed to
   // the caller, but it stores the resumption secret when stored on |SSL|
   // objects.
-  int secret_length = 0;
+  uint8_t secret_length = 0;
   uint8_t secret[SSL_MAX_MASTER_KEY_LENGTH] = {0};
 
   // session_id - valid?
-  unsigned session_id_length = 0;
+  uint8_t session_id_length = 0;
   uint8_t session_id[SSL_MAX_SSL_SESSION_ID_LENGTH] = {0};
   // this is used to determine whether the session is being reused in
   // the appropriate context. It is up to the application to set this,
diff --git a/ssl/ssl_asn1.cc b/ssl/ssl_asn1.cc
index 96cb79545..3311246c6 100644
--- a/ssl/ssl_asn1.cc
+++ b/ssl/ssl_asn1.cc
@@ -486,7 +486,7 @@ static int SSL_SESSION_parse_bounded_octet_string(CBS *cbs, uint8_t *out,
     return 0;
   }
   OPENSSL_memcpy(out, CBS_data(&value), CBS_len(&value));
-  *out_len = (uint8_t)CBS_len(&value);
+  *out_len = static_cast<uint8_t>(CBS_len(&value));
   return 1;
 }
 
@@ -578,9 +578,13 @@ UniquePtr<SSL_SESSION> SSL_SESSION_parse(CBS *cbs,
     return nullptr;
   }
   OPENSSL_memcpy(ret->session_id, CBS_data(&session_id), CBS_len(&session_id));
-  ret->session_id_length = CBS_len(&session_id);
+  static_assert(SSL3_MAX_SSL_SESSION_ID_LENGTH <= UINT8_MAX,
+                "max session ID is too large");
+  ret->session_id_length = static_cast<uint8_t>(CBS_len(&session_id));
   OPENSSL_memcpy(ret->secret, CBS_data(&secret), CBS_len(&secret));
-  ret->secret_length = CBS_len(&secret);
+  static_assert(SSL_MAX_MASTER_KEY_LENGTH <= UINT8_MAX,
+                "max secret is too large");
+  ret->secret_length = static_cast<uint8_t>(CBS_len(&secret));
 
   CBS child;
   uint64_t timeout;
diff --git a/ssl/tls13_both.cc b/ssl/tls13_both.cc
index 62e3fffeb..1929746d7 100644
--- a/ssl/tls13_both.cc
+++ b/ssl/tls13_both.cc
@@ -508,7 +508,8 @@ bool tls13_add_certificate(SSL_HANDSHAKE *hs) {
   if (!ssl->method->init_message(ssl, cbb.get(), body,
                                  SSL3_MT_COMPRESSED_CERTIFICATE) ||
       !CBB_add_u16(body, hs->cert_compression_alg_id) ||
-      !CBB_add_u24(body, msg.size()) ||
+      msg.size() > (1u << 24) - 1 ||  //
+      !CBB_add_u24(body, static_cast<uint32_t>(msg.size())) ||
       !CBB_add_u24_length_prefixed(body, &compressed)) {
     OPENSSL_PUT_ERROR(SSL, ERR_R_INTERNAL_ERROR);
     return false;
