From 1b2a9f735b2897c9782bc6738efd50ee070b0b26 Mon Sep 17 00:00:00 2001
From: John Harrison <jargh@amazon.com>
Date: Wed, 26 Jan 2022 19:51:35 -0800
Subject: [PATCH] Add non-BMI forms of remaining x86 P-384 functions

s2n-bignum original commit: https://github.com/awslabs/s2n-bignum/commit/8aae21a6a9fc63e682d69669f7beb2b0b34f85cb
---
 arm/p384/bignum_cmul_p384.S            |   2 +
 arm/p384/bignum_deamont_p384.S         |   2 +
 arm/p384/bignum_demont_p384.S          |   2 +
 arm/p384/bignum_mod_n384.S             |   2 +
 arm/p384/bignum_mod_p384.S             |   2 +
 arm/p384/bignum_tomont_p384.S          |   2 +
 arm/p384/bignum_triple_p384.S          |   2 +
 x86_att/p384/bignum_cmul_p384_alt.S    | 171 +++++++++++++
 x86_att/p384/bignum_deamont_p384_alt.S | 176 ++++++++++++++
 x86_att/p384/bignum_demont_p384_alt.S  | 131 ++++++++++
 x86_att/p384/bignum_mod_n384_alt.S     | 226 ++++++++++++++++++
 x86_att/p384/bignum_mod_p384_alt.S     | 225 ++++++++++++++++++
 x86_att/p384/bignum_tomont_p384_alt.S  | 316 +++++++++++++++++++++++++
 x86_att/p384/bignum_triple_p384.S      |   4 +-
 x86_att/p384/bignum_triple_p384_alt.S  | 151 ++++++++++++
 15 files changed, 1411 insertions(+), 3 deletions(-)
 create mode 100644 x86_att/p384/bignum_cmul_p384_alt.S
 create mode 100644 x86_att/p384/bignum_deamont_p384_alt.S
 create mode 100644 x86_att/p384/bignum_demont_p384_alt.S
 create mode 100644 x86_att/p384/bignum_mod_n384_alt.S
 create mode 100644 x86_att/p384/bignum_mod_p384_alt.S
 create mode 100644 x86_att/p384/bignum_tomont_p384_alt.S
 create mode 100644 x86_att/p384/bignum_triple_p384_alt.S

diff --git a/arm/p384/bignum_cmul_p384.S b/arm/p384/bignum_cmul_p384.S
index 7f1e1e3c9..1b956b64a 100644
--- a/arm/p384/bignum_cmul_p384.S
+++ b/arm/p384/bignum_cmul_p384.S
@@ -25,6 +25,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_cmul_p384
+        .globl  bignum_cmul_p384_alt
         .text
         .balign 4
 
@@ -55,6 +56,7 @@
 
 
 bignum_cmul_p384:
+bignum_cmul_p384_alt:
 
 // First do the multiply, straightforwardly, getting [h; d5; ...; d0]
 
diff --git a/arm/p384/bignum_deamont_p384.S b/arm/p384/bignum_deamont_p384.S
index f237d6533..42006882b 100644
--- a/arm/p384/bignum_deamont_p384.S
+++ b/arm/p384/bignum_deamont_p384.S
@@ -27,6 +27,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_deamont_p384
+        .globl  bignum_deamont_p384_alt
         .text
         .balign 4
 
@@ -88,6 +89,7 @@
 #define w x10
 
 bignum_deamont_p384:
+bignum_deamont_p384_alt:
 
 // Set up an initial window with the input x and an extra leading zero
 
diff --git a/arm/p384/bignum_demont_p384.S b/arm/p384/bignum_demont_p384.S
index 35852513a..05e084c14 100644
--- a/arm/p384/bignum_demont_p384.S
+++ b/arm/p384/bignum_demont_p384.S
@@ -27,6 +27,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_demont_p384
+        .globl  bignum_demont_p384_alt
         .text
         .balign 4
 
@@ -88,6 +89,7 @@
 #define w x10
 
 bignum_demont_p384:
+bignum_demont_p384_alt:
 
 // Set up an initial window with the input x and an extra leading zero
 
diff --git a/arm/p384/bignum_mod_n384.S b/arm/p384/bignum_mod_n384.S
index 3cd37ecaa..bae1d4918 100644
--- a/arm/p384/bignum_mod_n384.S
+++ b/arm/p384/bignum_mod_n384.S
@@ -26,6 +26,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_mod_n384
+        .globl  bignum_mod_n384_alt
         .text
         .balign 4
 
@@ -73,6 +74,7 @@
                 movk    nn, n3, lsl #48
 
 bignum_mod_n384:
+bignum_mod_n384_alt:
 
 // If the input is already <= 5 words long, go to a trivial "copy" path
 
diff --git a/arm/p384/bignum_mod_p384.S b/arm/p384/bignum_mod_p384.S
index a8491eebd..dc3c904ad 100644
--- a/arm/p384/bignum_mod_p384.S
+++ b/arm/p384/bignum_mod_p384.S
@@ -24,6 +24,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_mod_p384
+        .globl  bignum_mod_p384_alt
         .text
         .balign 4
 
@@ -51,6 +52,7 @@
 
 
 bignum_mod_p384:
+bignum_mod_p384_alt:
 
 // If the input is already <= 5 words long, go to a trivial "copy" path
 
diff --git a/arm/p384/bignum_tomont_p384.S b/arm/p384/bignum_tomont_p384.S
index 4c651b052..08c378e44 100644
--- a/arm/p384/bignum_tomont_p384.S
+++ b/arm/p384/bignum_tomont_p384.S
@@ -24,6 +24,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_tomont_p384
+        .globl  bignum_tomont_p384_alt
         .text
         .balign 4
 
@@ -70,6 +71,7 @@
                 adc     d5, d5, t3
 
 bignum_tomont_p384:
+bignum_tomont_p384_alt:
 
 #define d0 x2
 #define d1 x3
diff --git a/arm/p384/bignum_triple_p384.S b/arm/p384/bignum_triple_p384.S
index b5db48d79..f9a311f19 100644
--- a/arm/p384/bignum_triple_p384.S
+++ b/arm/p384/bignum_triple_p384.S
@@ -27,6 +27,7 @@
 // ----------------------------------------------------------------------------
 
         .globl  bignum_triple_p384
+        .globl  bignum_triple_p384_alt
         .text
         .balign 4
 
@@ -62,6 +63,7 @@
 
 
 bignum_triple_p384:
+bignum_triple_p384_alt:
 
 // Load the inputs
 
diff --git a/x86_att/p384/bignum_cmul_p384_alt.S b/x86_att/p384/bignum_cmul_p384_alt.S
new file mode 100644
index 000000000..8baa6245c
--- /dev/null
+++ b/x86_att/p384/bignum_cmul_p384_alt.S
@@ -0,0 +1,171 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Multiply by a single word modulo p_384, z := (c * x) mod p_384, assuming
+// x reduced
+// Inputs c, x[6]; output z[6]
+//
+//    extern void bignum_cmul_p384_alt
+//     (uint64_t z[static 6], uint64_t c, uint64_t x[static 6]);
+//
+// Standard x86-64 ABI: RDI = z, RSI = c, RDX = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_cmul_p384_alt
+        .text
+
+#define z %rdi
+
+// Temporarily moved here for initial multiply
+#define x %rcx
+
+// Likewise this is thrown away after initial multiply
+#define m %rsi
+
+#define a %rax
+#define c %rcx
+#define d %rdx
+
+#define d0 %r8
+#define d1 %r9
+#define d2 %r10
+#define d3 %r11
+#define d4 %r12
+#define d5 %rsi
+
+// Multiplier again for second stage
+#define q %rcx
+
+#define ashort %eax
+#define dshort %edx
+
+#define cshort %ecx
+#define qshort %ecx
+
+bignum_cmul_p384_alt:
+
+// We seem to need (just!) one extra register, which we need to save and restore
+
+                pushq   %r12
+
+// Shuffle inputs (since we want %rdx for the high parts of products)
+
+                movq    %rdx, x
+
+// Multiply, accumulating the result as 2^384 * h + [d5;d4;d3;d2;d1;d0]
+// but actually immediately producing q = h + 1, our quotient approximation,
+// by adding 1 to it. Note that by hypothesis x is reduced mod p_384, so our
+// product is <= (2^64 - 1) * (p_384 - 1) and hence  h <= 2^64 - 2, meaning
+// there is no danger this addition of 1 could wrap.
+
+                movq    (x), a
+                mulq    m
+                movq    a, d0
+                movq    d, d1
+
+                movq    8(x), a
+                mulq    m
+                xorq    d2, d2
+                addq    a, d1
+                adcq    d, d2
+
+                movq    16(x), a
+                mulq    m
+                xorq    d3, d3
+                addq    a, d2
+                adcq    d, d3
+
+                movq    24(x), a
+                mulq    m
+                xorq    d4, d4
+                addq    a, d3
+                adcq    d, d4
+
+                movq    32(x), a
+                mulq    m
+                addq    a, d4
+                adcq    $0, d
+
+                movq    m, a
+                movq    d, d5
+                mulq     40(x)
+                movl    $1, qshort
+
+                addq    a, d5
+                adcq    d, q
+
+// It's easy to see -p_384 <= z - q * p_384 < p_384, so we just need to
+// subtract q * p_384 and then correct if that is negative by adding p_384.
+//
+// Write p_384 = 2^384 - r where r = 2^128 + 2^96 - 2^32 + 1
+//
+// We want z - q * (2^384 - r)
+//       = (2^384 * h + l) - q * (2^384 - r)
+//       = 2^384 * (h - q) + (l + q * r)
+//       = 2^384 * (-1) + (l + q * r)
+
+                movq    $0xffffffff00000001, a
+                mulq    q
+                addq    a, d0
+                adcq    d, d1
+                adcq    q, d2
+                movq    q, a
+                sbbq    c, c
+                movl    $0x00000000ffffffff, dshort
+                negq    c
+                mulq    d
+                addq    a, d1
+                adcq    d, d2
+                adcq    c, d3
+                adcq    $0, d4
+                adcq    $0, d5
+                sbbq    c, c
+                notq    c
+
+// The net c value is now the top word of the 7-word answer, hence will
+// be -1 if we need a corrective addition, 0 otherwise, usable as a mask.
+// Now use that mask for a masked addition of p_384, which again is in
+// fact done by a masked subtraction of 2^384 - p_384, so that we only
+// have three nonzero digits and so can avoid using another register.
+
+                movl    $0x00000000ffffffff, dshort
+                xorq    a, a
+                andq    c, d
+                subq    d, a
+                andq    $1, c
+
+                subq    a, d0
+                movq    d0, (z)
+                sbbq    d, d1
+                movq    d1, 8(z)
+                sbbq    c, d2
+                movq    d2, 16(z)
+                sbbq    $0, d3
+                movq    d3, 24(z)
+                sbbq    $0, d4
+                movq    d4, 32(z)
+                sbbq    $0, d5
+                movq    d5, 40(z)
+
+// Return
+
+                popq    %r12
+                ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_deamont_p384_alt.S b/x86_att/p384/bignum_deamont_p384_alt.S
new file mode 100644
index 000000000..fbcabd60c
--- /dev/null
+++ b/x86_att/p384/bignum_deamont_p384_alt.S
@@ -0,0 +1,176 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert from almost-Montgomery form, z := (x / 2^384) mod p_384
+// Input x[6]; output z[6]
+//
+//    extern void bignum_deamont_p384_alt
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// Convert a 6-digit bignum x out of its (optionally almost) Montgomery form,
+// "almost" meaning any 6-digit input will work, with no range restriction.
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_deamont_p384_alt
+        .text
+
+#define z %rdi
+#define x %rsi
+
+// Additional temps in the correction phase
+
+#define u %rax
+#define v %rcx
+#define w %rdx
+
+#define vshort %ecx
+
+// Core one-step "short" Montgomery reduction macro. Takes input in
+// [d5;d4;d3;d2;d1;d0] and returns result in [d6;d5;d4;d3;d2;d1],
+// adding to the existing [d5;d4;d3;d2;d1] and re-using d0 as a
+// temporary internally, as well as %rax, %rcx and %rdx.
+// It is OK for d6 and d0 to be the same register (they often are)
+//
+// We want to add (2^384 - 2^128 - 2^96 + 2^32 - 1) * w
+// where w = [d0 + (d0<<32)] mod 2^64
+//
+//       montreds(d6,d5,d4,d3,d2,d1,d0)
+
+#define montreds(d6,d5,d4,d3,d2,d1,d0)                                  \
+/* Our correction multiplier is w = [d0 + (d0<<32)] mod 2^64 */         \
+                movq    d0, %rcx ;                                        \
+                shlq    $32, %rcx ;                                        \
+                addq    d0, %rcx ;                                        \
+/* Construct [%rax;%rdx;d0;-] = (2^384 - p_384) * w            */         \
+/* We know the lowest word will cancel so we can re-use d0   */         \
+/* and %rcx as temps.                                         */         \
+                movq    $0xffffffff00000001, %rax ;                        \
+                mulq    %rcx;                                            \
+                movq    %rdx, d0 ;                                        \
+                movq    $0x00000000ffffffff, %rax ;                        \
+                mulq    %rcx;                                            \
+                addq    %rax, d0 ;                                        \
+                movl    $0, %eax ;                                         \
+                adcq    %rcx, %rdx ;                                       \
+                adcl    %eax, %eax ;                                       \
+/* Now subtract that and add 2^384 * w                       */         \
+                subq    d0, d1 ;                                         \
+                sbbq    %rdx, d2 ;                                        \
+                sbbq    %rax, d3 ;                                        \
+                sbbq    $0, d4 ;                                          \
+                sbbq    $0, d5 ;                                          \
+                movq    %rcx, d6 ;                                        \
+                sbbq    $0, d6
+
+bignum_deamont_p384_alt:
+
+// Save more registers to play with
+
+        pushq   %r12
+        pushq   %r13
+
+// Set up an initial window [%r13,%r12,%r11,%r10,%r9,%r8] = x
+
+        movq    (x), %r8
+        movq    8(x), %r9
+        movq    16(x), %r10
+        movq    24(x), %r11
+        movq    32(x), %r12
+        movq    40(x), %r13
+
+// Montgomery reduce window 0
+
+        montreds(%r8,%r13,%r12,%r11,%r10,%r9,%r8)
+
+// Montgomery reduce window 1
+
+        montreds(%r9,%r8,%r13,%r12,%r11,%r10,%r9)
+
+// Montgomery reduce window 2
+
+        montreds(%r10,%r9,%r8,%r13,%r12,%r11,%r10)
+
+// Montgomery reduce window 3
+
+        montreds(%r11,%r10,%r9,%r8,%r13,%r12,%r11)
+
+// Montgomery reduce window 4
+
+        montreds(%r12,%r11,%r10,%r9,%r8,%r13,%r12)
+
+// Montgomery reduce window 5
+
+        montreds(%r13,%r12,%r11,%r10,%r9,%r8,%r13)
+
+// Do a test addition of dd = [%r13;%r12;%r11;%r10;%r9;%r8] and
+// 2^384 - p_384 = [0;0;0;1;v;u], hence setting CF iff
+// dd + (2^384 - p_384) >= 2^384, hence iff dd >= p_384.
+
+        movq    $0xffffffff00000001, u
+        movl    $0x00000000ffffffff, vshort
+
+        movq    %r8, w
+        addq    u, w
+        movq    %r9, w
+        adcq    v, w
+        movq    %r10, w
+        adcq    $1, w
+        movq    %r11, w
+        adcq    $0, w
+        movq    %r12, w
+        adcq    $0, w
+        movq    %r13, w
+        adcq    $0, w
+
+// Convert CF to a bitmask in w
+
+        sbbq    w, w
+
+// Masked addition of 2^384 - p_384, hence subtraction of p_384
+
+        andq    w, u
+        andq    w, v
+        andq    $1, w
+
+        addq   u, %r8
+        adcq   v, %r9
+        adcq   w, %r10
+        adcq   $0, %r11
+        adcq   $0, %r12
+        adcq   $0, %r13
+
+// Write back the result
+
+        movq    %r8, (z)
+        movq    %r9, 8(z)
+        movq    %r10, 16(z)
+        movq    %r11, 24(z)
+        movq    %r12, 32(z)
+        movq    %r13, 40(z)
+
+// Restore registers and return
+
+        popq    %r13
+        popq    %r12
+
+        ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_demont_p384_alt.S b/x86_att/p384/bignum_demont_p384_alt.S
new file mode 100644
index 000000000..d624057e9
--- /dev/null
+++ b/x86_att/p384/bignum_demont_p384_alt.S
@@ -0,0 +1,131 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert from Montgomery form z := (x / 2^384) mod p_384, assuming x reduced
+// Input x[6]; output z[6]
+//
+//    extern void bignum_demont_p384_alt
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// This assumes the input is < p_384 for correctness. If this is not the case,
+// use the variant "bignum_deamont_p384" instead.
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_demont_p384_alt
+        .text
+
+#define z %rdi
+#define x %rsi
+
+// Core one-step "short" Montgomery reduction macro. Takes input in
+// [d5;d4;d3;d2;d1;d0] and returns result in [d6;d5;d4;d3;d2;d1],
+// adding to the existing [d5;d4;d3;d2;d1] and re-using d0 as a
+// temporary internally, as well as %rax, %rcx and %rdx.
+// It is OK for d6 and d0 to be the same register (they often are)
+//
+// We want to add (2^384 - 2^128 - 2^96 + 2^32 - 1) * w
+// where w = [d0 + (d0<<32)] mod 2^64
+//
+//       montreds(d6,d5,d4,d3,d2,d1,d0)
+
+#define montreds(d6,d5,d4,d3,d2,d1,d0)                                  \
+/* Our correction multiplier is w = [d0 + (d0<<32)] mod 2^64 */         \
+                movq    d0, %rcx ;                                        \
+                shlq    $32, %rcx ;                                        \
+                addq    d0, %rcx ;                                        \
+/* Construct [%rax;%rdx;d0;-] = (2^384 - p_384) * w            */         \
+/* We know the lowest word will cancel so we can re-use d0   */         \
+/* and %rcx as temps.                                         */         \
+                movq    $0xffffffff00000001, %rax ;                        \
+                mulq    %rcx;                                            \
+                movq    %rdx, d0 ;                                        \
+                movq    $0x00000000ffffffff, %rax ;                        \
+                mulq    %rcx;                                            \
+                addq    %rax, d0 ;                                        \
+                movl    $0, %eax ;                                         \
+                adcq    %rcx, %rdx ;                                       \
+                adcl    %eax, %eax ;                                       \
+/* Now subtract that and add 2^384 * w                       */         \
+                subq    d0, d1 ;                                         \
+                sbbq    %rdx, d2 ;                                        \
+                sbbq    %rax, d3 ;                                        \
+                sbbq    $0, d4 ;                                          \
+                sbbq    $0, d5 ;                                          \
+                movq    %rcx, d6 ;                                        \
+                sbbq    $0, d6
+
+bignum_demont_p384_alt:
+
+// Save more registers to play with
+
+        pushq   %r12
+        pushq   %r13
+
+// Set up an initial window [%r13,%r12,%r11,%r10,%r9,%r8] = x
+
+        movq    (x), %r8
+        movq    8(x), %r9
+        movq    16(x), %r10
+        movq    24(x), %r11
+        movq    32(x), %r12
+        movq    40(x), %r13
+
+// Montgomery reduce window 0
+
+        montreds(%r8,%r13,%r12,%r11,%r10,%r9,%r8)
+
+// Montgomery reduce window 1
+
+        montreds(%r9,%r8,%r13,%r12,%r11,%r10,%r9)
+
+// Montgomery reduce window 2
+
+        montreds(%r10,%r9,%r8,%r13,%r12,%r11,%r10)
+
+// Montgomery reduce window 3
+
+        montreds(%r11,%r10,%r9,%r8,%r13,%r12,%r11)
+
+// Montgomery reduce window 4
+
+        montreds(%r12,%r11,%r10,%r9,%r8,%r13,%r12)
+
+// Montgomery reduce window 5
+
+        montreds(%r13,%r12,%r11,%r10,%r9,%r8,%r13)
+
+// Write back the result
+
+        movq    %r8, (z)
+        movq    %r9, 8(z)
+        movq    %r10, 16(z)
+        movq    %r11, 24(z)
+        movq    %r12, 32(z)
+        movq    %r13, 40(z)
+
+// Restore registers and return
+
+        popq    %r13
+        popq    %r12
+
+        ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_mod_n384_alt.S b/x86_att/p384/bignum_mod_n384_alt.S
new file mode 100644
index 000000000..ecc0f410e
--- /dev/null
+++ b/x86_att/p384/bignum_mod_n384_alt.S
@@ -0,0 +1,226 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Reduce modulo group order, z := x mod n_384
+// Input x[k]; output z[6]
+//
+//    extern void bignum_mod_n384_alt
+//     (uint64_t z[static 6], uint64_t k, uint64_t *x);
+//
+// Reduction is modulo the group order of the NIST curve P-384.
+//
+// Standard x86-64 ABI: RDI = z, RSI = k, RDX = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_mod_n384_alt
+        .text
+
+#define z %rdi
+#define k %rsi
+#define x %rcx
+
+#define m0 %r8
+#define m1 %r9
+#define m2 %r10
+#define m3 %r11
+#define m4 %r12
+#define m5 %r13
+#define d %r14
+
+#define n0 %rax
+#define n1 %rbx
+#define n2 %rdx
+
+#define q %rbp
+#define c %rbx
+
+#define n0short %eax
+#define qshort %ebp
+
+bignum_mod_n384_alt:
+
+// Save extra registers
+
+                pushq   %rbp
+                pushq   %rbx
+                pushq   %r12
+                pushq   %r13
+                pushq   %r14
+
+// If the input is already <= 5 words long, go to a trivial "copy" path
+
+                cmpq    $6, k
+                jc      shortinput
+
+// Otherwise load the top 6 digits (top-down) and reduce k by 6
+
+                subq    $6, k
+                movq    40(%rdx,k,8), m5
+                movq    32(%rdx,k,8), m4
+                movq    24(%rdx,k,8), m3
+                movq    16(%rdx,k,8), m2
+                movq    8(%rdx,k,8), m1
+                movq    (%rdx,k,8), m0
+
+// Move x into another register to leave %rdx free for multiplies and use of n2
+
+                movq    %rdx, x
+
+// Reduce the top 6 digits mod n_384 (a conditional subtraction of n_384)
+
+                movq    $0x1313e695333ad68d, n0
+                movq    $0xa7e5f24db74f5885, n1
+                movq    $0x389cb27e0bc8d220, n2
+
+                addq    n0, m0
+                adcq    n1, m1
+                adcq    n2, m2
+                adcq    $0, m3
+                adcq    $0, m4
+                adcq    $0, m5
+                sbbq    d, d
+                notq    d
+                andq    d, n0
+                andq    d, n1
+                andq    d, n2
+                subq    n0, m0
+                sbbq    n1, m1
+                sbbq    n2, m2
+                sbbq    $0, m3
+                sbbq    $0, m4
+                sbbq    $0, m5
+
+// Now do (k-6) iterations of 7->6 word modular reduction
+
+                testq   k, k
+                jz      writeback
+
+loop:
+
+// Compute q = min (m5 + 1) (2^64 - 1)
+
+                movl    $1, qshort
+                addq    m5, q
+                sbbq    d, d
+                orq     d, q
+
+// Load the next digit so current m to reduce = [m5;m4;m3;m2;m1;m0;d]
+
+                movq    -8(x,k,8), d
+
+// Now form [m5;m4;m3;m2;m1;m0;d] = m - q * n_384
+
+                subq    q, m5
+                movq    $0x1313e695333ad68d, %rax
+                mulq    q
+                addq    %rax, d
+                adcq    %rdx, m0
+                sbbq    c, c
+                movq    $0xa7e5f24db74f5885, %rax
+                mulq    q
+                subq    c, %rdx
+                addq    %rax, m0
+                adcq    %rdx, m1
+                sbbq    c, c
+                movq    $0x389cb27e0bc8d220, n0
+                mulq    q
+                subq    c, %rdx
+                addq    %rax, m1
+                adcq    %rdx, m2
+                adcq    $0, m3
+                adcq    $0, m4
+                adcq    $0, m5
+
+// Now our top word m5 is either zero or all 1s. Use it for a masked
+// addition of n_384, which we can do by a *subtraction* of
+// 2^384 - n_384 from our portion
+
+                movq    $0x1313e695333ad68d, n0
+                andq    m5, n0
+                movq    $0xa7e5f24db74f5885, n1
+                andq    m5, n1
+                movq    $0x389cb27e0bc8d220, n2
+                andq    m5, n2
+
+                subq    n0, d
+                sbbq    n1, m0
+                sbbq    n2, m1
+                sbbq    $0, m2
+                sbbq    $0, m3
+                sbbq    $0, m4
+
+// Now shuffle registers up and loop
+
+                movq    m4, m5
+                movq    m3, m4
+                movq    m2, m3
+                movq    m1, m2
+                movq    m0, m1
+                movq    d, m0
+
+                decq    k
+                jnz     loop
+
+// Write back
+
+writeback:
+
+                movq    m0, (z)
+                movq    m1, 8(z)
+                movq    m2, 16(z)
+                movq    m3, 24(z)
+                movq    m4, 32(z)
+                movq    m5, 40(z)
+
+// Restore registers and return
+
+                popq    %r14
+                popq    %r13
+                popq    %r12
+                popq    %rbx
+                popq    %rbp
+                ret
+
+shortinput:
+
+                xorq    m0, m0
+                xorq    m1, m1
+                xorq    m2, m2
+                xorq    m3, m3
+                xorq    m4, m4
+                xorq    m5, m5
+
+                testq   k, k
+                jz      writeback
+                movq    (%rdx), m0
+                decq    k
+                jz      writeback
+                movq    8(%rdx), m1
+                decq    k
+                jz      writeback
+                movq    16(%rdx), m2
+                decq    k
+                jz      writeback
+                movq    24(%rdx), m3
+                decq    k
+                jz      writeback
+                movq    32(%rdx), m4
+                jmp     writeback
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_mod_p384_alt.S b/x86_att/p384/bignum_mod_p384_alt.S
new file mode 100644
index 000000000..b486a61fb
--- /dev/null
+++ b/x86_att/p384/bignum_mod_p384_alt.S
@@ -0,0 +1,225 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Reduce modulo field characteristic, z := x mod p_384
+// Input x[k]; output z[6]
+//
+//    extern void bignum_mod_p384_alt
+//     (uint64_t z[static 6], uint64_t k, uint64_t *x);
+//
+// Standard x86-64 ABI: RDI = z, RSI = k, RDX = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_mod_p384_alt
+        .text
+
+#define z %rdi
+#define k %rsi
+#define x %rcx
+
+#define m0 %r8
+#define m1 %r9
+#define m2 %r10
+#define m3 %r11
+#define m4 %r12
+#define m5 %r13
+#define d %r14
+
+#define n0 %rax
+#define n1 %rbx
+#define n2 %rdx
+
+// Both alias n1
+
+#define q %rbx
+#define c %rbx
+
+#define n0short %eax
+#define n1short %ebx
+#define qshort %ebx
+
+
+bignum_mod_p384_alt:
+
+// Save extra registers
+
+                pushq   %rbx
+                pushq   %r12
+                pushq   %r13
+                pushq   %r14
+
+// If the input is already <= 5 words long, go to a trivial "copy" path
+
+                cmpq    $6, k
+                jc      shortinput
+
+// Otherwise load the top 6 digits (top-down) and reduce k by 6
+
+                subq    $6, k
+                movq    40(%rdx,k,8), m5
+                movq    32(%rdx,k,8), m4
+                movq    24(%rdx,k,8), m3
+                movq    16(%rdx,k,8), m2
+                movq    8(%rdx,k,8), m1
+                movq    (%rdx,k,8), m0
+
+// Move x into another register to leave %rdx free for multiplies and use of n2
+
+                movq    %rdx, x
+
+// Reduce the top 6 digits mod p_384 (a conditional subtraction of p_384)
+
+                movl    $0x00000000ffffffff, n0short
+                movq    $0xffffffff00000000, n1
+                movq    $0xfffffffffffffffe, n2
+
+                subq    n0, m0
+                sbbq    n1, m1
+                sbbq    n2, m2
+                sbbq    $-1, m3
+                sbbq    $-1, m4
+                sbbq    $-1, m5
+
+                sbbq    d, d
+                andq    d, n0
+                andq    d, n1
+                andq    d, n2
+                addq    n0, m0
+                adcq    n1, m1
+                adcq    n2, m2
+                adcq    d, m3
+                adcq    d, m4
+                adcq    d, m5
+
+// Now do (k-6) iterations of 7->6 word modular reduction
+
+                testq   k, k
+                jz      writeback
+
+loop:
+
+// Compute q = min (m5 + 1) (2^64 - 1)
+
+                movl    $1, qshort
+                addq    m5, q
+                sbbq    d, d
+                orq     d, q
+
+// Load the next digit so current m to reduce = [m5;m4;m3;m2;m1;m0;d]
+
+                movq    -8(x,k,8), d
+
+// Now form [m5;m4;m3;m2;m1;m0;d] = m - q * p_384. To use an addition for
+// the main calculation we do (m - 2^384 * q) + q * (2^384 - p_384)
+// where 2^384 - p_384 = [0;0;0;1;0x00000000ffffffff;0xffffffff00000001].
+// The extra subtraction of 2^384 * q is the first instruction.
+
+                subq    q, m5
+                movq    $0xffffffff00000001, %rax
+                mulq    q
+                addq    %rax, d
+                adcq    %rdx, m0
+                adcq    q, m1
+                movq    q, %rax
+                sbbq    c, c
+                movl    $0x00000000ffffffff, %edx
+                negq    c
+                mulq    %rdx
+                addq    %rax, m0
+                adcq    %rdx, m1
+                adcq    c, m2
+                adcq    $0, m3
+                adcq    $0, m4
+                adcq    $0, m5
+
+// Now our top word m5 is either zero or all 1s. Use it for a masked
+// addition of p_384, which we can do by a *subtraction* of
+// 2^384 - p_384 from our portion
+
+                movq    $0xffffffff00000001, n0
+                andq    m5, n0
+                movl    $0x00000000ffffffff, n1short
+                andq    m5, n1
+                andq    $1, m5
+
+                subq    n0, d
+                sbbq    n1, m0
+                sbbq    m5, m1
+                sbbq    $0, m2
+                sbbq    $0, m3
+                sbbq    $0, m4
+
+// Now shuffle registers up and loop
+
+                movq    m4, m5
+                movq    m3, m4
+                movq    m2, m3
+                movq    m1, m2
+                movq    m0, m1
+                movq    d, m0
+
+                decq    k
+                jnz     loop
+
+// Write back
+
+writeback:
+
+                movq    m0, (z)
+                movq    m1, 8(z)
+                movq    m2, 16(z)
+                movq    m3, 24(z)
+                movq    m4, 32(z)
+                movq    m5, 40(z)
+
+// Restore registers and return
+
+                popq    %r14
+                popq    %r13
+                popq    %r12
+                popq    %rbx
+                ret
+
+shortinput:
+
+                xorq    m0, m0
+                xorq    m1, m1
+                xorq    m2, m2
+                xorq    m3, m3
+                xorq    m4, m4
+                xorq    m5, m5
+
+                testq   k, k
+                jz      writeback
+                movq    (%rdx), m0
+                decq    k
+                jz      writeback
+                movq    8(%rdx), m1
+                decq    k
+                jz      writeback
+                movq    16(%rdx), m2
+                decq    k
+                jz      writeback
+                movq    24(%rdx), m3
+                decq    k
+                jz      writeback
+                movq    32(%rdx), m4
+                jmp     writeback
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_tomont_p384_alt.S b/x86_att/p384/bignum_tomont_p384_alt.S
new file mode 100644
index 000000000..a26a66fad
--- /dev/null
+++ b/x86_att/p384/bignum_tomont_p384_alt.S
@@ -0,0 +1,316 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Convert to Montgomery form z := (2^384 * x) mod p_384
+// Input x[6]; output z[6]
+//
+//    extern void bignum_tomont_p384_alt
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_tomont_p384_alt
+        .text
+
+#define z %rdi
+#define x %rsi
+
+// Some temp registers for the last correction stage
+
+#define d %rax
+#define u %rdx
+#define v %rcx
+#define w %rsi
+
+#define vshort %ecx
+#define wshort %esi
+
+// Add %rbx * m into a register-pair (high,low) maintaining consistent
+// carry-catching with carry (negated, as bitmask) and using %rax and %rdx
+// as temporaries
+
+#define mulpadd(carry,high,low,m)       \
+        movq    m, %rax ;                 \
+        mulq    %rbx;                    \
+        subq    carry, %rdx ;             \
+        addq    %rax, low ;               \
+        adcq    %rdx, high ;              \
+        sbbq    carry, carry
+
+// Initial version assuming no carry-in
+
+#define mulpadi(carry,high,low,m)       \
+        movq    m, %rax ;                 \
+        mulq    %rbx;                    \
+        addq    %rax, low ;               \
+        adcq    %rdx, high ;              \
+        sbbq    carry, carry
+
+// End version not catching the top carry-out
+
+#define mulpade(carry,high,low,m)       \
+        movq    m, %rax ;                 \
+        mulq    %rbx;                    \
+        subq    carry, %rdx ;             \
+        addq    %rax, low ;               \
+        adcq    %rdx, high
+
+// Core one-step Montgomery reduction macro. Takes input in
+// [d7;d6;d5;d4;d3;d2;d1;d0] and returns result in [d7;d6;d5;d4;d3;d2;d1],
+// adding to the existing contents, re-using d0 as a temporary internally
+//
+// We want to add (2^384 - 2^128 - 2^96 + 2^32 - 1) * w
+// where w = [d0 + (d0<<32)] mod 2^64
+//
+//       montredc(d7,d6,d5,d4,d3,d2,d1,d0)
+//
+// This particular variant, with its mix of addition and subtraction
+// at the top, is not intended to maintain a coherent carry or borrow out.
+// It is assumed the final result would fit in [d7;d6;d5;d4;d3;d2;d1].
+// which is always the case here as the top word is even always in {0,1}
+
+#define montredc(d7,d6,d5,d4,d3,d2,d1,d0)                               \
+/* Our correction multiplier is w = [d0 + (d0<<32)] mod 2^64 */         \
+                movq    d0, %rbx ;                                        \
+                shlq    $32, %rbx ;                                        \
+                addq    d0, %rbx ;                                        \
+/* Construct [%rcx;%rdx;%rax;-] = (2^384 - p_384) * w */                   \
+/* We know the lowest word will cancel so we can re-use d0 as a temp */ \
+                xorl    %ecx, %ecx ;                                       \
+                movq    $0xffffffff00000001, %rax ;                        \
+                mulq    %rbx;                                            \
+                movq    %rdx, d0 ;                                        \
+                movq    $0x00000000ffffffff, %rax ;                        \
+                mulq    %rbx;                                            \
+                addq    d0, %rax ;                                        \
+                adcq    %rbx, %rdx ;                                       \
+                adcl    %ecx, %ecx ;                                       \
+/*  Now subtract that and add 2^384 * w */                              \
+                subq    %rax, d1 ;                                        \
+                sbbq    %rdx, d2 ;                                        \
+                sbbq    %rcx, d3 ;                                        \
+                sbbq    $0, d4 ;                                          \
+                sbbq    $0, d5 ;                                          \
+                sbbq    $0, %rbx ;                                         \
+                addq    %rbx, d6 ;                                        \
+                adcq    $0, d7
+
+bignum_tomont_p384_alt:
+
+// We are essentially just doing a Montgomery multiplication of x and the
+// precomputed constant y = 2^768 mod p, so the code is almost the same
+// modulo a few registers and the change from loading y[i] to using constants,
+// plus the easy digits y[4] = 1 and y[5] = 0 being treated specially.
+// Because there is no y pointer to keep, we use one register less.
+
+        pushq   %rbx
+        pushq   %r12
+        pushq   %r13
+        pushq   %r14
+        pushq   %r15
+
+// Do row 0 computation, which is a bit different:
+// set up initial window [%r14,%r13,%r12,%r11,%r10,%r9,%r8] = y[0] * x
+// Unlike later, we only need a single carry chain
+
+        movq    $0xfffffffe00000001, %rbx
+        movq    (x), %rax
+        mulq    %rbx
+        movq    %rax, %r8
+        movq    %rdx, %r9
+
+        movq    8(x), %rax
+        mulq    %rbx
+        xorl    %r10d, %r10d
+        addq    %rax, %r9
+        adcq    %rdx, %r10
+
+        movq    16(x), %rax
+        mulq    %rbx
+        xorl    %r11d, %r11d
+        addq    %rax, %r10
+        adcq    %rdx, %r11
+
+        movq    24(x), %rax
+        mulq    %rbx
+        xorl    %r12d, %r12d
+        addq    %rax, %r11
+        adcq    %rdx, %r12
+
+        movq    32(x), %rax
+        mulq    %rbx
+        xorl    %r13d, %r13d
+        addq    %rax, %r12
+        adcq    %rdx, %r13
+
+        movq    40(x), %rax
+        mulq    %rbx
+        xorl    %r14d, %r14d
+        addq    %rax, %r13
+        adcq    %rdx, %r14
+
+        xorl    %r15d, %r15d
+
+// Montgomery reduce the zeroth window
+
+        montredc(%r15, %r14,%r13,%r12,%r11,%r10,%r9,%r8)
+
+// Add row 1
+
+        movq    $0x0000000200000000, %rbx
+        mulpadi(%r8,%r10,%r9,(x))
+        mulpadd(%r8,%r11,%r10,8(x))
+        mulpadd(%r8,%r12,%r11,16(x))
+        mulpadd(%r8,%r13,%r12,24(x))
+        mulpadd(%r8,%r14,%r13,32(x))
+        mulpadd(%r8,%r15,%r14,40(x))
+        negq    %r8
+
+// Montgomery reduce window 1
+
+        montredc(%r8, %r15,%r14,%r13,%r12,%r11,%r10,%r9)
+
+// Add row 2
+
+        movq    $0xfffffffe00000000, %rbx
+        mulpadi(%r9,%r11,%r10,(x))
+        mulpadd(%r9,%r12,%r11,8(x))
+        mulpadd(%r9,%r13,%r12,16(x))
+        mulpadd(%r9,%r14,%r13,24(x))
+        mulpadd(%r9,%r15,%r14,32(x))
+        mulpadd(%r9,%r8,%r15,40(x))
+        negq    %r9
+
+// Montgomery reduce window 2
+
+        montredc(%r9, %r8,%r15,%r14,%r13,%r12,%r11,%r10)
+
+// Add row 3
+
+        movq    $0x0000000200000000, %rbx
+        mulpadi(%r10,%r12,%r11,(x))
+        mulpadd(%r10,%r13,%r12,8(x))
+        mulpadd(%r10,%r14,%r13,16(x))
+        mulpadd(%r10,%r15,%r14,24(x))
+        mulpadd(%r10,%r8,%r15,32(x))
+        mulpadd(%r10,%r9,%r8,40(x))
+        negq    %r10
+
+// Montgomery reduce window 3
+
+        montredc(%r10, %r9,%r8,%r15,%r14,%r13,%r12,%r11)
+
+// Add row 4. The multiplier y[4] = 1, so we just add x to the window
+// while extending it with one more digit, initially this carry
+
+        xorq    %r11, %r11
+        addq    (x), %r12
+        adcq    8(x), %r13
+        adcq    16(x), %r14
+        adcq    24(x), %r15
+        adcq    32(x), %r8
+        adcq    40(x), %r9
+        adcq    %r11, %r10
+        adcq    %r11, %r11
+
+// Montgomery reduce window 4
+
+        montredc(%r11, %r10,%r9,%r8,%r15,%r14,%r13,%r12)
+
+// Add row 5, The multiplier y[5] = 0, so this is trivial: all we do is
+// bring down another zero digit into the window.
+
+        xorq    %r12, %r12
+
+// Montgomery reduce window 5
+
+        montredc(%r12, %r11,%r10,%r9,%r8,%r15,%r14,%r13)
+
+// We now have a pre-reduced 7-word form [%r12;%r11;%r10;%r9;%r8;%r15;%r14]
+
+// We know, writing B = 2^{6*64} that the full implicit result is
+// B^2 c <= z + (B - 1) * p < B * p + (B - 1) * p < 2 * B * p,
+// so the top half is certainly < 2 * p. If c = 1 already, we know
+// subtracting p will give the reduced modulus. But now we do a
+// comparison to catch cases where the residue is >= p.
+// First set [0;0;0;w;v;u] = 2^384 - p_384
+
+        movq    $0xffffffff00000001, u
+        movl    $0x00000000ffffffff, vshort
+        movl    $0x0000000000000001, wshort
+
+// Let dd = [%r11;%r10;%r9;%r8;%r15;%r14] be the topless 6-word intermediate result.
+// Set CF if the addition dd + (2^384 - p_384) >= 2^384, hence iff dd >= p_384.
+
+        movq    %r14, d
+        addq    u, d
+        movq    %r15, d
+        adcq    v, d
+        movq    %r8, d
+        adcq    w, d
+        movq    %r9, d
+        adcq    $0, d
+        movq    %r10, d
+        adcq    $0, d
+        movq    %r11, d
+        adcq    $0, d
+
+// Now just add this new carry into the existing %r12. It's easy to see they
+// can't both be 1 by our range assumptions, so this gives us a {0,1} flag
+
+        adcq    $0, %r12
+
+// Now convert it into a bitmask
+
+        negq    %r12
+
+// Masked addition of 2^384 - p_384, hence subtraction of p_384
+
+        andq    %r12, u
+        andq    %r12, v
+        andq    %r12, w
+
+        addq   u, %r14
+        adcq   v, %r15
+        adcq   w, %r8
+        adcq   $0, %r9
+        adcq   $0, %r10
+        adcq   $0, %r11
+
+// Write back the result
+
+        movq    %r14, (z)
+        movq    %r15, 8(z)
+        movq    %r8, 16(z)
+        movq    %r9, 24(z)
+        movq    %r10, 32(z)
+        movq    %r11, 40(z)
+
+// Restore registers and return
+
+        popq    %r15
+        popq    %r14
+        popq    %r13
+        popq    %r12
+        popq    %rbx
+
+        ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
diff --git a/x86_att/p384/bignum_triple_p384.S b/x86_att/p384/bignum_triple_p384.S
index 515da2f77..4620fe56c 100644
--- a/x86_att/p384/bignum_triple_p384.S
+++ b/x86_att/p384/bignum_triple_p384.S
@@ -55,9 +55,7 @@ bignum_triple_p384:
 
 // Multiply, accumulating the result as 2^384 * h + [d5;d4;d3;d2;d1;d0]
 // but actually immediately producing q = h + 1, our quotient approximation,
-// by adding 1 to it. Note that by hypothesis x is reduced mod p_384, so our
-// product is <= (2^64 - 1) * (p_384 - 1) and hence  h <= 2^64 - 2, meaning
-// there is no danger this addition of 1 could wrap.
+// by adding 1 to it.
 
                 xorl    ashort, ashort
 
diff --git a/x86_att/p384/bignum_triple_p384_alt.S b/x86_att/p384/bignum_triple_p384_alt.S
new file mode 100644
index 000000000..aa7ddd7b1
--- /dev/null
+++ b/x86_att/p384/bignum_triple_p384_alt.S
@@ -0,0 +1,151 @@
+/*
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License").
+ * You may not use this file except in compliance with the License.
+ * A copy of the License is located at
+ *
+ *  http://aws.amazon.com/apache2.0
+ *
+ * or in the "LICENSE" file accompanying this file. This file is distributed
+ * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied. See the License for the specific language governing
+ * permissions and limitations under the License.
+ */
+
+// ----------------------------------------------------------------------------
+// Triple modulo p_384, z := (3 * x) mod p_384
+// Input x[6]; output z[6]
+//
+//    extern void bignum_triple_p384_alt
+//     (uint64_t z[static 6], uint64_t x[static 6]);
+//
+// The input x can be any 6-digit bignum, not necessarily reduced modulo p_384,
+// and the result is always fully reduced, i.e. z = (3 * x) mod p_384.
+//
+// Standard x86-64 ABI: RDI = z, RSI = x
+// ----------------------------------------------------------------------------
+
+
+        .globl  bignum_triple_p384_alt
+        .text
+
+#define z %rdi
+#define x %rsi
+
+#define d0 %r8
+#define d1 %r9
+#define d2 %r10
+#define d3 %r11
+#define d4 %rbx
+#define d5 %rsi
+
+#define a %rax
+#define c %rcx
+#define q %rcx
+#define d %rdx
+
+#define ashort %eax
+#define cshort %ecx
+#define qshort %ecx
+#define dshort %edx
+
+bignum_triple_p384_alt:
+
+// We seem to need (just!) one extra register, which we need to save and restore
+
+                pushq   %rbx
+
+// Multiply, accumulating the result as 2^384 * h + [d5;d4;d3;d2;d1;d0]
+// but actually immediately producing q = h + 1, our quotient approximation,
+// by adding 1 to it.
+
+                movl    $3, cshort
+
+                movq    (x), a
+                mulq    c
+                movq    a, d0
+                movq    d, d1
+
+                movq    8(x), a
+                xorq    d2, d2
+                mulq    c
+                addq    a, d1
+                adcq    d, d2
+
+                movq    16(x), a
+                xorq    d3, d3
+                mulq    c
+                addq    a, d2
+                adcq    d, d3
+
+                movq    24(x), a
+                xorq    d4, d4
+                mulq    c
+                addq    a, d3
+                adcq    d, d4
+
+                movq    32(x), a
+                mulq    c
+                addq    a, d4
+                adcq    $0, d
+
+                movq    40(x), a
+                movq    d, d5
+                mulq    c
+                addq    a, d5
+
+                movl    $1, qshort
+                adcq    d, q
+
+// Initial subtraction of z - q * p_384, with bitmask c for the carry
+// Actually done as an addition of (z - 2^384 * h) + q * (2^384 - p_384)
+// which, because q = h + 1, is exactly 2^384 + (z - q * p_384), and
+// therefore CF <=> 2^384 + (z - q * p_384) >= 2^384 <=> z >= q * p_384.
+
+                movq    q, d
+                shlq    $32, d
+                movq    q, a
+                subq    d, a
+                sbbq    $0, d
+
+                addq    a, d0
+                adcq    d, d1
+                adcq    q, d2
+                adcq    $0, d3
+                adcq    $0, d4
+                adcq    $0, d5
+                sbbq    d, d
+                notq    d
+
+// Now use that mask for a masked addition of p_384, which again is in
+// fact done by a masked subtraction of 2^384 - p_384, so that we only
+// have three nonzero digits and so can avoid using another register.
+
+                movl    $0x00000000ffffffff, qshort
+                xorl    ashort, ashort
+                andq    d, q
+                subq    q, a
+                negq    d
+
+                subq    a, d0
+                movq    d0, (z)
+                sbbq    q, d1
+                movq    d1, 8(z)
+                sbbq    d, d2
+                movq    d2, 16(z)
+                sbbq    $0, d3
+                movq    d3, 24(z)
+                sbbq    $0, d4
+                movq    d4, 32(z)
+                sbbq    $0, d5
+                movq    d5, 40(z)
+
+// Return
+
+                popq    %rbx
+                ret
+
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits
+#endif
